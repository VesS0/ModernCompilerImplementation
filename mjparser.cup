package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import java.util.*;
import java.util.stream.IntStream;
import rs.ac.bg.etf.pp1.MJParser.SCOPE;
import rs.etf.pp1.mj.runtime.Code;

// import java.io.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;

parser code {:
///
    boolean errorDetected = false;    
    boolean errorRecovery = false;
    
    //NIVO A
    int globalVarCount = 0; //
    int localVarCount = 0;
    int globalConstCount = 0; //
    //NIVO B
    int globalFuncClassCount = 0; //
    int staticFuncClassCount = 0; //
    int funcMainCount = 0;
    int formArgsCount = 0;//
    //NIVO C
    int methodClassCount = 0; //
    int varClassDeclCount = 0; //
    
    Boolean inMain = false;
    Boolean inClass = false;
    Boolean inMethod = false;
    
    
    int printCallCount = 0;
///
    public static enum SCOPE
    {
        METHOD_SCOPE,
        CLASS_SCOPE,
        CLASS_METHOD_SCOPE,
        MAIN_SCOPE
    }
    
    Stack<SCOPE> nestedScopes = new Stack<SCOPE>();
    
    int globalVariableCount = 0;
    int globalConstVariableCount = 0;
    int mainVariableCount = 0;
    int mainFunctionCallsCount = 0;
    int globalClassFunctionCount = 0;
    int staticClassFunctionCount = 0;
    int formalParamsCount = 0;
    int globalFunctionCount = 0;
    int classCount = 0;
    int classVariableCount = 0;
    
    boolean errorEncountered = false;
    boolean errorHandled = false;
    boolean returnHappend = false;
    
    Struct lastMethType = null;
    Struct lastType = null;
    Obj lastClass = null;
    Obj lastMethod = null;
    Obj extendedClass = null;
    String curTypeName = "";
    
    public String StructToTypeName(Struct structKind)
    {
        switch(structKind.getKind())
        {
            case 0:
            return "None";
            case 1:
            return "Int";
            case 2:
            return "Char";
            case 3:
            return "Array";
            case 4:
            return "Class";
            case 5:
            return "Bool";
            default:
            return "No such kind";
        }
    }
    
    void ReportError(String errorMessage)
    {
        errorEncountered = true;
        log.debug(errorMessage);
    }
    
    void ReportVarDeclError(char errorChar)
    {
        errorEncountered = true;
        if (nestedScopes.empty())
        {
            log.debug("Doslo je do greske prilikom deklaracije globalne promenljive pre znaka \""+errorChar + '\"');
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            log.debug("Doslo je do greske prilikom definicije lokalne promenljive unutrasnje klase pre znaka \"" +errorChar+ '\"');
            return;
        }
    }
    
    void IncreaseVariableCount()
    {
        
        if (nestedScopes.empty()) // Global scope
        {
            globalVariableCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.MAIN_SCOPE)
        {
            mainVariableCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            classVariableCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.METHOD_SCOPE)
        {
            return;
        }
    }
    
    void IncreaseConstVariableCount()
    {
        if (nestedScopes.empty()) // Global scope
        {
            globalConstVariableCount++;
        }
    }
    
    void IncreaseFunctionCount()
    {
        if (nestedScopes.empty()) // Global Scope
        {
            globalFunctionCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            globalClassFunctionCount++;
        }
    }
    
    void IncreaseStaticFunctionCount()
    {
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            staticClassFunctionCount++;
        }
        else
        {
         report_error(" Static se koristi samo za metode klasa", null);
        }
        if (nestedScopes.empty()) // Global Scope
        {
            // globalFunctionCount++;
            return;
        }
        
        
         
    }
    
    void IncreaseFunctionCallsCount()
    {
        if (nestedScopes.empty()) // Global scope
        {
            return;
        }
        
        if (nestedScopes.peek() == SCOPE.MAIN_SCOPE)
        {
            mainFunctionCallsCount++;   
            return;
        }
    }
    
    void InScope(SCOPE newScope)
    {
        if (nestedScopes.empty())
        {
            nestedScopes.push(newScope);
            return;
        }
        
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE && newScope == SCOPE.METHOD_SCOPE)
        {
            nestedScopes.push(SCOPE.CLASS_METHOD_SCOPE);
            return;
        }
        nestedScopes.push(newScope);   
    }
    
    void OutOfCurrentScope()
    {
        if (!nestedScopes.empty())
        {
            nestedScopes.pop();
        }
    }
    
    void VariableDeclaration(String name, int nameLocation, int objectType, 
        Obj assignedType, int assignLocation, boolean isConst)
    {
        if( Tab.currentScope.findSymbol(name) != null)
        {
             report_error(" " + name + " je vec deklarisano ("+nameLocation+")" ,null );
             return;
        }
        
        if(assignedType != null && assignedType.getType() != lastType)
        {
            report_error("neispravan tip promenljive koja se dodeljuje "+ StructToTypeName(lastType) +" = "+ StructToTypeName(assignedType.getType()) +"("+assignLocation+")",null );
            return;
        }
        
        if (lastType == null || lastType == Tab.noType)
        {
            report_error("Greska pri deklaraciji promenljive", null);
            return; 
        }
        
        Tab.insert(objectType, name, lastType);
        
        if (isConst) IncreaseConstVariableCount();
        else IncreaseVariableCount();
        
        report_info("Definisana promenljiva " + name + " tipa: "+StructToTypeName(lastType)+ " na liniji "+nameLocation, null);
    }

    // Overloading
    void VariableDeclaration(String name, int nameLocation, int objectType)
    {
        VariableDeclaration(name, nameLocation, objectType, null, 0, false);
    }
    
    void VariableDeclaration(String name, int nameLocation, int objectType, Obj assignedType, int assignedLocation)
    {
        VariableDeclaration(name, nameLocation, objectType, assignedType, assignedLocation, false);
    }

    void ClassDeclaration(String className, int classLocation)
    {
        if(Tab.currentScope.findSymbol(className) != null)
        {
            report_error("Klasa sa imenom " + className + "je vec deklarisana ("+classLocation +")", null);
            return;
        }
        
        lastClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
        InScope(SCOPE.CLASS_SCOPE);
        Tab.openScope();
        classCount++;
        
        report_info("Definisana klasa " + className + " na liniji "+classLocation,null );
    }
    
    void ClassEnding()
    {
        if(extendedClass != null) {
            for (Obj obj : extendedClass.getType().getMembers()) {
                if(Tab.currentScope.findSymbol(obj.getName()) == null)
                      Tab.insert(obj.getKind(), obj.getName(), obj.getType());
                }
       }   
       extendedClass = null;
       
        // if (!nestedScopes.empty() && nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            OutOfCurrentScope();
            Tab.chainLocalSymbols(lastClass.getType());
            Tab.closeScope();
            lastClass = null;
        }          
    }
    
    void MethodDeclaration(String methodName, int methodLocation, Struct type, int typeLocation, boolean isStaticMethod)
    {
        if(Tab.currentScope.findSymbol(methodName) != null)
        {
              report_error("Naziv metode "+methodName + "je vec u upotrebi ("+methodLocation+")", null);
              return;
        }
        
        if(extendedClass != null) 
        {
           for (Obj o : extendedClass.getType().getMembers()) 
           {
               if(o.getKind() == Obj.Meth && o.getName().equals(methodName)) 
               if(o.getType().getElemType().getKind() == 6) 
                   {
                   // error
                   return;
                   }
          }
        }
        if (methodName.equals("main"))
        {
            if(type != Tab.noType)
            {
                report_error("Main mora biti tipa \"void\" ("+typeLocation + ")",null);
                return;
            }
            if (isStaticMethod)
            {
                report_error("Main ne sme biti staticka metoda ("+methodLocation+")",null);
                return;
            }

            InScope(SCOPE.MAIN_SCOPE);
            InsertMethod(methodName, methodLocation, type.getKind());
            Tab.openScope();
            lastMethType = type;
            return;
        } 
        
       if(isStaticMethod) 
       {
           InsertMethod(methodName, methodLocation, 6);
       }
       else 
       {
           InsertMethod(methodName, methodLocation, type.getKind());
       }
       
       lastMethType = type;
       InScope(SCOPE.METHOD_SCOPE);
       Tab.openScope();
    }
    
    void InsertMethod(String methodName, int methodLocation, int methodType)
    {
           if (methodType == 7 ) IncreaseFunctionCount();
           else IncreaseStaticFunctionCount();
           lastType.setElementType(new Struct(methodType));
           lastMethod = Tab.insert(Obj.Meth, methodName, lastType);
           report_info("Ubacena metoda "+methodName+" u tabelu simbola na liniji "+ methodLocation,null );
    }
    
    void MethodEnding()
    {
        // if (!nestedScopes.empty() &&
        // nestedScopes.peek() == SCOPE.METHOD_SCOPE ||
        // nestedScopes.peek() == SCOPE.MAIN_SCOPE || 
        // nestedScopes.peek() == SCOPE.CLASS_METHOD_SCOPE)
        {
            HandleScopeEnd(lastMethod);
            lastMethod = null;
            lastMethType = null;
        }
    }
    
    void HandleScopeEnd(Obj scopeName)
    {
        OutOfCurrentScope();
        Tab.chainLocalSymbols(scopeName);
        Tab.closeScope();
    }

    void HandleProgramEnd(Obj progName, int programLocation)
    {
        if(Tab.find("main") == Tab.noObj)
        {
            report_error("Metoda \"main\" nije pronadjena! ("+programLocation+")", null);
        }
        
        HandleScopeEnd(progName);
    }
    
    Struct CheckTypeAndUpdateLastType(String typeName, int nameLocation)
    {
        Obj typeNode = Tab.find(typeName);
        
        if (Obj.Type == typeNode.getKind()) 
        {
             curTypeName = typeName;
             return lastType = typeNode.getType();
        }
        
        lastType = Tab.noType;
        if (typeNode == Tab.noObj) 
        {
            report_error("U tabeli simbola nije pronadjen tip " + typeName + " referenciran na lokaciji "+nameLocation, null);            
            return Tab.noType;
        }
        
        report_error(" ime " + typeName + " ne predstavlja tip "+nameLocation, null);
        return Tab.noType;
    }

    Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
    public void report_detect(int line, Obj info) {
        StringBuilder msg = new StringBuilder("Pretraga na " + line + "("); 
        msg.append (info.getName());
        msg.append ("), nadjeno ");
        
        log.info(msg.toString());
    }
:}

scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null) 
        log.info(s.toString() + " " + s.value.toString());
    return s;
:}

init with {:
    Tab.init(); // Universe scope
    Tab.currentScope.addToLocals(new Obj(Obj.Type, "bool",CUP$MJParser$actions.boolType));
:}

action code {:
int numberOfNestedFors = 0;
boolean isThisSpecified = false;
Obj backupDesig = null;
public static final int STATIC = 6;
public static final int Bool = 5;
public static final Struct boolType = new Struct(Struct.Bool);

Obj lastDesignator = null;
///
    String curTypeName = "";
    Struct curType = null;
    Struct curMethType = null;
    Obj curMeth = null;
    Obj curClass = null;
    Obj curDesig = null;
    Obj extendedClass = null;
    
    Collection<Obj> membersClass = null; 
    List<Struct> funcParams = new LinkedList<Struct>();
    String desigName;
    
    int formParams = 0;
    boolean statMeth = false;
    boolean retNeed = false;
    boolean thisSpecified = false;
    boolean staticVar = false;
    boolean varArgs = false;
    
    int inFor = 0;

    Stack<Integer> forStack = new Stack<Integer>();
    Stack<Integer> cond = new Stack<Integer>();
    Stack<Integer> andAdr = new Stack<Integer>();    
    Stack<Integer> orAdr = new Stack<Integer>();     
    Stack<Integer> endAdr = new Stack<Integer>();
    Stack<Integer> forAdr = new Stack<Integer>();
    Stack<Integer> endFor = new Stack<Integer>();
    Stack<Integer> noCond = new Stack<Integer>();
    Stack<Integer> desi = new Stack<Integer>();
///
Collection<Obj> classFields = null;
List<Struct> actParams= new LinkedList<Struct>();
    
    public void EnteredFor()
    {
        ++numberOfNestedFors;
    }
    public void ExitedFor()
    {
        --numberOfNestedFors;
    }
    public boolean IsNotInForLoop()
    {
        return numberOfNestedFors == 0;
    }
    
    void ReturnCallCheck(int returnLocation, Struct expr)
    {
       parser.returnHappend = true;
        
        if(parser.lastMethod == null )
        {
            parser.report_error("Return mora biti iz funkcije pozvan ("+returnLocation+")", null);
            return;
        }
        
        if (parser.lastMethType == Tab.noType)
        {
            parser.report_error("Return mora biti iz funkcije pozvan ("+returnLocation+")", null);
            return;
        }

        if (expr != null && expr.getKind() != parser.lastMethType.getKind())
        {
            parser.report_error("Funkcija vraca tip "+ parser.StructToTypeName(expr) +" A mora vracati tip "+ 
            parser.StructToTypeName(parser.lastMethod.getType()) + "("+returnLocation+")", null);
        }
    }
    
int [] correctObjTypes = {Obj.Var, Obj.Elem, Obj.Fld };
int [] correctStructTypes = {Struct.Int, Struct.Char, Struct.None};
    
    public boolean IsObjectVarElemOrFieldError(Obj designator, int designatorLocation)
    {
        if (designator == null)
            return false;
        if (!IntStream.of(correctObjTypes).anyMatch(x -> x == designator.getKind()))
        {
            parser.report_error(" " + designator.getName() + 
            " mora biti  promenljiva, element niza ili polje unutar objekta ("+ designatorLocation+")", null);
            return false;
        }
        return true;
    }
    
    public boolean IsStructIntCharOrNone(Struct expr, int exprLocation)
    {
        if (!IntStream.of(correctStructTypes).anyMatch(x -> x == expr.getKind()))
        {       
            parser.report_error(" " + expr.getKind() + " mora biti tipa int, char ili bool. ("+exprLocation+")", null);                
            return false;
        }
        return true;
    }
    
    public void CorrectTypesForFunctionCalls(Obj designator, int designatorLocation)
    {
        if (IsObjectVarElemOrFieldError(designator, designatorLocation) &&
            IsStructIntCharOrNone(designator.getType(), designatorLocation))
         {
            parser.IncreaseFunctionCallsCount(); 
         }
    }
    
    public boolean IsAssignable(Obj design, Struct expr)
    {
        if(expr.assignableTo(design.getType())) // If expr is assignable to design
        {
            return true;
        }
        
        if( expr.getKind() == design.getType().getKind() || // If they are not same Struct type
            expr.getElemType() != design.getType().getElemType() || // If they are not same Struct.ElementType
            expr.getNumberOfFields() != design.getType().getNumberOfFields() || // If they don't have same params of fields
            expr.getMembers() == design.getType().getMembers()) // If they don't have same type of fields
        {
            return false;
        }
  /*
        if (design.getType().getKind() == Struct.Array && // If designator is Struct.Array
            expr.getElemType() == null && // Expression is not array
            !expr.assignableTo(design.getType().getElemType())) // if expr is assignable to type of designator elements
        {
            return false;
        }
     */   
        return true;
    }
    
    Obj GetResultIfBothInt(Obj result, int resultLocation, Struct term)
    {
        
        if (result.getType().getKind() == Struct.Int && term.getKind() == Struct.Int)
        {
            return result;
        }
        
       parser.report_error("Poslali ste tipove" + parser.StructToTypeName(parser.lastMethod.getType()) +
            " i " + parser.StructToTypeName(term) + " a moraju biti int ("+resultLocation+")", null);
        return Tab.noObj;
    }
    
    void SaveExtendedClassMembers(Struct extendsClass)
    {
        if(extendsClass != null && extendsClass != Tab.noType && extendsClass.getKind() == Struct.Class) 
        {
            for (Obj obj : extendsClass.getMembers()) 
            {
                if(Tab.currentScope.findSymbol(obj.getName()) == null)
                      Tab.insert(obj.getKind(), obj.getName(), obj.getType());
            }
        }
    }
    
    boolean CheckIfArgumentsMatch(Obj designator, int designatorLocation, int args, int argsLocation)
    {
        if(designator.getKind() != Obj.Meth)
        {
              parser.report_error("Funkcija mora biti deklarisana pre poziva ("+designatorLocation+")", null);
              return false;
        }  
                                
        if(args != designator.getLevel()) 
        {
                parser.report_error(" Broj argumenata funkcije nije dobar."+ designator.getName() +" ("+argsLocation+")", null);
                return false;
        }
        
        for(int i = 0; i < args; i++) 
        {
             Obj o = ((Obj) designator.getLocalSymbols().toArray()[i]);
             Struct s = actParams.get(actParams.size() - (args - i)); // sta ce aoba
             if(!o.getType().compatibleWith(s))
                if(!(o.getType().getKind() != Struct.Class && o.getType().getKind() == s.getKind() && o.getType().getElemType() == s.getElemType() && o.getType().getNumberOfFields() == s.getNumberOfFields()))
             //if (!o.getType().compatibleWith(s) && !IsAssignable(o,s)) 
             {
                 parser.report_error(" Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva. ("+argsLocation+")", null);
                 return false;
             }
        }
        parser.IncreaseFunctionCallsCount();
        return true;
    }
    
    public boolean ThisIsSpecified(String name, int nameLocation)
    {
        if(!"this".equals(name)) return false;
     
        if(parser.lastMethod != null) 
        {
          if(parser.nestedScopes.empty() || parser.nestedScopes.peek() != SCOPE.CLASS_METHOD_SCOPE ||
          parser.lastMethod.getType().getElemType().getKind() == STATIC)
          {
               parser.report_error("This se moze navoditi samo u nestatickim metodama ("+nameLocation+")", null);
          }
          
          isThisSpecified = true;
       } 
       return true;
    }                       
:}

terminal BREAK, CLASS, CONST, CONTINUE, ELSE, EXTENDS, FOR, IF, NEW, PRINT, PROG, READ, RETURN, STATIC, VOID;
terminal LBRACE, RBRACE, LBRACK, RBRACK, LPAREN, RPAREN;
terminal ADD, SUB, MUL, DIV, MOD;
terminal ASSIGN, ASSIGN_ADD, ASSIGN_SUB, ASSIGN_MUL, ASSIGN_DIV, ASSIGN_MOD;
terminal EQUAL, NOT_EQUAL, GREATER_EQUAL, LESS_EQUAL, GREATER, LESS;
terminal DEC, INC, OR, AND;
terminal SEMI, COMMA, DOT;
terminal Boolean BOOL;
terminal char CHAR;

terminal Integer NUMBER;
terminal String IDENT;
non terminal InClassStart, InClassEnd, InMethodStart, InMethodEnd;
non terminal ClassDecl, ClassVarDecl, ClassVarDeclListOpt;
non terminal MethodDecl, MethodDeclOpt, MethodDeclListOpt, MethodVarDecl, MethodVarDeclListOpt, MethodIdentList;
non terminal DesignatorOpt, DesignatorStatement;
non terminal Addop, AddopLeft, AddopRight; 
non terminal Integer Mulop, MulopLeft, MulopRight;       
non terminal VarArgs, VarDecl, VarDeclList, Var;
non terminal ConstIdent, ConstDecl, ConstDeclList;
non terminal FormalParamDecl;
non terminal Statement, StatementListOpt, StatementIfElse;
non terminal Condition, CondTerm, CondFact, CondOpt, ClassName;

non terminal Decl, DeclListOpt;
non terminal Integer NumOpt;
non terminal Assignop, AssignopError;
non terminal Program;
non terminal Integer Relop;
non terminal Obj ProgramName, Const, Designator, AddopTermList, MulopFactorList, Term, Factor, DesignatorListOpt, DesignatorIdent;
non terminal Boolean StaticOpt;
non terminal Struct Type, TypeVoid, Expression, AddopTermCombList, ExtendsOpt;
non terminal Integer ActParsListOpt, FormParamsOpt, FormalParamList, ActPars;
non terminal String MethodName;

precedence left ELSE;

Program ::= PROG ProgramName:p DeclListOpt LBRACE MethodDeclListOpt RBRACE 
            {:
            if(Tab.find("main") == Tab.noObj) 
                    parser.report_error(" Mora postojati metoda main u programu", pleft);
            Code.dataSize = Tab.currentScope().getnVars();
            Tab.chainLocalSymbols(p);
            Tab.closeScope();                 
            :}            
            ;
            
ProgramName ::= IDENT:pName
                {:
                RESULT = Tab.insert(Obj.Prog, pName, Tab.noType);
                Tab.openScope();
                :};

DeclListOpt ::= DeclListOpt Decl  
                |
                /* epsilon */ 
                ;
                
Decl ::= ConstDecl | VarDecl | ClassDecl;

//CONST DECLARATION
ConstDecl ::= CONST Type ConstDeclList SEMI ;

ConstDeclList ::= ConstDeclList COMMA ConstIdent 
                |
                ConstIdent
                ;
                
ConstIdent ::= IDENT:constName ASSIGN Const:type
                {: parser.IncreaseConstVariableCount();
                    if( Tab.currentScope.findSymbol(constName) != null)
                      parser.report_error(" " + constName + " vec deklarisano", constNameleft);
                      else {
                          if(type.getType() != curType)
                              parser.report_error(": neispravan tip promenljive koja se dodeljuje ", typeleft);                              
                          else {
                              Tab.insert(Obj.Con, constName, curType);
                              parser.report_info("Definisana konstanta " + constName + " tipa: " +curType.getKind()+ " na liniji " + constNameleft, null);
                          }
                  }  
                :}
                ;

Const ::= NUMBER
            {: RESULT = new Obj(Obj.Con, "", Tab.intType); :}
            | 
            CHAR
            {: RESULT = new Obj(Obj.Con, "", Tab.charType); :}
            | 
            BOOL
            {: RESULT = new Obj(Obj.Con, "", boolType); :}
            ;

//VAR DECLARATION
                
VarDecl ::= Type VarDeclList SEMI
            |
            Type error SEMI
            {:
            parser.errorRecovery = true;
                if(parser.inClass)
                parser.log.debug("Oporavak od greske do ; pri deklaraciji polja unutrasnje klase   "  );
                else
                parser.log.debug("Oporavak od greske do ; pri definiciji globalne promenljive   "  );
            :}
            ;

VarDeclList ::= VarDeclList COMMA Var
                |
                error COMMA Var
                {:
                parser.errorRecovery = true;
                if(parser.inClass)
                parser.log.debug("Oporavak od greske do , pri deklaraciji polja unustrasnje klase   "  );               
                else
                parser.log.debug("Oporavak od greske do , pri definiciji globalne promenljive   "  );               
                :}
                |
                Var
                ;
                
Var ::= IDENT:identName
{:parser.IncreaseVariableCount();
               if(parser.inMain) {
                    if( Tab.currentScope.findSymbol(identName) != null)
                      parser.report_error(" " + identName + " vec deklarisano", identNameleft);
                      else {
                          if( curType != null && curType != Tab.noType)
                              Tab.insert(Obj.Var, identName, curType);
                              parser.report_info("Definisana lokalna promenljiva " + identName + " tipa "+curType.getKind()+" na liniji " + identNameleft, null);
                          }
                    
                } else if(parser.inMethod) {
                    if( Tab.currentScope.findSymbol(identName) != null)
                      parser.report_error(" " + identName + " vec deklarisano", identNameleft);
                      else {
                          if( curType != null && curType != Tab.noType)
                     Tab.insert(Obj.Var, identName, curType);
                              parser.report_info("Definisana lokalna promenljiva " + identName + " tipa "+curType.getKind()+" na liniji " + identNameleft, null);
                          
                          }
                } else if(parser.inClass) {
                    if( Tab.currentScope.findSymbol(identName) != null)
                      parser.report_error(" " + identName + " vec deklarisano", identNameleft);
                      else {
                          if( curType != null && curType != Tab.noType)
                              Tab.insert(Obj.Var, identName, curType);
                              parser.report_info("Definisano polje klase " + identName + " tipa: "+ curType.getKind()+" na liniji " + identNameleft, null);
                          }
                } else {
                    if( Tab.currentScope.findSymbol(identName) != null)
                      parser.report_error(" " + identName + " vec deklarisano", identNameleft);
                      else {
                          if( curType != null && curType != Tab.noType)
                              Tab.insert(Obj.Var, identName, curType);
                              parser.report_info("Definisana globalna promenljiva " + identName + " tipa: "+curType.getKind()+ " na liniji " + identNameleft, null);
                          }    
              
                }
            :}

            |
            IDENT:identName LBRACK RBRACK
            {: 
            parser.IncreaseVariableCount();
                if(parser.inMain) {
                    if( Tab.currentScope.findSymbol(identName) != null)
                      parser.report_error(" " + identName + " vec deklarisano", identNameleft);
                      else {
                          if( curType != null && curType != Tab.noType)
                                Tab.insert(Obj.Var, identName, new Struct(Struct.Array, curType));
                              parser.report_info("Definisana lokalna promenljiva " + identName + " tipa "+Struct.Array+" na liniji " + identNameleft, null);
                          }
                } else if(parser.inMethod) {
                    if( Tab.currentScope.findSymbol(identName) != null)
                      parser.report_error(" " + identName + " vec deklarisano", identNameleft);
                      else {
                          if( curType != null && curType != Tab.noType)
                              Tab.insert(Obj.Var, identName, new Struct(Struct.Array, curType));
                              parser.report_info("Definisana lokalna promenljiva " + identName + " tipa: "+Struct.Array+" na liniji " + identNameleft, null);
                          }
                } else if(parser.inClass) {
                    if( Tab.currentScope.findSymbol(identName) != null)
                      parser.report_error(" " + identName + " vec deklarisano", identNameleft);
                      else {
                          if( curType != null && curType != Tab.noType)
                              Tab.insert(Obj.Var, identName, new Struct(Struct.Array, curType));
                              parser.report_info("Definisano polje klase " + identName + " tipa: "+Struct.Array+" na liniji " + identNameleft, null);
                          }
                } else {
                      if( Tab.currentScope.findSymbol(identName) != null)
                      parser.report_error(" " + identName + " vec deklarisano", identNameleft);
                      else {
                          if( curType != null && curType != Tab.noType)
                              Tab.insert(Obj.Var, identName, new Struct(Struct.Array, curType));
                              parser.report_info("Definisana globalna promenljiva " + identName + " tipa: "+ Struct.Array+" na liniji " + identNameleft, null);
                          }    
                }
            :}
            ;

Type ::= IDENT:typeName
        {:
        Obj typeNode = Tab.find(typeName);
        if (typeNode == Tab.noObj) {
            curType = Tab.noType;
            RESULT = Tab.noType;
            parser.report_error("Nije pronadjen tip " + typeName + " u tabeli simbola", null);            
        }
        else {
            if (Obj.Type == typeNode.getKind()) {
                curTypeName = typeName;
                curType = typeNode.getType();
                RESULT = typeNode.getType();               
            }
            else {
                parser.report_error(" ime " + typeName + " ne predstavlja tip ", typeNameleft);
                curType = Tab.noType;
                RESULT = Tab.noType;
            }
        }
        :}
        ;

//CLASS VAR DECLARATION

ClassVarDeclListOpt ::= ClassVarDeclListOpt ClassVarDecl
                    |
                    /*epsilon*/
                    ;
                    
ClassVarDecl ::= STATIC VarDecl
                {:
                staticVar = true;
                :}
                |
                VarDecl
                ;

//CLASS DECLARATION
ClassDecl ::= InClassStart CLASS ClassName ExtendsOpt LBRACE ClassVarDeclListOpt {: Tab.chainLocalSymbols(curClass.getType()); :} MethodDeclOpt RBRACE InClassEnd;

ClassName ::= IDENT:className
            {:
            if( Tab.currentScope.findSymbol(className) != null)
                      parser.report_error(" " + className + " vec deklarisano", classNameleft);
                      else {
                          curClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
                          Tab.openScope();
                          parser.report_info("Definisana klasa " + className + " na liniji " + classNameleft, null);
                  }    
            :};

InClassStart ::= {: 
                    parser.inClass = true; 
                    parser.classCount++;
                :};

InClassEnd ::= {: 
                if(extendedClass != null) {
                    for (Obj obj : extendedClass.getType().getMembers()) {
                        if(Tab.currentScope.findSymbol(obj.getName()) == null)
                            Tab.insert(obj.getKind(), obj.getName(), obj.getType());
                    }
                }
                
                extendedClass = null;
                parser.inClass = false; 
                Tab.chainLocalSymbols(curClass.getType());
                Tab.closeScope();
                curClass = null;
                :};

ExtendsOpt ::= EXTENDS Type:type
            {:
            if(!(type.getKind() == Struct.Class))
                parser.report_error(" klasa moze da se izvede samo iz unutrasnjih klasa glavnog programa ", typeleft);
             else 
                extendedClass = Tab.find(curTypeName);
            :}
            |
            EXTENDS error 
            {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske prilikom deklaracije prosirenja natklase   "  ); :}                                         
            |
            /* epsilon */
            {: extendedClass = null; :}
            ;
            
//METHOD VAR DECLARATION

MethodVarDeclListOpt ::= MethodVarDeclListOpt MethodVarDecl
                        |
                        /* epsilon */
                        ;

MethodVarDecl ::= Type MethodIdentList SEMI ;
                
MethodIdentList ::= MethodIdentList COMMA Var
                |
                Var
                ;

//METHOD DECLARATION

MethodDeclOpt ::= LBRACE MethodDeclListOpt RBRACE
                |
                /*epsilon*/
                ;

MethodDeclListOpt ::= MethodDeclListOpt MethodDecl
                    |
                    /* epsilon */
                    ;

MethodDecl ::= InMethodStart StaticOpt TypeVoid:type MethodName:methodName LPAREN FormParamsOpt RPAREN 
                {: 
                if (curMeth.getName().equals("main"))
                {
                if(type != Tab.noType)
                parser.report_error("main ne sme imati povratnu vrednost",methodNameleft);
                if(formParams>0)
                    parser.report_error("main ne sme da ima parametre", -1);
                }
                else
                curMeth.setLevel(formParams); 
                
                //if (methodName.equals("main") && num > 0)
                //   parser.report_error("main ne sme da ima parametre", -1);
                
                Tab.chainLocalSymbols(curMeth);
                curMethType = type;   
                           
                :}
                MethodVarDeclListOpt LBRACE
                {: 
                    curMeth.setAdr(Code.pc);
                    if ("main".equals(curMeth.getName())) {
                        Code.mainPc = curMeth.getAdr();
                    }
                    Code.put(Code.enter);
                    Code.put(curMeth.getLevel());
                    Code.put(Tab.currentScope().getnVars());
               :}
                StatementListOpt RBRACE 
                InMethodEnd
                {:
                if(type != Tab.noType && !retNeed )
                parser.report_error("Funkcija mora imati povratnu vrednost",typeleft);
                
                :}
                ;


InMethodStart ::= {: parser.inMethod = true; :};

InMethodEnd ::= {:
                parser.inMethod = false;
                Code.put(Code.exit);
                Code.put(Code.return_);
                Tab.chainLocalSymbols(curMeth);
                Tab.closeScope();
                curMeth = null; 
                curMethType = null;
                :};

MethodName ::= IDENT:methodName
              {:
                  if(methodName.equals("main"))
                      parser.inMain = true;
                  else
                      parser.inMain = false;
                      
                 if(Tab.currentScope.findSymbol(methodName) != null)
                        parser.report_error(""+methodName + " naziv vec u upotrebi", methodNameleft);
                 else {
                 
                    boolean flag =  false;
                        if(extendedClass != null) {
                            for (Obj o : extendedClass.getType().getMembers()) {
                                if(o.getKind() == Obj.Meth && o.getName().equals(methodName)) 
                                    if(o.getType().getElemType().getKind() == 6) 
                                        flag = true;
                            }
                        }
                        if(flag) {
                            parser.report_error(" Ne mozete redefinisati staticku metodu.", methodNameleft);
                        }
                 else{
                    if(statMeth) {
                     Struct s = new Struct(curType.getKind()); s.setElementType(new Struct(6));
                     curMeth = Tab.insert(Obj.Meth, methodName, s);
                    }
                    else {
                     Struct s = new Struct(curType.getKind()); s.setElementType(new Struct(7));
                     curMeth = Tab.insert(Obj.Meth, methodName, s);
                     parser.report_info("ubacena metoda u tabelu simbola",null);
                    }
                     Tab.openScope();
                 }
                 }
                      statMeth = false;
                      
                      RESULT = methodName;     
              :};

StaticOpt ::= STATIC:staticCheck
            {: 
            parser.IncreaseStaticFunctionCount();
            :}
            |
            /*epsilon*/
            {:parser.IncreaseFunctionCount(); 
            :}
            ;
            
TypeVoid ::= Type:type
            {: RESULT = type; :}
            |
            VOID
            {: RESULT = curType = Tab.noType; :}
            ;

VarArgs ::=  Type DOT DOT DOT IDENT:identName   
                {:          
                        if( Tab.currentScope.findSymbol(identName) != null)         
                                      parser.report_error(" " + identName + "Sakriveno od strane f-skog parametra", identNameleft);         
                                      else {            
                                          if( curType != null && curType != Tab.noType) {           
                                              Tab.insert(Obj.Var, identName, new Struct(Struct.Array, curType));            
                                              parser.report_info("Parametar f-je ubacen u listu simbola " + identName + " tipa "+Struct.Array+" na liniji " + identNameleft, null);         
                                          }         
                                      }
                   //varArgs = true;                            
                :};         
                

FormParamsOpt ::= FormalParamList 
            |
            FormalParamList COMMA VarArgs
            {: parser.formArgsCount++;  :}
            |
            COMMA VarArgs
            {: parser.formArgsCount++;  :}
            |
            error
            {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske do ) prilikom deklaracije formalnog parametra funkcije   "  ); :}                               
            |
             /* epsilon */ 
             {: formParams = 0; :}
             ;

FormalParamList ::= FormalParamList COMMA FormalParamDecl
                    {: formParams ++; :}
                    |
                    FormalParamDecl
                    {: formParams = 1; :}
                    |
                    error COMMA FormalParamDecl
                    {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske do , prilikom deklaracije formalnog parametra funkcije   "  ); :}                   
                    ;
                    
FormalParamDecl ::= Type IDENT:identName
                    {: 
                    parser.formArgsCount++; 
                    if( Tab.currentScope.findSymbol(identName) != null)
                      parser.report_error(" " + identName + "Sakriveno od strane f-skog parametra", identNameleft);
                      else {
                          if( curType != null && curType != Tab.noType) {
                              Tab.insert(Obj.Var, identName, new Struct(curType.getKind(), curType));
                              parser.report_info("Parametar f-je ubacen u listu simbola " + identName + " tipa "+curType.getKind()+" na liniji " + identNameleft, null);
                          }
                      }
                    :}
                    |
                    Type IDENT:identName LBRACK RBRACK
                    {: parser.formArgsCount++; 
                      if( Tab.currentScope.findSymbol(identName) != null)
                      parser.report_error(" " + identName + "Sakriveno od strane f-skog parametra", identNameleft);
                      else {
                          if( curType != null && curType != Tab.noType) {
                              Tab.insert(Obj.Var, identName, new Struct(Struct.Array, curType));
                              parser.report_info("Parametar f-je ubacen u listu simbola " + identName + " tipa "+Struct.Array+" na liniji " + identNameleft, null);
                          }
                      }
                    
                    :}
                     ;

StatementListOpt ::= StatementListOpt Statement
                    |
                    /* epsilon */
                    ;

Statement ::= DesignatorStatement SEMI
                |
                IF LPAREN Condition RPAREN Statement 
                {: 
                    Code.fixup(endAdr.pop());
                :}
                |
                IF LPAREN Condition RPAREN Statement ELSE 
                {:
                    Code.pc += 3; 
                    Code.fixup(endAdr.pop());
                    Code.pc -= 3;
                    
                    Code.putJump(0); // dummy
                    endAdr.push(Code.pc - 2);
                :}
                Statement 
                {: 
                    Code.fixup(endAdr.pop());
                :}
                |
                FOR LPAREN DesignatorOpt SEMI 
                {:
                    cond.push(Code.pc);
                :}
                CondOpt
                {:
                    Code.putJump(0);
                    forAdr.push(Code.pc - 2);
                    
                    if(endAdr.peek() != -1) 
                        endFor.push(endAdr.peek()); 
                    else {
                        Code.putJump(0);
                        noCond.push(Code.pc - 2);
                        endFor.push(noCond.peek());
                    }
                :}
                SEMI 
                {:
                    desi.push(Code.pc);
                :}
                DesignatorOpt
                {: 
                    Code.putJump(cond.pop());
                :}
                RPAREN
                {: 
                    forStack.push(1); 
                    Code.fixup(forAdr.pop());
                :}
                Statement
                {: 
                    inFor--;
                    forStack.pop();
                    Code.putJump(desi.pop());
                    if(endAdr.peek() != -1)
                        Code.fixup(endAdr.pop());
                    else {
                        Code.fixup(noCond.pop());
                        endAdr.pop();
                    }
                :}
                |
                BREAK SEMI:semi
                {:
                    if(inFor<=0)
                        parser.report_error(" break mora biti unutar for petlje", semileft);
                    else
                        Code.putJump(endFor.pop() - 1);
                :}
                |
                CONTINUE SEMI:semi
                {:
                    if(inFor<=0)
                        parser.report_error(" continue mora biti unutar for petlje", semileft);
                    else
                        Code.putJump(desi.peek());
                :}
                |
                RETURN:expr SEMI
                {:
                if(curMeth != null )
                    {
                    if(curMethType != Tab.noType)
                    parser.report_error("Metoda mora imati povratni tip.",exprleft);
                    }
                    else{
                    parser.report_error("Return mora biti unutar funkcije.",exprleft);
                    }
                :}
                |
                RETURN Expression:expr SEMI
                {:
                    if(curMeth != null )
                    {
                    if(curMethType == Tab.noType)
                    parser.report_error("Metoda je void, nema povratni tip.",exprleft);
                    else
                    {
                    retNeed = true;
                    if(curMethType.getKind() != expr.getKind())
                    parser.report_error("Tip return-a, se ne slaze sa povratnom vrednosti metode.",exprleft);
                    }
                    
                    }
                    else{
                    parser.report_error("Return mora biti unutar funkcije.",exprleft);
                    }
                
                :}
                |
                READ LPAREN Designator:desig RPAREN SEMI
                {:
                 parser.IncreaseFunctionCallsCount(); 
                    if(desig.getKind() != Obj.Var && desig.getKind()!= Obj.Fld && desig.getKind() != Obj.Elem)
                        parser.report_error(" " + desig.getName() + " mora oznacavati  promenljivu, element niza ili polje unutar objekta", desigleft);
                    else 
                        if(desig.getKind() != Struct.Int && desig.getKind() != Struct.Char && desig.getKind() != Struct.None)
                            parser.report_error(" " + desig.getName() + " mora biti tipa int, char ili bool.", desigleft);                
                        
                  if (desig.getType() == Tab.charType ) 
                    Code.put(Code.bprint);           
                 else
                    Code.put(Code.print);
                 
                        
                :}
                |
                PRINT LPAREN Expression:desig NumOpt:num RPAREN SEMI
                {:
                parser.IncreaseFunctionCallsCount(); 
                if(desig.getKind() != Struct.Int && desig.getKind() != Struct.Char && desig.getKind() != Struct.None)
                    parser.report_error(" operand mora biti tipa int, char ili bool.", desigleft);
                        
                if (desig.getKind() == Struct.Char ) {
                    Code.loadConst(num);
                    Code.put(Code.bprint);
                 }
                 
                 else{
                    Code.loadConst(num);
                    Code.put(Code.print);
                 }
                :}
                |
                LBRACE StatementListOpt RBRACE
                |
                IF LPAREN error RPAREN Statement
                {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske do , prilikom logickog izraza unutat if konstrukcije   "  ); :}                                 
                |
                IF LPAREN error RPAREN Statement ELSE Statement 
                {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske do , prilikom logickog izraza unutar if konstrukcije   "  ); :}                                                 
                ;
                
NumOpt ::= COMMA NUMBER:num
            {: RESULT = num ; :} 
            | 
            /* epsilon */
            {: RESULT = 5; :}
            ;

DesignatorOpt ::= DesignatorStatement 
            | 
            /* epsilon */
            |
            error
            {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske prilikom izraza unutar for konstrukcije   "  ); :}                                                  
            ;

CondOpt ::= Condition 

        |
        error 
        {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske prilikom izraza unutar for konstrukcije   "  ); :}                                                  
        |
        /* epsilon */ 
        {: endAdr.push(-1); :}
        ;

    
DesignatorStatement ::= Designator:desig Assignop :op
                        {:
                        if((int)op != 0) { 
                                if(desig.getKind() == Obj.Elem)
                                    Code.put(Code.dup2);
                                Code.load(desig); 
                            }
                        
                        :}
                        Expression:expr
                        {:
                            if(desig.getKind() != Obj.Var && desig.getKind()!= Obj.Fld && desig.getKind() != Obj.Elem)
                                parser.report_error(" " + desig.getName() + " mora oznacavati  promenljivu, element niza ili polje unutar objekta", desigleft);
                            else{
                                boolean comp = true;
                                if(!expr.assignableTo(desig.getType())) {
                                
                                    if(expr.getKind() != desig.getType().getKind())
                                        parser.report_error(""+expr.getKind() +" != " +desig.getType().getKind()+"expr.getKind() != desig.getType().getKind()", desigleft); 
                                    if (expr.getElemType() != desig.getType().getElemType())
                                        parser.report_error(""+expr.getElemType() +" != "+ desig.getType().getElemType()+ " expr.getElemType() != desig.getType().getElemType()", desigleft);
                                    
                                    
                                    if (expr.getNumberOfFields() != desig.getType().getNumberOfFields())
                                        parser.report_error(" expr.getNumberOfFields() != desig.getType().getNumberOfFields()", desigleft);
                                    if (expr.getMembers() == desig.getType().getMembers())
                                        parser.report_error("expr.getMembers() == desig.getType().getMembers()", desigleft);
                                    if(desig.getType().getKind() == Struct.Array && expr.getElemType() == null)
                                        if(!expr.assignableTo(desig.getType().getElemType()))
                                            comp = false;
                                }
                                if(!comp)
                                    parser.report_error(" nekompatibilni tipovi u dodeli vrednosti", desigleft);
                            }
                            if((int)op != 0) 
                                Code.put((int)op); 
                            
                            Code.store(desig);
                        :}
                        |
                        Designator:desig LPAREN ActParsListOpt:num RPAREN    
                        {:
                        if(desig.getKind() != Obj.Meth)
                        {
                        parser.report_error("Funkcija mora biti deklarisana pre poziva",desigleft);
                        desig = Tab.noObj;
                        }  
                            
                        if(desig != Tab.noObj) {
                            if((!varArgs && num == desig.getLevel())||(varArgs && num > desig.getLevel())) {
                                boolean flag = true;
                                Obj o=null;
                                for(int i = 0; i < num; i++) {
                                    if(i<desig.getLevel()) o = ((Obj) desig.getLocalSymbols().toArray()[i]);
                                    Struct s = funcParams.get(funcParams.size() - (num - i));
                                    if(!o.getType().compatibleWith(s))
                                        if(!(o.getType().getKind() != Struct.Class && o.getType().getKind() == s.getKind() && o.getType().getElemType() == s.getElemType() && o.getType().getNumberOfFields() == s.getNumberOfFields()))
                                            flag = false;
                                }
                                
                                if(!flag)
                                    parser.report_error(" Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva.", numleft);
                                else{
                                int destAdr = desig.getAdr() - Code.pc;
                                Code.put(Code.call);
                                Code.put2(destAdr);
                                if(desig.getType().getKind() != Struct.None)
                                Code.put(Code.pop);
                                }
                            } else {
                                parser.report_error(" Broj argumenata funkcije nije dobar."+ desig.getName(), numleft);                     
                            }
                            for(int i = 0; i < num; i++)
                                    funcParams.remove(funcParams.size() - 1);
                        }
                        
                        
                        if(parser.inMain)
                            parser.funcMainCount++; 
                        :}        
                        |
                        Designator:desig INC
                        {:
                        if(desig.getKind() != Obj.Var && desig.getKind()!= Obj.Fld && desig.getKind() != Obj.Elem)
                                parser.report_error(" " + desig.getName() + " mora oznacavati  promenljivu, element niza ili polje objekta unutrasnje objekta", desigleft);
                            else{
                                if(desig.getType().getKind() != Struct.Int)
                                    parser.report_error(" " + desig.getName() + "mora biti int ", desigleft);
                            
                            if(desig.getKind() == Obj.Elem)
                                Code.put(Code.dup2);
                            Code.load(desig);
                            Code.put(Code.const_1);
                            Code.put(Code.add);
                            Code.store(desig);
                            }
                        :}
                        |
                        Designator:desig DEC
                        {:
                        if(desig.getKind() != Obj.Var && desig.getKind()!= Obj.Fld && desig.getKind() != Obj.Elem)
                                parser.report_error(" " + desig.getName() + " mora oznacavati  promenljivu, element niza ili polje objekta unutrasnje objekta", desigleft);
                            else{
                                if(desig.getType().getKind() != Struct.Int)
                                    parser.report_error(" " + desig.getName() + "mora biti int ", desigleft);
                            
                            if(desig.getKind() == Obj.Elem)
                                Code.put(Code.dup2);
                            Code.load(desig);
                            Code.put(Code.const_1);
                            Code.put(Code.sub);
                            Code.store(desig);
                            }
                        :}
                        |
                        Designator ASSIGN error
                        {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske do ; prilikom konstrukcije iskaza dodele  "  ); :}
                        |
                        Designator ASSIGN_ADD error
                        {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske do ; prilikom konstrukcije iskaza dodele  "  ); :}
                        |
                        Designator ASSIGN_SUB error
                        {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske do ; prilikom konstrukcije iskaza dodele  "  ); :}
                        |
                        Designator ASSIGN_MUL error
                        {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske do ; prilikom konstrukcije iskaza dodele  "  ); :}
                        |
                        Designator ASSIGN_DIV error
                        {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske do ; prilikom konstrukcije iskaza dodele  "  ); :}
                        |
                        Designator ASSIGN_MOD error
                        {: parser.errorRecovery = true; parser.log.debug("Oporavak od greske do ; prilikom konstrukcije iskaza dodele  "  ); :}
                        ;

ActParsListOpt ::= ActPars:num
                {:
                RESULT = num;
                :}
                | 
                /* epsilon */ 
                {:
                RESULT = 0;
                :}
                ;

ActPars ::= ActPars:num COMMA Expression:expr
            {:
            funcParams.add(expr);
            RESULT = num+1;
            :}
            |
            Expression:expr
            {:
            funcParams.add(expr);
            RESULT = 1;
            :}
            ;
           
Designator ::= IDENT:idenName 
                {:
                  if(idenName.equals("this")) {
                    if(curMeth != null) {
                        if(parser.inClass && parser.inMethod && curMeth.getType().getElemType().getKind() != 6)
                            thisSpecified = true;
                        else {
                            parser.report_error("this moze postojati samo u nestatickim metodama", idenNameleft);
                            thisSpecified = true;
                        }
                    }
                  } else {
                    
                    Obj o = Tab.currentScope.findSymbol(idenName);
                    if(o== null) {
                        Obj o1 = Tab.find(idenName);
                        if(o1 != Tab.noObj) {
                            if(o1.getType().getKind() == Struct.Array)
                                desigName = idenName;
                    }
                        else { 
                            Obj found = null;
                            if(extendedClass != null) {
                                for (Obj o2 : extendedClass.getType().getMembers()) {
                                    if(o2.getName().equals(idenName))
                                        found = o2;
                                }
                            }
                            if(found != null) {
                                if(found.getType().getKind() == Struct.Array) {
                                    desigName = idenName;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                o1 = found;
                            } else
                                parser.report_error("" + idenName + "nije nadjeno", idenNameleft);
                        }
                        lastDesignator = o1;
                        RESULT = o1;
                    }
                    else {
                      if(curMeth != null) {
                        if(o.getType().getKind() == Struct.Array)
                            desigName = idenName;                       
                      }
                        RESULT = lastDesignator = o;
                        
                    }  
                  }
                :}
                DesignatorListOpt:res {: if(res != null) RESULT = res; :}
                ;


DesignatorListOpt ::= DesignatorListOpt DesignatorIdent:val
             {: 
             if (val != null)   
                RESULT = val;
             :}
                |
                /* epsilon */
                ;

DesignatorIdent ::= DOT IDENT:identName
            {:
            if(!(thisSpecified || (lastDesignator != null && (lastDesignator.getKind() == Obj.Elem || lastDesignator.getKind() == Obj.Var || lastDesignator.getKind() == Obj.Fld )&& lastDesignator.getType().getKind() == Struct.Class))) {
                        if(lastDesignator.getKind() == Obj.Type) {
                            if(thisSpecified) {
                                Obj o = Tab.currentScope().getOuter().findSymbol(identName);
                                if(o != null) {
                                    if(o.getKind() != Obj.Meth) {
                                        parser.report_error(": za klasu se mogu pozvati samo staticke metode", identNameleft);
                                        lastDesignator = Tab.noObj;
                                    } else if(o.getType().getElemType().getKind() != 6) {
                                        parser.report_error(": za klasu se mogu pozvati samo staticke metode", identNameleft);
                                        lastDesignator = Tab.noObj;
                                    } else {
                                        parser.report_detect(identNameleft, o);
                                        lastDesignator = o;
                                    }
                                }
                                else { // ako koristimo this a nema ga u toj klasi, proveravamo da li je klasa izvedena
                                      // i ima li u osnovnoj onda
                                    Obj found = null;
                                    if(extendedClass != null) {
                                        for (Obj o1 : extendedClass.getType().getMembers()) {
                                            if(o1.getName().equals(identName))
                                                found = o1;
                                        }
                                    }
                                    if(found != null) {
                                        if(found.getKind() != Obj.Meth) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", identNameleft);
                                            lastDesignator = Tab.noObj;
                                        } else if(found.getType().getElemType().getKind() != 6) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", identNameleft);
                                            lastDesignator = Tab.noObj;
                                        } else {
                                            parser.report_detect(identNameleft, found);
                                            lastDesignator = found;
                                        }
                                    } else {
                                        parser.report_error("(this." + identName + ") nije nadjeno", identNameleft);
                                        lastDesignator = Tab.noObj;
                                    }
                                }
                            } else {
                                Obj found = null;
                                if(lastDesignator != null) {
                                    for (Obj o : lastDesignator.getType().getMembers()) { //pronalazimo u klasi ovaj naziv
                                        if(o.getName().equals(identName))
                                            found = o;
                                    }
                                    if(found != null){
                                        if(found.getKind() != Obj.Meth) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", identNameleft);
                                            lastDesignator = Tab.noObj;
                                        } else if(found.getType().getElemType().getKind() != 6) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", identNameleft);
                                            lastDesignator = Tab.noObj;
                                        } else {
                                            parser.report_detect(identNameleft, found);
                                            lastDesignator = found;
                                        }
                                    } else {
                                        parser.report_error("(" + lastDesignator.getName() + "." + identName + ") nije nadjeno", identNameleft);
                                        lastDesignator = Tab.noObj;
                                    }
                                }
                            }
                            thisSpecified = false;
                            RESULT = lastDesignator;
                        }
                        else {
                            parser.report_error(": " + lastDesignator.getName() + " nije klasa", identNameleft);
                            lastDesignator = Tab.noObj;
                        }
                } else {
                    if(thisSpecified) {
                        Obj o = Tab.currentScope().getOuter().findSymbol(identName);
                        if(o != null) {
                            if(o.getType().getKind() == Struct.Array) {
                                desigName = identName;
                                if(lastDesignator != null && lastDesignator.getType() != null)
                                    classFields = lastDesignator.getType().getMembers();
                            }
                            parser.report_detect(identNameleft, o);
                            lastDesignator = o;
                        }
                        else { // ako koristimo this a nema ga u toj klasi, proveravamo da li je klasa izvedena
                              // i ima li u osnovnoj onda
                            Obj found = null;
                            if(extendedClass != null) {
                                for (Obj o1 : extendedClass.getType().getMembers()) {
                                    if(o1.getName().equals(identName))
                                        found = o1;
                                }
                            }
                            if(found != null) {
                                if(found.getType().getKind() == Struct.Array) {
                                    desigName = identName;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                parser.report_detect(identNameleft, found);
                                lastDesignator = found;
                            } else
                                parser.report_error("(this." + identName + ") nije nadjeno", identNameleft);
                        }
                    } else {
                        Obj found = null;
                        if(lastDesignator != null) {
                            for (Obj o : lastDesignator.getType().getMembers()) { //pronalazimo u klasi ovaj naziv
                                if(o.getName().equals(identName))
                                    found = o;
                            }
                            if(found != null){
                                if(found.getType().getKind() == Struct.Array) {
                                    desigName = identName;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                parser.report_detect(identNameleft, found);
                                lastDesignator = found;
                            } else
                                parser.report_error("(" + lastDesignator.getName() + "." + identName + ") nije nadjeno", identNameleft);
                        }
                    }
                    thisSpecified = false;
                    RESULT = lastDesignator;
                }
            :}
            |
            LBRACK:brack
            {:
            if(lastDesignator.getType().getKind() != Struct.Array) {
                    parser.report_error(": " + lastDesignator.getName() + " nije niz", brackleft);
                    RESULT = Tab.noObj;
            } else
                   backupDesig = lastDesignator;
                   Code.load(lastDesignator);
                   
             :}
             Expression:expr RBRACK   
             {:  
            if(expr.getKind() != Struct.Int)
                parser.report_error(" tip u zagradama niza mora biti int a vama je :"+ expr.getKind(),exprleft);
              else {
                    //if(RESULT == null) {
                        if(backupDesig != null)
                            RESULT = lastDesignator = new Obj(Obj.Elem, backupDesig.getName(), backupDesig.getType().getElemType(), backupDesig.getAdr(), backupDesig.getLevel());
                        else
                            RESULT = lastDesignator = Tab.noObj;
                    //}
                }
                
            :}
           
            ;
            

Condition ::= Condition OR CondTerm
        {:
        
        Code.putJump(0); 
        endAdr.push(Code.pc - 2);
    
        while(!orAdr.empty()) 
            Code.fixup(orAdr.pop());
                        
        
        :}
                |
                CondTerm
                        {:
        
        Code.putJump(0); 
        endAdr.push(Code.pc - 2);
    
        while(!orAdr.empty()) 
            Code.fixup(orAdr.pop());
                        
        
        :}
                ;
                        
CondTerm ::= CondTerm AND CondFact
            {:
                        if(!parser.errorRecovery){
                        Code.putJump(0); 
                        orAdr.push(Code.pc - 2);                    
                        while(!andAdr.empty()) 
                            Code.fixup(andAdr.pop());
                        }
                    :}
                |
                CondFact
                {:
                        if(!parser.errorRecovery){
                        Code.putJump(0); 
                        orAdr.push(Code.pc - 2);                    
                        while(!andAdr.empty()) 
                            Code.fixup(andAdr.pop());
                        }
                    :}
                ;

CondFact ::= Expression:exp
            {:
            if(exp.getKind() != Struct.Bool)
                    parser.report_error("Exp mora biti tipa bool", expleft);
            Code.loadConst(0); //expr je bool i samo proverimo da li je jednako sa 0
                Code.putFalseJump(Code.ne, 0); // dummy //ako nije tacan uslov odmah preskacemo AND uslove i idemo na OR ako ima
                andAdr.push(Code.pc - 2);
            :}
            |
            Expression:exp1 Relop:op Expression:exp2
            {:
            if(!exp1.compatibleWith(exp2)) {
                    if(!(exp1.getKind() == exp2.getKind() && exp1.getElemType() == exp2.getElemType() && exp1.getNumberOfFields() == exp2.getNumberOfFields()))
                        parser.report_error(" Tipovi nisu kompatibilni", exp1left);
                }
                else {
                    if(exp1.getKind() == Struct.Array || exp1.getKind() == Struct.Class) {
                        if(op != Code.eq && op != Code.ne)
                            parser.report_error("Uz promenljive tipa klase ili niza mogu se koristiti samo != i ==", exp1left);
                    }
                Code.putFalseJump(op, 0); // dummy
                andAdr.push(Code.pc - 2);   
                }
            :}
            ;
    
                
Expression ::= SUB AddopTermCombList:atcl
        {:
        if(atcl.getKind() != Struct.Int){
        parser.report_error("izraz nakon minusa mora biti tipa int",atclleft);
        RESULT = Tab.noType;
        
        }
        else RESULT = atcl;
        Code.put(Code.neg);
        :}
        |
        AddopTermCombList:atcl
        {:
        RESULT = atcl;
        :}
        ;

AddopTermCombList ::= AddopTermList:atl
                    
                    {:
                    if(atl.getKind() == Obj.Elem) {
                                Code.put(Code.dup2);
                                Code.put(Code.dup2);
                            }
                            if(atl.getKind() != Obj.Con)
                    Code.load(atl); 
                    :}
                    
                     AddopRight:op  AddopTermCombList:atcl
                        {:
                        Code.put((int)op);
                            Code.store(atl);
                            Code.load(atl);
                        if (IsObjectVarElemOrFieldError(atl, atlleft))
                        {
                            RESULT = GetResultIfBothInt(atl, atlleft, atcl).getType();
                        }
                        :}
                        |
                        AddopTermList:result
                        {:
                        if(result != null)
                        {
                        RESULT = result.getType();
                        if(result.getKind() == Obj.Var || result.getKind() == Obj.Elem)
                            Code.load(result);
                        }
                        else
                        RESULT = Tab.noType;
                        
                        :}
                        ;

AddopTermList ::= AddopTermList:result {:if(result.getKind() != Obj.Con) Code.load(result);:}
                    AddopLeft:op Term:term
                    {:
                     
                     if (GetResultIfBothInt(result, resultleft, term.getType()).getType()!= Tab.noType)
                        RESULT = new Obj(Obj.Con, "rezultat sabiranja", Tab.intType);
                      if(term.getKind() != Obj.Con)
                            Code.load(term);
                        
                        Code.put((int)op);
                      
                    :}
                    |
                    Term:t
                    {:
                    RESULT = t;
                    :}
                    ;

Term ::= MulopFactorList:mfl
        {:
        if(mfl.getKind() == Obj.Elem) {
                    Code.put(Code.dup2);
                    Code.put(Code.dup2);
                }
                if(mfl.getKind() != Obj.Con)
                    Code.load(mfl); 
        :}
             MulopRight:op Term:term
            {:
            if(term.getKind() != Obj.Con)
                    Code.load(term);
                    
                Code.put((int)op);
                Code.store(mfl);
                if (!IsObjectVarElemOrFieldError(mfl , mflleft))
                {
                    parser.report_error(" " + mfl.getName() + " mora oznacavati  promenljivu, element niza ili polje objekta unutrasnje objekta", mflleft);
                    RESULT = Tab.noObj;
                }
               else 
               RESULT = GetResultIfBothInt(mfl, mflleft, term.getType());
            :}
            |
            MulopFactorList:mfl
            {:
            RESULT = mfl;
            :}
            ;

MulopFactorList ::= MulopFactorList:mfl 
                    {:
                    if(mfl.getKind() != Obj.Con)
                            Code.load(mfl);
                    :}
                
                    MulopLeft:operation Factor:fact    
                    {:
                    if(fact.getKind() != Obj.Con) 
                            Code.load(fact);
                        
                        Code.put((int)operation);
                        RESULT = Tab.noObj;
                        if (GetResultIfBothInt(mfl, mflleft, fact.getType()) != Tab.noObj)
                        {
                            RESULT = new Obj(Obj.Con, "Multiplication result", Tab.intType); 
                        } 
                    :}
                    |
                    Factor:fact
                    {:
                    RESULT = fact;
                    :}
                    ;

Factor ::= Designator:desig
            {:
                RESULT = desig;
                if(desig.getKind() == Obj.Con)
                    Code.load(desig);
                
            :}
            |
            Designator:desig LPAREN ActParsListOpt:num RPAREN
            {:
            parser.IncreaseFunctionCallsCount();
            if(desig.getKind() != Obj.Meth)
            {
            parser.report_error("Funkcija mora biti deklarisana pre poziva",desigleft);
            RESULT = Tab.noObj;
            }
            else
             RESULT = new Obj(Obj.Meth, desig.getName(), new Struct(desig.getType().getKind()), desig.getAdr(), desig.getLevel());   
            
                if(RESULT != Tab.noObj) {
                    if((!varArgs && num == desig.getLevel())||(varArgs && num > desig.getLevel())) {
                        boolean flag = true;
                        Obj o = null;
                        for(int i = 0; i < num; i++) {
                            if(i<desig.getLevel()) o = ((Obj) desig.getLocalSymbols().toArray()[i]);
                            Struct s = funcParams.get(funcParams.size() - (num - i));
                            if(!o.getType().compatibleWith(s))
                                if(!(o.getType().getKind() != Struct.Class && o.getType().getKind() == s.getKind() && o.getType().getElemType() == s.getElemType() && o.getType().getNumberOfFields() == s.getNumberOfFields()))
                                    flag = false;
                        }
                        
                        if(!flag)
                            parser.report_error(" Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva.", numleft);
                        else {
                            if(RESULT.getType() != Tab.noType)
                                RESULT = new Obj(Obj.Con, "", RESULT.getType());
                                
                            else                            
                                parser.report_error(" Funkcija nema povratnu vrednost.", numleft);
                            int destAdr = desig.getAdr() - Code.pc;
                            Code.put(Code.call);
                            Code.put2(destAdr);
                            if(desig.getType().getKind() != Struct.None)
                                Code.put(Code.pop);
                        }
                    } else {
                        parser.report_error(" Broj argumenata funkcije nije dobar."+ RESULT.getName(), numleft);                        
                    }
                    for(int i = 0; i < num; i++)
                            funcParams.remove(funcParams.size() - 1);
                }
            :}
            |
            NUMBER:num
            {: 
            Obj value = new Obj(Obj.Con, "" + num, Tab.intType); 
            value.setAdr(num.intValue());
            Code.load(value);
            RESULT = value; 
            :}
            |
            CHAR:ch
            {: 
            Obj value = new Obj(Obj.Con, "" + ch, Tab.charType); 
            value.setAdr(ch);
            Code.load(value);
            RESULT = value; 
            :}
            |
            BOOL:boo
            {: 
            Obj value = new Obj(Obj.Con, "" + boo, new Struct (Struct.Bool)); 
            value.setAdr(boo? 1:0);
            Code.load(value);
            RESULT = value; 
            :}
            |
            NEW Type:type
            {:
            if(type.getKind()!=Struct.Class)
                parser.report_error("tip prilikom pravljenja objekta mora biti unutrasnja klasa",typeleft);
            else
            {
            if(lastDesignator.getType().getKind() != type.getKind()) {
                  parser.report_error(": tipovi se ne podudaraju ", typeleft);
                  RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
            } else
                  RESULT = new Obj(Obj.NO_VALUE, "", type);
            
            }
            :}
            |
            NEW Type:type 
            {:
                Obj obj = Tab.noObj;
                if(classFields == null)
                    obj = Tab.find(desigName);      
                else  { 
                    for (Obj o : classFields) { 
                        if(o.getName().equals(desigName))
                            obj = o;
                    }
                } 
                                
                if(obj == Tab.noObj)
                    RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                else {
                    if(obj.getType().getElemType() != type) {
                        parser.report_error("Ne podudaraju se tipovi. ", typeleft);
                        RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                    }
                } 
                    
                classFields = null;
            :}
            LBRACK Expression:expr RBRACK
            {:
                if(expr.getKind() == Struct.Int)
                    RESULT = new Obj(Obj.NO_VALUE, "", new Struct(Struct.Array, type));
                else {
                    parser.report_error(": tip expr mora biti int", typeleft);
                    RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                }
                
                Code.put(Code.newarray);
                Code.put(type == Tab.charType ? 0 : 1); 
                    
                
            :}
            |
            LPAREN Expression:expr RPAREN
            {: RESULT = new Obj(Obj.Con, "", expr); :}
            ;
           
Assignop ::= ASSIGN 
            {: RESULT = 0 ; :}
            |
            AddopRight:addOp
            {: RESULT = addOp ; :}
            |
            MulopRight:mulOp
            {: RESULT = mulOp ; :}
            ;

Relop ::= EQUAL 
        {: RESULT = Code.eq ; :}
        | 
        NOT_EQUAL 
        {: RESULT = Code.ne ; :}
        | 
        GREATER
        {: RESULT = Code.gt ; :} 
        | 
        GREATER_EQUAL 
        {: RESULT = Code.ge ; :}
        | 
        LESS
        {: RESULT = Code.lt ; :}
        | 
        LESS_EQUAL
        {: RESULT = Code.le ; :}
        ;

Addop ::= AddopLeft 
        | 
        AddopRight 
        ;

AddopLeft ::= ADD 
            {: RESULT = Code.add ; :}
            | 
            SUB 
            {: RESULT = Code.sub ; :}
            ;

AddopRight ::= ASSIGN_ADD 
            {: RESULT = Code.add ; :}
            | 
            ASSIGN_SUB 
            {: RESULT = Code.sub ; :}
            ;

Mulop ::= MulopLeft 
        | 
        MulopRight 
        ;

MulopLeft ::= MUL 
            {: RESULT = Code.mul ; :}
            | 
            DIV 
            {: RESULT = Code.div ; :}
            | 
            MOD 
            {: RESULT = Code.rem ; :}
            ;

MulopRight ::= ASSIGN_MUL 
            {: RESULT = Code.mul ; :}
            | 
            ASSIGN_DIV 
            {: RESULT = Code.div ; :}
            | 
            ASSIGN_MOD 
            {: RESULT = Code.rem ; :}
            ;