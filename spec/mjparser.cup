package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import java.util.Stack;
import rs.ac.bg.etf.pp1.MJParser.SCOPE;

// import java.io.*;


parser code {:
    public static enum SCOPE
    {
        METHOD_SCOPE,
        CLASS_SCOPE,
        CLASS_METHOD_SCOPE,
        MAIN_SCOPE
    }
    Stack<SCOPE> nestedScopes = new Stack<SCOPE>();
    
    int globalVariableCount = 0;
    int globalConstVariableCount = 0;
    int mainVariableCount = 0;
    int mainFunctionCallsCount = 0;
    int globalClassFunctionCount = 0;
    int staticClassFunctionCount = 0;
    int formalParamsCount = 0;
    int globalFunctionCount = 0;
    int classCount = 0;
    int classVariableCount = 0;
    
    boolean errorEncountered = false;
    boolean errorHandled = false;
    
    void ReportError(String errorMessage)
    {
        errorEncountered = true;
        log.debug(errorMessage);
    }
    
    void ReportVarDeclError(char errorChar)
    {
        errorEncountered = true;
        if (nestedScopes.empty())
        {
            log.debug("Doslo je do greske prilikom deklaracije globalne promenljive pre znaka \""+errorChar + '\"');
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            log.debug("Doslo je do greske prilikom definicije lokalne promenljive unutrasnje klase pre znaka \"" +errorChar+ '\"');
            return;
        }
    }
    
    void IncreaseVariableCount()
    {
        
        if (nestedScopes.empty()) // Global scope
        {
            globalVariableCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.MAIN_SCOPE)
        {
            mainVariableCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            classVariableCount++;
            return;
        }
    }
    
    void IncreaseConstVariableCount()
    {
        if (nestedScopes.empty()) // Global scope
        {
            globalConstVariableCount++;
        }
    }
    
    void IncreaseFunctionCount()
    {
        if (nestedScopes.empty())
        {
            globalFunctionCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            globalClassFunctionCount++;
        }
    }
    
    void IncreaseStaticFunctionCount()
    {
        if (nestedScopes.empty()) // Global Scope
        {
            // globalFunctionCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            staticClassFunctionCount++;
        }
    }
    
    void IncreaseFunctionCallsCount()
    {
        if (nestedScopes.empty()) // Global scope
        {
            return;
        }
        
        if (nestedScopes.peek() == SCOPE.MAIN_SCOPE)
        {
            mainFunctionCallsCount++;   
            return;
        }
    }
    
    void InScope(SCOPE newScope)
    {
        if (nestedScopes.empty())
        {
            nestedScopes.push(newScope);
            return;
        }
        
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE && newScope == SCOPE.METHOD_SCOPE)
        {
            nestedScopes.push(SCOPE.CLASS_METHOD_SCOPE);
            return;
        }
        nestedScopes.push(newScope);   
    }
    
    void OutOfCurrentScope()
    {
        nestedScopes.pop();
    }
    
    Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null) 
        log.info(s.toString() + " " + s.value.toString());
    return s;
:}

terminal BREAK, CLASS, CONST, CONTINUE, ELSE, EXTENDS, FOR, IF, NEW, PRINT, PROG, READ, RETURN, STATIC, VOID;
terminal LBRACE, RBRACE, LBRACK, RBRACK, LPAREN, RPAREN;
terminal ADD, SUB, MUL, DIV, MOD;
terminal ASSIGN, ASSIGN_ADD, ASSIGN_SUB, ASSIGN_MUL, ASSIGN_DIV, ASSIGN_MOD;
terminal EQUAL, NOT_EQUAL, GREATER_EQUAL, LESS_EQUAL, GREATER, LESS;
terminal DEC, INC, OR, AND;
terminal SEMI, COMMA, DOT;
terminal BOOL, CHAR, NUMBER, IDENT;

non terminal ClassDecl, ClassVarDecl, ClassVarDeclListOpt;
non terminal MethodDecl, MethodDeclOpt, MethodDeclListOpt, MethodVarDecl, MethodVarDeclListOpt, MethodIdentList;
non terminal Designator, DesignatorOpt, DesignatorListOpt, DesignatorStatement, DesignatorIdent;
non terminal Addop, AddopLeft, AddopRight, AddopTermList, AddopTermCombList; 
non terminal Mulop, MulopLeft, MulopRight, MulopFactorList;       
non terminal VarArgs, VarDecl, VarDeclList, Var;
non terminal Const, ConstIdent, ConstDecl, ConstDeclList;
non terminal FormalParamDecl, FormParamsOpt, FormalParamList;
non terminal Statement, StatementListOpt, StatementIfElse;
non terminal Condition, CondTerm, CondFact, CondOpt;

non terminal Decl, DeclListOpt;
non terminal ExtendsOpt, StaticOpt, NumOpt;
non terminal Assignop, AssignopError, ActPars ,ActParsListOpt, Relop;
non terminal Program, Expression, Term, Type, TypeVoid, Factor;

precedence left ELSE;

Program ::= PROG IDENT DeclListOpt LBRACE MethodDeclListOpt RBRACE;

DeclListOpt ::= DeclListOpt Decl
                | /* epsilon */ 
                ;


Decl ::=    ClassDecl 
            | ConstDecl 
            | VarDecl 
            ;

//CONST DECLARATION
ConstDecl ::= CONST Type ConstDeclList SEMI;

ConstDeclList ::=   ConstDeclList COMMA ConstIdent {: parser.IncreaseConstVariableCount(); :}
                    | ConstIdent {: parser.IncreaseConstVariableCount(); :}
                    ;
                    
                
ConstIdent ::= IDENT ASSIGN Const;

Const ::=   BOOL
            | CHAR
            | NUMBER
            ;

//VAR DECLARATION
VarDecl ::= Type VarDeclList SEMI
            | Type error SEMI
            {: parser.ReportVarDeclError(';'); :}
            ;

VarDeclList ::= VarDeclList COMMA Var
                | error COMMA Var
                {: parser.ReportVarDeclError(','); :}
                | Var 
                ;

Var ::= IDENT LBRACK RBRACK  {: parser.IncreaseVariableCount(); :}
        | IDENT {: parser.IncreaseVariableCount(); :}
           ;

Type ::= IDENT;

//CLASS VAR DECLARATION
ClassVarDeclListOpt ::= ClassVarDeclListOpt ClassVarDecl
                        | /*epsilon*/
                        ;

ClassVarDecl ::=    STATIC VarDecl
                    | VarDecl
                    ;

//CLASS DECLARATION
ClassDecl ::= CLASS IDENT ExtendsOpt LBRACE
{: 
    parser.InScope(SCOPE.CLASS_SCOPE);
    parser.classCount++;
:}
 ClassVarDeclListOpt MethodDeclOpt RBRACE
{: parser.OutOfCurrentScope(); :};


ExtendsOpt ::=  EXTENDS Type
                | EXTENDS error
                {: parser.ReportError("Doslo je do greske prilikom deklaracije prosirenja natklase"); :}
                | /* epsilon */
                ;
            
//METHOD VAR DECLARATION
MethodVarDeclListOpt ::= MethodVarDeclListOpt MethodVarDecl
                        | /* epsilon */
                        ;

MethodVarDecl ::= Type MethodIdentList SEMI ;
                
MethodIdentList ::= MethodIdentList COMMA Var
                    | Var
                    ;

//METHOD DECLARATION
MethodDeclOpt ::=   LBRACE MethodDeclListOpt RBRACE
                    | /*epsilon*/
                    ;

MethodDeclListOpt ::= MethodDeclListOpt MethodDecl
                    | /* epsilon */
                    ;

MethodDecl ::= 
StaticOpt TypeVoid IDENT:methodName LPAREN 
{:
if (methodName.equals("main"))
    parser.InScope(SCOPE.MAIN_SCOPE);
else
    parser.InScope(SCOPE.METHOD_SCOPE); 
:}
FormParamsOpt RPAREN MethodVarDeclListOpt LBRACE StatementListOpt RBRACE 
{: parser.OutOfCurrentScope(); :};

StaticOpt ::= 
            STATIC 
            {: parser.IncreaseStaticFunctionCount(); :}
            | /*epsilon*/ 
            {: parser.IncreaseFunctionCount(); :}
            ;

TypeVoid ::= Type
            | VOID
            ;

VarArgs ::= COMMA Type DOT DOT DOT IDENT {: parser.formalParamsCount++; :};

FormParamsOpt ::=   FormalParamList 
                    | FormalParamList VarArgs 
                    | VarArgs 
                    | error
                    {: parser.ReportError("Doslo je do greske prilikom deklaracije formalnog parametra funkcije pre znaka \")\""); :}
                    | /* epsilon */ 
                    ;

FormalParamList ::= FormalParamList COMMA FormalParamDecl 
                    | error COMMA FormalParamDecl {: parser.ReportError("Doslo je do greske prilikom deklaracije formalnog parametra funkcije pre znaka \",\""); :}
                    | FormalParamDecl;
                    

FormalParamDecl ::= Type IDENT LBRACK RBRACK {: parser.formalParamsCount++; :}
                    | Type IDENT {: parser.formalParamsCount++; :}
                    ;

StatementListOpt ::= StatementListOpt Statement
                    | /* epsilon */
                    ;

Statement ::=   Designator DesignatorStatement SEMI
                | StatementIfElse
                | FOR LPAREN DesignatorOpt SEMI CondOpt SEMI DesignatorOpt RPAREN Statement
                | BREAK SEMI
                | CONTINUE SEMI
                | RETURN SEMI
                | RETURN Expression SEMI
                | READ LPAREN Designator RPAREN SEMI
                {: parser.IncreaseFunctionCallsCount(); :}
                | PRINT LPAREN Expression NumOpt RPAREN SEMI
                {: parser.IncreaseFunctionCallsCount(); :}
                | LBRACE StatementListOpt RBRACE
                ;

StatementIfElse ::= IF LPAREN Condition RPAREN Statement 
                    | IF LPAREN Condition RPAREN Statement ELSE Statement 
                    | IF LPAREN error RPAREN Statement
                    {: parser.ReportError("Doslo je do greske u logickom izrazu unutar IF konstrukcije"); :}
                    | IF LPAREN error RPAREN Statement ELSE Statement 
                    {: parser.ReportError("Doslo je do greske u logickom izrazu unutar IF-ELSE konstrukcije"); :}
                    ;
                    
NumOpt ::=  COMMA NUMBER
            | /* epsilon */
            ;

DesignatorOpt ::=  Designator DesignatorStatement 
            | error
            {: parser.ReportError("Doslo je do greske unutar FOR(...) konstrukcije"); :}
            | /* epsilon */
            ;

CondOpt ::=  Condition
            | error
            {: parser.ReportError("Doslo je do greske u logickom iskazu unutar FOR(...) konstrukcije"); :}
            | /* epsilon */ 
            ;

DesignatorStatement ::= Assignop Expression
                        | LPAREN ActParsListOpt RPAREN
                        | INC
                        | DEC
                        | Assignop error 
                        {: parser.ReportError("Doslo je do prilikom dodele vrednosti pre znaka ;"); :}
                        ;
/*
AssignopError ::= ASSIGN error {: parser.ReportError("Doslo je do prilikom dodele vrednosti pre znaka ;"); :}
                | ASSIGN_ADD error {: parser.ReportError("Doslo je do prilikom dodele vrednosti pre znaka ;"); :}
                | ASSIGN_SUB error {: parser.ReportError("Doslo je do prilikom dodele vrednosti pre znaka ;"); :}
                | ASSIGN_MUL error {: parser.ReportError("Doslo je do prilikom dodele vrednosti pre znaka ;"); :}
                | ASSIGN_DIV error {: parser.ReportError("Doslo je do prilikom dodele vrednosti pre znaka ;"); :}
                | ASSIGN_MOD error {: parser.ReportError("Doslo je do prilikom dodele vrednosti pre znaka ;"); :}
                ;
*/

ActParsListOpt ::=  ActPars 
                    | /* epsilon */ 
                    ;

ActPars ::= ActPars COMMA Expression
            | Expression
            ;
            
Designator ::= IDENT DesignatorListOpt;

DesignatorListOpt ::= DesignatorListOpt DesignatorIdent
                 | /* epsilon */
                 ;

DesignatorIdent ::=  DOT IDENT
                | LBRACK Expression RBRACK
                ;
            

Condition ::=   Condition OR CondTerm
                | CondTerm
                ;
                          
CondTerm ::=    CondTerm AND CondFact
                | CondFact
                ;

CondFact ::=    Expression
                | Expression Relop Expression
                ;
    
                
Expression ::=    SUB AddopTermCombList
            | AddopTermCombList
            ;

AddopTermCombList ::=   AddopTermList    AddopRight  AddopTermCombList
                        | AddopTermList
                        ;

AddopTermList ::=   AddopTermList AddopLeft Term
                    | Term
                    ;

Term ::=    MulopFactorList MulopRight Term
            | MulopFactorList
            ;

MulopFactorList ::= MulopFactorList MulopLeft Factor
                    | Factor
                    ;

Factor ::=  Designator
            | Designator LPAREN ActParsListOpt RPAREN
            {: parser.IncreaseFunctionCallsCount(); :}
            | NUMBER
            | CHAR
            | BOOL
            | NEW Type
            | NEW Type LBRACK Expression RBRACK
            | LPAREN Expression RPAREN
            ;
            
Assignop ::= ASSIGN 
            | AddopRight
            | MulopRight
            ;

Relop ::=   EQUAL
            | NOT_EQUAL
            | GREATER
            | GREATER_EQUAL 
            | LESS
            | LESS_EQUAL
            ;

Addop ::=   AddopLeft 
            | AddopRight 
            ;

AddopLeft ::=   ADD 
                | SUB 
                ;

AddopRight ::=  ASSIGN_ADD 
                | ASSIGN_SUB 
                ;

Mulop ::=   MulopLeft 
            | MulopRight 
            ;

MulopLeft ::=   MUL 
                | DIV 
                | MOD 
                ;

MulopRight ::=  ASSIGN_MUL 
                | ASSIGN_DIV 
                | ASSIGN_MOD 
                ;