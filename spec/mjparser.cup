package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import java.util.*;
import java.util.stream.IntStream;
import rs.ac.bg.etf.pp1.MJParser.SCOPE;

// import java.io.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;

parser code {:
    public static enum SCOPE
    {
        METHOD_SCOPE,
        CLASS_SCOPE,
        CLASS_METHOD_SCOPE,
        MAIN_SCOPE
    }
    
    Stack<SCOPE> nestedScopes = new Stack<SCOPE>();
    
    int globalVariableCount = 0;
    int globalConstVariableCount = 0;
    int mainVariableCount = 0;
    int mainFunctionCallsCount = 0;
    int globalClassFunctionCount = 0;
    int staticClassFunctionCount = 0;
    int formalParamsCount = 0;
    int globalFunctionCount = 0;
    int classCount = 0;
    int classVariableCount = 0;
    
    boolean errorEncountered = false;
    boolean errorHandled = false;
    
    Struct lastType = null;
    Obj lastClass = null;
    Obj lastMethod = null;
    Obj extendsClass = null;
    
    void ReportError(String errorMessage)
    {
        errorEncountered = true;
        log.debug(errorMessage);
    }
    
    void ReportVarDeclError(char errorChar)
    {
        errorEncountered = true;
        if (nestedScopes.empty())
        {
            log.debug("Doslo je do greske prilikom deklaracije globalne promenljive pre znaka \""+errorChar + '\"');
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            log.debug("Doslo je do greske prilikom definicije lokalne promenljive unutrasnje klase pre znaka \"" +errorChar+ '\"');
            return;
        }
    }
    
    void IncreaseVariableCount()
    {
        
        if (nestedScopes.empty()) // Global scope
        {
            globalVariableCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.MAIN_SCOPE)
        {
            mainVariableCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            classVariableCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.METHOD_SCOPE)
        {
            return;
        }
    }
    
    void IncreaseConstVariableCount()
    {
        if (nestedScopes.empty()) // Global scope
        {
            globalConstVariableCount++;
        }
    }
    
    void IncreaseFunctionCount()
    {
        if (nestedScopes.empty()) // Global Scope
        {
            globalFunctionCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            globalClassFunctionCount++;
        }
    }
    
    void IncreaseStaticFunctionCount()
    {
        if (nestedScopes.empty()) // Global Scope
        {
            // globalFunctionCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            staticClassFunctionCount++;
        }
    }
    
    void IncreaseFunctionCallsCount()
    {
        if (nestedScopes.empty()) // Global scope
        {
            return;
        }
        
        if (nestedScopes.peek() == SCOPE.MAIN_SCOPE)
        {
            mainFunctionCallsCount++;   
            return;
        }
    }
    
    void InScope(SCOPE newScope)
    {
        if (nestedScopes.empty())
        {
            nestedScopes.push(newScope);
            return;
        }
        
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE && newScope == SCOPE.METHOD_SCOPE)
        {
            nestedScopes.push(SCOPE.CLASS_METHOD_SCOPE);
            return;
        }
        nestedScopes.push(newScope);   
    }
    
    void OutOfCurrentScope()
    {
        if (!nestedScopes.empty())
        {
            nestedScopes.pop();
        }
    }
    
    void VariableDeclaration(String name, int nameLocation, int objectType, 
        Obj assignedType, int assignLocation, boolean isConst)
    {
        if( Tab.currentScope.findSymbol(name) != null)
        {
             report_error(" " + name + " je vec deklarisano", nameLocation);
             return;
        }
        
        if(assignedType != null && assignedType.getType() != lastType)
        {
            report_error("neispravan tip promenljive koja se dodeljuje ", assignLocation);
            return;
        }
        
        if (lastType == null || lastType == Tab.noType)
        {
            report_error("Greska pri deklaraciji promenljive", null);
            return; 
        }
        
        Tab.insert(objectType, name, lastType);
        
        if (isConst) IncreaseConstVariableCount();
        else IncreaseVariableCount();
        
        report_info("Definisana promenljiva " + name + " tipa: "+lastType.getKind()+ " na liniji ", nameLocation);
    }

    // Overloading
    void VariableDeclaration(String name, int nameLocation, int objectType)
    {
        VariableDeclaration(name, nameLocation, objectType, null, 0, false);
    }
    
    void VariableDeclaration(String name, int nameLocation, int objectType, Obj assignedType, int assignedLocation)
    {
        VariableDeclaration(name, nameLocation, objectType, assignedType, assignedLocation, false);
    }

    void ClassDeclaration(String className, int classLocation)
    {
        if(Tab.currentScope.findSymbol(className) != null)
        {
            report_error("Klasa sa imenom " + className + "je vec deklarisana ", classLocation);
            return;
        }
        
        lastClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
        InScope(SCOPE.CLASS_SCOPE);
        Tab.openScope();
        classCount++;
        
        report_info("Definisana klasa " + className + " na liniji ", classLocation);
    }
    
    void ClassEnding()
    {
        if(extendsClass != null) {
            for (Obj obj : extendsClass.getType().getMembers()) {
                if(Tab.currentScope.findSymbol(obj.getName()) == null)
                      Tab.insert(obj.getKind(), obj.getName(), obj.getType());
                }
       }   
       extendsClass = null;
       
        // if (!nestedScopes.empty() && nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            HandleScopeEnd(lastClass); 
            lastClass = null;
        }          
    }
    
    void MethodDeclaration(String methodName, int methodLocation, Struct type, int typeLocation, boolean isStaticMethod)
    {
        if(Tab.currentScope.findSymbol(methodName) != null)
        {
              report_error("Naziv metode "+methodName + "je vec u upotrebi", methodLocation);
              return;
        }
        
        if(extendsClass != null) 
        {
           for (Obj o : extendsClass.getType().getMembers()) 
           {
               if(o.getKind() == Obj.Meth && o.getName().equals(methodName)) 
               if(o.getType().getElemType().getKind() == 6) 
                   {
                   // error
                   return;
                   }
          }
        }
        if (methodName.equals("main"))
        {
            if(type != Tab.noType)
            {
                report_error("Main mora biti tipa \"void\"",typeLocation);
                return;
            }
            if (isStaticMethod)
            {
                report_error("Main ne sme biti staticka metoda",methodLocation);
                return;
            }

            InScope(SCOPE.MAIN_SCOPE);
            InsertMethod(methodName, methodLocation, type.getKind());
            Tab.openScope();
            return;
        } 
        
       if(isStaticMethod) 
       {
           InsertMethod(methodName, methodLocation, 6);
       }
       else 
       {
           InsertMethod(methodName, methodLocation, type.getKind());
       }
       
       InScope(SCOPE.METHOD_SCOPE);
       Tab.openScope();
    }
    
    void InsertMethod(String methodName, int methodLocation, int methodType)
    {
           if (methodType == 7 ) IncreaseFunctionCount();
           else IncreaseStaticFunctionCount();
           Struct s = new Struct(lastType.getKind()); s.setElementType(new Struct(methodType));
           lastMethod = Tab.insert(Obj.Meth, methodName, s);
           report_info("Ubacena metoda "+methodName+" u tabelu simbola", methodLocation);
    }
    
    void MethodEnding()
    {
        // if (!nestedScopes.empty() &&
        // nestedScopes.peek() == SCOPE.METHOD_SCOPE ||
        // nestedScopes.peek() == SCOPE.MAIN_SCOPE || 
        // nestedScopes.peek() == SCOPE.CLASS_METHOD_SCOPE)
        {
            HandleScopeEnd(lastMethod);
            lastMethod = null;
        }
    }
    
    void HandleScopeEnd(Obj scopeName)
    {
        OutOfCurrentScope();
        Tab.chainLocalSymbols(scopeName);
        Tab.closeScope();
    }

    void HandleProgramEnd(Obj progName, int programLocation)
    {
        if(Tab.find("main") == Tab.noObj)
        {
            report_error("Metoda \"main\" nije pronadjena!", programLocation);
        }
        
        HandleScopeEnd(progName);
    }
    
    Struct CheckTypeAndUpdateLastType(String typeName, int nameLocation)
    {
        Obj typeNode = Tab.find(typeName);
        
        if (Obj.Type == typeNode.getKind()) 
        {
             return lastType = typeNode.getType();
        }
        
        lastType = Tab.noType;
        if (typeNode == Tab.noObj) 
        {
            report_error("U tabeli simbola nije pronadjen tip " + typeName + " referenciran na lokaciji", nameLocation);            
            return Tab.noType;
        }
        
        report_error(" ime " + typeName + " ne predstavlja tip ", nameLocation);
        return Tab.noType;
    }

    Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null) 
        log.info(s.toString() + " " + s.value.toString());
    return s;
:}

init with {:
    Tab.init(); // Universe scope
    Tab.currentScope.addToLocals(new Obj(Obj.Type, "bool",CUP$MJParser$actions.boolType));
:}

action code {:
int numberOfNestedFors = 0;
boolean isThisSpecified = false;
Obj backupDesig = null;
public static final int STATIC = 6;
public static final int Bool = 5;
public static final Struct boolType = new Struct(Struct.Bool);

Obj extendsClass = null;
Obj lastDesignator = null;

Collection<Obj> classFields = null;
List<Struct> actParams= new LinkedList<Struct>();

    String StructToTypeName(Struct structKind)
    {
        switch(structKind.getKind())
        {
            case 0:
            return "None";
            case 1:
            return "Int";
            case 2:
            return "Char";
            case 3:
            return "Array";
            case 4:
            return "Class";
            case 5:
            return "Bool";
            default:
            return "No such kind";
        }
    }
    
    public void EnteredFor()
    {
        ++numberOfNestedFors;
    }
    public void ExitedFor()
    {
        --numberOfNestedFors;
    }
    public boolean IsNotInForLoop()
    {
        return numberOfNestedFors == 0;
    }
    
    void ReturnCallCheck(Object returnCall, int returnLocation, Struct expr)
    {
        if(parser.lastMethod == null )
        {
            parser.report_error("Return mora biti iz funkcije pozvan ", returnLocation);
            return;
        }
        
        if(parser.lastMethod.getType() != Tab.noType)
        {
            parser.report_error("Funkcija mora vracati tip "+ StructToTypeName(parser.lastMethod.getType()), returnLocation);
            return;
        }
        
        if (expr != null && expr.getKind() != parser.lastMethod.getType().getKind())
        {
            parser.report_error("Funkcija vraca tip "+ StructToTypeName(expr) +" A mora vracati tip "+ 
            StructToTypeName(parser.lastMethod.getType()), returnLocation);
        }
    }
    
int [] correctObjTypes = {Obj.Var, Obj.Elem, Obj.Fld };
int [] correctStructTypes = {Struct.Int, Struct.Char, Struct.None};
    
    public boolean IsObjectVarElemOrFieldError(Obj designator, int designatorLocation)
    {
        if (!IntStream.of(correctObjTypes).anyMatch(x -> x == designator.getKind()))
        {
            parser.report_error(" " + designator.getName() + 
            " mora biti  promenljiva, element niza ili polje unutar objekta", designatorLocation);
            return false;
        }
        return true;
    }
    
    public boolean IsStructIntCharOrNone(Struct expr, int exprLocation)
    {
        if (!IntStream.of(correctStructTypes).anyMatch(x -> x == expr.getKind()))
        {       
            parser.report_error(" " + expr.getKind() + " mora biti tipa int, char ili bool.", exprLocation);                
            return false;
        }
        return true;
    }
    
    public void CorrectTypesForFunctionCalls(Obj designator, int designatorLocation)
    {
        if (IsObjectVarElemOrFieldError(designator, designatorLocation) &&
            IsStructIntCharOrNone(designator.getType(), designatorLocation))
         {
            parser.IncreaseFunctionCallsCount(); 
         }
    }
    
    public boolean IsAssignable(Obj design, Struct expr)
    {
        if(expr.assignableTo(design.getType())) // If expr is assignable to design
        {
            return true;
        }
        
        if( expr.getKind() != design.getType().getKind() || // If they are not same Struct type
            expr.getElemType() != design.getType().getElemType() || // If they are not same Struct.ElementType
            expr.getNumberOfFields() != design.getType().getNumberOfFields() || // If they don't have same params of fields
            expr.getMembers() == design.getType().getMembers()) // If they don't have same type of fields
        {
            return false;
        }
  /*
        if (design.getType().getKind() == Struct.Array && // If designator is Struct.Array
            expr.getElemType() == null && // Expression is not array
            !expr.assignableTo(design.getType().getElemType())) // if expr is assignable to type of designator elements
        {
            return false;
        }
     */   
        return true;
    }
    
    Obj GetResultIfBothInt(Obj result, int resultLocation, Struct term)
    {
        if (!IsObjectVarElemOrFieldError(result , resultLocation))
        {
            return Tab.noObj;
        }
        
        if (result.getType().getKind() == Struct.Int && term.getKind() == Struct.Int)
        {
            return result;
        }
        
       parser.report_error("Poslali ste tipove" + StructToTypeName(parser.lastMethod.getType()) +
            " i " + StructToTypeName(term) + " a moraju biti int ", resultLocation);
        return Tab.noObj;
    }
    
    void SaveExtendedClassMembers(Struct extendsClass)
    {
        if(extendsClass != null && extendsClass != Tab.noType && extendsClass.getKind() == Struct.Class) 
        {
            for (Obj obj : extendsClass.getMembers()) 
            {
                if(Tab.currentScope.findSymbol(obj.getName()) == null)
                      Tab.insert(obj.getKind(), obj.getName(), obj.getType());
            }
        }
    }
    
    
:}

terminal BREAK, CLASS, CONST, CONTINUE, ELSE, EXTENDS, FOR, IF, NEW, PRINT, PROG, READ, RETURN, STATIC, VOID;
terminal LBRACE, RBRACE, LBRACK, RBRACK, LPAREN, RPAREN;
terminal ADD, SUB, MUL, DIV, MOD;
terminal ASSIGN, ASSIGN_ADD, ASSIGN_SUB, ASSIGN_MUL, ASSIGN_DIV, ASSIGN_MOD;
terminal EQUAL, NOT_EQUAL, GREATER_EQUAL, LESS_EQUAL, GREATER, LESS;
terminal DEC, INC, OR, AND;
terminal SEMI, COMMA, DOT;
terminal BOOL, CHAR, NUMBER;

terminal String IDENT;


non terminal ClassDecl, ClassVarDecl, ClassVarDeclListOpt;
non terminal MethodDecl, MethodDeclOpt, MethodDeclListOpt, MethodVarDecl, MethodVarDeclListOpt, MethodIdentList;
non terminal DesignatorOpt, DesignatorStatement;
non terminal Addop, AddopLeft, AddopRight; 
non terminal Mulop, MulopLeft, MulopRight;       
non terminal VarArgs, VarDecl, VarDeclList, Var;
non terminal ConstIdent, ConstDecl, ConstDeclList;
non terminal FormalParamDecl;
non terminal Statement, StatementListOpt, StatementIfElse;
non terminal Condition, CondTerm, CondFact, CondOpt;

non terminal Decl, DeclListOpt;
non terminal NumOpt;
non terminal Assignop, AssignopError , Relop;
non terminal Program;

non terminal Obj ProgramName, Const, Designator, AddopTermList, MulopFactorList, Term, Factor, DesignatorListOpt, DesignatorIdent;
non terminal Boolean StaticOpt;
non terminal Struct Type, TypeVoid, Expression, AddopTermCombList, ExtendsOpt;
non terminal Integer ActParsListOpt, FormParamsOpt, FormalParamList, ActPars;

precedence left ELSE;

Program ::= PROG ProgramName:progName DeclListOpt LBRACE MethodDeclListOpt RBRACE
{:
    parser.HandleProgramEnd(progName, progNameleft);
:};

ProgramName ::= IDENT:progName
{:
    RESULT = Tab.insert(Obj.Prog, progName, Tab.noType);
    Tab.openScope();
:};

DeclListOpt ::= DeclListOpt Decl
                | /* epsilon */ 
                ;


Decl ::=    ClassDecl 
            | ConstDecl 
            | VarDecl 
            ;

//CONST DECLARATION
ConstDecl ::= CONST Type ConstDeclList SEMI;

ConstDeclList ::=   ConstDeclList COMMA ConstIdent
                    | ConstIdent
                    ;
                    
                
ConstIdent ::= IDENT:name ASSIGN Const:type
{: 
    parser.VariableDeclaration(name, nameleft, Obj.Con, type, typeleft);
:}
;

Const ::=   BOOL  {: RESULT = new Obj(Obj.Con, "", Tab.intType); :}
            | CHAR {: RESULT = new Obj(Obj.Con, "", Tab.charType); :}
            | NUMBER {: RESULT = new Obj(Obj.Con, "", new Struct(Struct.Bool)); :}
            ;

//VAR DECLARATION
VarDecl ::= Type VarDeclList SEMI
            | Type error SEMI
            {: parser.ReportVarDeclError(';'); :}
            ;

VarDeclList ::= VarDeclList COMMA Var
                | error COMMA Var
                {: parser.ReportVarDeclError(','); :}
                | Var 
                ;

Var ::= IDENT:name LBRACK RBRACK  
        {: 
            parser.lastType = new Struct(Struct.Array, parser.lastType);
            parser.VariableDeclaration(name, nameleft, Obj.Var); 
        :}
        | IDENT:name {: parser.VariableDeclaration(name, nameleft, Obj.Var); :}
        ;

Type ::= IDENT:name
        {:
            RESULT = parser.CheckTypeAndUpdateLastType(name, nameleft);
        :}
        ;

//CLASS VAR DECLARATION
ClassVarDeclListOpt ::= ClassVarDeclListOpt ClassVarDecl
                        | /*epsilon*/
                        ;

ClassVarDecl ::=    STATIC VarDecl
                    | VarDecl
                    ;

//CLASS DECLARATION
ClassDecl ::= CLASS IDENT:className ExtendsOpt:extendsClass LBRACE
{: 
    parser.ClassDeclaration(className, classNameleft);
:}

 ClassVarDeclListOpt MethodDeclOpt RBRACE
{:  
    SaveExtendedClassMembers(extendsClass);
    parser.ClassEnding();
:};


ExtendsOpt ::=  EXTENDS Type:type 
                {: 
                    if(!(type.getKind() == Struct.Class))
                        parser.report_error(" Tip objekta iz kog se pokusava izvodjenje mora biti klasa! ", typeleft);
                    RESULT = type;
                :}
                | EXTENDS error
                {:
                    parser.ReportError("Doslo je do greske prilikom deklaracije prosirenja natklase"); 
                    RESULT = Tab.noType;
                :}
                | /* epsilon */
                ;
            
//METHOD VAR DECLARATION
MethodVarDeclListOpt ::= MethodVarDeclListOpt MethodVarDecl
                        | /* epsilon */
                        ;

MethodVarDecl ::= Type MethodIdentList SEMI ;
                
MethodIdentList ::= MethodIdentList COMMA Var
                    | Var
                    ;

//METHOD DECLARATION
MethodDeclOpt ::=   LBRACE MethodDeclListOpt RBRACE
                    | /*epsilon*/
                    ;

MethodDeclListOpt ::= MethodDeclListOpt MethodDecl
                    | /* epsilon */
                    ;

MethodDecl ::= StaticOpt:isStaticMethod TypeVoid:type IDENT:methodName LPAREN 
                {:
                    parser.MethodDeclaration(methodName, methodNameleft, type, typeleft, isStaticMethod);
                :}
FormParamsOpt:numOfParams RPAREN MethodVarDeclListOpt LBRACE StatementListOpt RBRACE 
{: 
    if (methodName.equals("main") &&  numOfParams >0)
    {
        parser.report_error("Main ne sme imati argumente!", numOfParamsleft);
    }

    parser.lastMethod.setLevel(numOfParams);
    
    parser.MethodEnding();
:};

StaticOpt ::= 
            STATIC 
            {: RESULT = true; :}
            | /*epsilon*/ 
            {: RESULT = false;:}
            ;

TypeVoid ::= Type: type
            {: RESULT = type; // = parser.lastType:}
            | VOID
            {: RESULT = parser.lastType = Tab.noType;:}
            ;

VarArgs ::= COMMA Type:type DOT DOT DOT IDENT:name
            {:
                parser.lastType = new Struct(Struct.Array, parser.lastType);
                parser.VariableDeclaration(name, nameleft, Obj.Var);    
                parser.formalParamsCount++; 
            :};

FormParamsOpt ::=   FormalParamList:result
                    {: RESULT = result; :}
                    | FormalParamList:numOfParams VarArgs
                    {: RESULT = numOfParams+1; :}
                    | VarArgs 
                    {: RESULT = 1; :}
                    | error
                    {: parser.ReportError("Doslo je do greske prilikom deklaracije formalnog parametra funkcije pre znaka \")\""); :}
                    | /* epsilon */ 
                    {: RESULT = 0; :}
                    ;

FormalParamList ::= FormalParamList:numberOfParams COMMA FormalParamDecl
                    {: RESULT = numberOfParams + 1; :}
                    | error COMMA FormalParamDecl 
                    {: parser.ReportError("Doslo je do greske prilikom deklaracije formalnog parametra funkcije pre znaka \",\""); :}
                    | FormalParamDecl
                    {: RESULT = 1; :}
                    ;

FormalParamDecl ::= Type IDENT:name LBRACK RBRACK 
                    {: 
                        parser.lastType = new Struct(Struct.Array, parser.lastType);
                        parser.VariableDeclaration(name, nameleft, Obj.Var);
                        parser.formalParamsCount++; 
                    :}
                    | Type IDENT:name
                    {: 
                        parser.VariableDeclaration(name, nameleft, Obj.Var);
                        parser.formalParamsCount++; 
                    :}
                     ;

StatementListOpt ::= StatementListOpt Statement
                    | /* epsilon */
                    ;

Statement ::=   DesignatorStatement SEMI
                | StatementIfElse
                | FOR LPAREN DesignatorOpt SEMI CondOpt SEMI DesignatorOpt RPAREN {: EnteredFor(); :} Statement {: ExitedFor(); :}
                | BREAK SEMI:sem
                {: 
                if (IsNotInForLoop())
                        parser.report_error("Breakovati se moze samo iz unutar for petlje ", semleft);
                :}
                | CONTINUE SEMI:sem
                {:
                    if (IsNotInForLoop())
                        parser.report_error("Continue naredba se moze izvrsiti samo iz unutar for petlje ", semleft);
                :}
                | RETURN:ret SEMI
                {:
                    ReturnCallCheck(ret, retleft, null);
                :}
                | RETURN:ret Expression:expr SEMI
                {:
                    ReturnCallCheck(ret, retleft, expr);
                :}
                | READ LPAREN Designator:designator RPAREN SEMI
                {:
                    CorrectTypesForFunctionCalls(designator, designatorleft);
                :}
                | PRINT LPAREN Expression:expr NumOpt:width RPAREN SEMI
                {: 
                if (IsStructIntCharOrNone(expr, exprleft))
                {
                    parser.IncreaseFunctionCallsCount(); 
                }
                :}
                | LBRACE StatementListOpt RBRACE
                ;

StatementIfElse ::= IF LPAREN Condition RPAREN Statement 
                    | IF LPAREN Condition RPAREN Statement ELSE Statement 
                    | IF LPAREN error RPAREN Statement
                    {: parser.ReportError("Doslo je do greske u logickom izrazu unutar IF konstrukcije"); :}
                    | IF LPAREN error RPAREN Statement ELSE Statement 
                    {: parser.ReportError("Doslo je do greske u logickom izrazu unutar IF-ELSE konstrukcije"); :}
                    ;
                    
NumOpt ::=  COMMA NUMBER:width
            {: RESULT = width; :}
            | /* epsilon */
            {: RESULT = 5; :}
            ;

DesignatorOpt ::= DesignatorStatement 
            | error
            {: parser.ReportError("Doslo je do greske unutar FOR(...) konstrukcije"); :}
            | /* epsilon */
            ;

CondOpt ::=  Condition
            | error
            {: parser.ReportError("Doslo je do greske u logickom iskazu unutar FOR(...) konstrukcije"); :}
            | /* epsilon */ 
            ;

DesignatorStatement ::= Designator:designator Assignop Expression:expr
                        {:
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if (!IsAssignable(designator, expr))
                                {
                                    parser.report_error("Nemoguce je dodeliti vrednost tipa "+StructToTypeName(expr) + "variabli tipa " +StructToTypeName(designator.getType()) , designatorleft);
                                }
                            }
                        :}
                        | Designator:designator LPAREN ActParsListOpt:args RPAREN
                        {:
                            if(designator.getKind() != Obj.Meth)
                            {
                                parser.report_error("Funkcija mora biti deklarisana pre poziva",designatorleft);
                                designator = Tab.noObj;
                            }  
                                
                            if(designator != Tab.noObj) 
                            {
                                if(args != designator.getLevel()) 
                                {
                                    parser.report_error(" Broj argumenata funkcije nije dobar."+ designator.getName(), argsleft);
                                }
                                else
                                {
                                    for(int i = 0; i < args; i++) {
                                        Obj o = ((Obj) designator.getLocalSymbols().toArray()[i]);
                                        Struct s = actParams.get(actParams.size() - (args - i)); // sta ce aoba
                                        //if(!o.getType().compatibleWith(s))
                                         //   if(!(o.getType().getKind() != Struct.Class && o.getType().getKind() == s.getKind() && o.getType().getElemType() == s.getElemType() && o.getType().getNumberOfFields() == s.getNumberOfFields()))
                                           if (!IsAssignable(o,s)) 
                                           {
                                                parser.report_error(" Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva.", argsleft);
                                                break;
                                           }
                                    }
                                }
                                for(int i = 0; i < args; i++)
                                        actParams.remove(actParams.size() - 1);
                            }
                            parser.IncreaseFunctionCallsCount(); 
                            
                        :}
                        | Designator:designator INC
                        {:  
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if(designator.getType().getKind() != Struct.Int)
                                {
                                    parser.report_error("Prilikom INC " + designator.getName() + " mora biti int ", designatorleft);
                                }
                            }
                        :}
                        | Designator:designator DEC
                        {:  
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if(designator.getType().getKind() != Struct.Int)
                                {
                                    parser.report_error("Prilikom INC " + designator.getName() + " mora biti int ", designatorleft);
                                }
                            }
                        :}
                        | Designator Assignop error 
                        {: parser.ReportError("Doslo je do prilikom dodele vrednosti pre znaka ;"); :}
                        ;

ActParsListOpt ::=  ActPars:args
                    {: RESULT = args; :} 
                    | /* epsilon */ 
                    {: RESULT = 0; :}
                    ;

ActPars ::= ActPars:args COMMA Expression:expr
            {:
                actParams.add(expr);
                RESULT = args+1;
            :}
            | Expression:expr
            {:
                actParams.add(expr);
                RESULT = 1;
            :}
            ;
            
Designator ::= IDENT:name 
                {:
                  if(name.equals("this")) {
                    if(parser.lastMethod != null) {
                        if(parser.lastMethod.getType().getElemType().getKind() != STATIC) // SIPRAVI !!
                            isThisSpecified = true;
                        else {
                            parser.report_error("this moze postojati samo u nestatickim metodama", nameleft);
                            isThisSpecified = true;
                        }
                    }
                  } else {
                    
                    Obj o = Tab.currentScope.findSymbol(name);
                    if(o== null) {
                        Obj o1 = Tab.find(name);
                        if(o1 != Tab.noObj) {
                            if(o1.getType().getKind() == Struct.Array)
                                lastDesignator = o1;
                    }
                        else { 
                            Obj found = null;
                            if(parser.extendsClass != null) {
                                for (Obj o2 : parser.extendsClass.getType().getMembers()) {
                                    if(o2.getName().equals(name))
                                        found = o2;
                                }
                            }
                            if(found != null) {
                                if(found.getType().getKind() == Struct.Array) {
                                    lastDesignator = found;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                o1 = found;
                            } else
                                parser.report_error("" + name + "nije nadjeno", nameleft);
                        }
                        lastDesignator = o1;
                        RESULT = o1;
                    }
                    else {
                      if(parser.lastMethod != null) {
                        if(o.getType().getKind() == Struct.Array)
                            lastDesignator = o;                       
                      }
                        RESULT = lastDesignator = o;
                    }  
                  }
                :}
                DesignatorListOpt:res {: if(res != null) RESULT = res; :}
                ;

DesignatorListOpt ::= DesignatorListOpt DesignatorIdent:val
                    {: 
                        if (val != null) RESULT = val;
                    :}
                     | /* epsilon */
                     ;

DesignatorIdent ::=  DOT IDENT:name
            {:
            if(!(isThisSpecified || (lastDesignator != null && (lastDesignator.getKind() == Obj.Elem || lastDesignator.getKind() == Obj.Var || lastDesignator.getKind() == Obj.Fld )&& lastDesignator.getType().getKind() == Struct.Class))) {
                        if(lastDesignator.getKind() == Obj.Type) {
                            if(isThisSpecified) {
                                Obj o = Tab.currentScope().getOuter().findSymbol(name);
                                if(o != null) {
                                    if(o.getKind() != Obj.Meth) {
                                        parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                        lastDesignator = Tab.noObj;
                                    } else if(o.getType().getElemType().getKind() != STATIC) {
                                        parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                        lastDesignator = Tab.noObj;
                                    } else {
                                        lastDesignator = o;
                                    }
                                }
                                else { // ako koristimo this a nema ga u toj klasi, proveravamo da li je klasa izvedena
                                      // i ima li u osnovnoj onda
                                    Obj found = null;
                                    if(parser.extendsClass != null) {
                                        for (Obj o1 : parser.extendsClass.getType().getMembers()) {
                                            if(o1.getName().equals(name))
                                                found = o1;
                                        }
                                    }
                                    if(found != null) {
                                        if(found.getKind() != Obj.Meth) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else if(found.getType().getElemType().getKind() != 6) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else {
                                            lastDesignator = found;
                                        }
                                    } else {
                                        parser.report_error("(this." + name + ") nije nadjeno", nameleft);
                                        lastDesignator = Tab.noObj;
                                    }
                                }
                            } else {
                                Obj found = null;
                                if(lastDesignator != null) {
                                    for (Obj o : lastDesignator.getType().getMembers()) { //pronalazimo u klasi ovaj naziv
                                        if(o.getName().equals(name))
                                            found = o;
                                    }
                                    if(found != null){
                                        if(found.getKind() != Obj.Meth) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else if(found.getType().getElemType().getKind() != 6) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else {
                                            lastDesignator = found;
                                        }
                                    } else {
                                        parser.report_error("(" + lastDesignator.getName() + "." + name + ") nije nadjeno", nameleft);
                                        lastDesignator = Tab.noObj;
                                    }
                                }
                            }
                            isThisSpecified = false;
                            RESULT = lastDesignator;
                        }
                        else {
                            parser.report_error(": " + lastDesignator.getName() + " nije klasa", nameleft);
                            lastDesignator = Tab.noObj;
                        }
                } else {
                    if(isThisSpecified) {
                        Obj o = Tab.currentScope().getOuter().findSymbol(name);
                        if(o != null) {
                            if(o.getType().getKind() == Struct.Array) {
                                lastDesignator = o;
                                if(lastDesignator != null && lastDesignator.getType() != null)
                                    classFields = lastDesignator.getType().getMembers();
                            }
                            lastDesignator = o;
                        }
                        else { // ako koristimo this a nema ga u toj klasi, proveravamo da li je klasa izvedena
                              // i ima li u osnovnoj onda
                            Obj found = null;
                            if(parser.extendsClass != null) {
                                for (Obj o1 : parser.extendsClass.getType().getMembers()) {
                                    if(o1.getName().equals(name))
                                        found = o1;
                                }
                            }
                            if(found != null) {
                                if(found.getType().getKind() == Struct.Array) {
                                    lastDesignator = found;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                lastDesignator = found;
                            } else
                                parser.report_error("(this." + name + ") nije nadjeno", nameleft);
                        }
                    } else {
                        Obj found = null;
                        if(lastDesignator != null) {
                            for (Obj o : lastDesignator.getType().getMembers()) { //pronalazimo u klasi ovaj naziv
                                if(o.getName().equals(name))
                                    found = o;
                            }
                            if(found != null){
                                if(found.getType().getKind() == Struct.Array) {
                                     lastDesignator = found;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                lastDesignator = found;
                            } else
                                parser.report_error("(" + lastDesignator.getName() + "." + name + ") nije nadjeno", nameleft);
                        }
                    }
                    isThisSpecified = false;
                    RESULT = lastDesignator;
                }
            :}
            |
            LBRACK:brack
            {:
            if(lastDesignator.getType().getKind() != Struct.Array) {
                    parser.report_error(": " + lastDesignator.getName() + " nije niz", brackleft);
                    RESULT = Tab.noObj;
            } else
                   backupDesig = lastDesignator;
             :}
             Expression:expr RBRACK   
             {:  
            if(expr.getKind() != Struct.Int)
                parser.report_error(" tip u zagradama niza mora biti int a vama je :"+ expr.getKind(),exprleft);
              else {
                    //if(RESULT == null) {
                        if(backupDesig != null)
                            RESULT = lastDesignator = new Obj(Obj.Elem, backupDesig.getName(), backupDesig.getType().getElemType(), backupDesig.getAdr(), backupDesig.getLevel());
                        else
                            RESULT = lastDesignator = Tab.noObj;
                    //}
                }
                
            :}
           
            ;
            

Condition ::=   Condition OR CondTerm
                | CondTerm
                ;
                          
CondTerm ::=    CondTerm AND CondFact
                | CondFact
                ;

CondFact ::=    Expression
                | Expression Relop Expression
                ;
    
                
Expression ::= SUB AddopTermCombList:result
            {: 
                RESULT = result;
                
                if (result.getKind() != Struct.Int)
                {
                     RESULT = Tab.noType;
                     parser.report_error("izraz nakon minusa mora biti tipa int", resultleft);
                }
            :}
            | AddopTermCombList:result
            {:
                RESULT = result;
            :}
            ;

AddopTermCombList ::=   AddopTermList:result  AddopRight  AddopTermCombList:term
                        {: 
                            RESULT = GetResultIfBothInt(result, resultleft, term).getType();
                        :}
                        | AddopTermList:result
                        {:
                           if(result != null)
                        RESULT = result.getType();
                        else
                        RESULT = Tab.noType;
                        :}
                        ;

AddopTermList ::=   AddopTermList:result AddopLeft Term:term
                    {:
                        if (GetResultIfBothInt(result, resultleft, term.getType()) != Tab.noObj)
                        {
                            RESULT = new Obj(Obj.Con, "Addition result", Tab.intType); 
                        }
                    :}
                    | Term:result
                    {: RESULT = result; :}
                    ;

Term ::=    MulopFactorList:result  MulopRight Term:term
            {:
                RESULT = GetResultIfBothInt(result, resultleft, term.getType());
            :}
            | MulopFactorList:result
            {: RESULT = result; :}
            ;

MulopFactorList ::= MulopFactorList:result MulopLeft Factor:fact
                    {:
                        RESULT = Tab.noObj;
                        if (GetResultIfBothInt(result, resultleft, fact.getType()) != Tab.noObj)
                        {
                            RESULT = new Obj(Obj.Con, "Multiplication result", Tab.intType); 
                        }  
                    :}
                    | Factor:result
                    {: RESULT = result; :}
                    ;

Factor ::=  Designator:designator
            {: RESULT = designator; :}
            | Designator:designator  LPAREN ActParsListOpt:params RPAREN
            {:
                parser.IncreaseFunctionCallsCount();
                if (designator.getKind() != Obj.Meth)
                { 
                    parser.report_error("Funkcija nije deklarisana",designatorleft);
                    RESULT = Tab.noObj;
                }
                else
                {
                    RESULT = new Obj(Obj.Meth, 
                        designator.getName(), 
                        new Struct(designator.getType().getKind()), 
                        designator.getAdr(), 
                        designator.getLevel());   
                }
                
                if(RESULT != Tab.noObj) {
                    if(params == RESULT.getLevel()) {
                        boolean flag = true;
                        for(int i = 0; i < params; i++) {
                            Obj o = ((Obj) designator.getLocalSymbols().toArray()[i]);
                            Struct s = actParams.get(actParams.size() - (params - i));
                            // if(!o.getType().compatibleWith(s))
                            //    if(!(o.getType().getKind() != Struct.Class && o.getType().getKind() == s.getKind() && o.getType().getElemType() == s.getElemType() && o.getType().getNumberOfFields() == s.getNumberOfFields()))
                             if (!IsAssignable(o,s))
                                    flag = false;
                        }
                        
                        if(!flag)
                            parser.report_error(" Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva.", paramsleft);
                        else {
                            if(RESULT.getType() != Tab.noType)
                                RESULT = new Obj(Obj.Con, "", RESULT.getType());
                                
                            else                            
                                parser.report_error(" Funkcija nema povratnu vrednost.", paramsleft);
                            
                        }
                    } else {
                        parser.report_error(" Broj argumenata funkcije nije dobar."+ RESULT.getName(), paramsleft);                        
                    }
                    for(int i = 0; i < params; i++)
                            actParams.remove(actParams.size() - 1);
                }
            :}
            | NUMBER:number
            {: RESULT = new Obj(Obj.Con, "" + number, Tab.intType); :}
            | CHAR:chr
            {: RESULT = new Obj(Obj.Con, "" + chr, Tab.charType); :}
            | BOOL:bool
            {: RESULT = new Obj(Obj.Con, "" + bool, Tab.intType); :}
            | NEW Type:type
            {:
                if(type.getKind()!=Struct.Class)
                    parser.report_error("tip prilikom pravljenja objekta mora biti unutrasnja klasa",typeleft);
                else
                {
                if(lastDesignator.getType().getKind() != type.getKind()) {
                      parser.report_error(": tipovi se ne podudaraju ", typeleft);
                      RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                } else
                      RESULT = new Obj(Obj.NO_VALUE, "", type);
                
                }
            :}
            |
            NEW Type:type 
            {:
                Obj obj = Tab.noObj;
                if(classFields == null)
                    obj = Tab.find(lastDesignator.getName());      
                else  { 
                    for (Obj o : classFields) { 
                        if(o.getName().equals(lastDesignator.getName()))
                            obj = o;
                    }
                } 
                                
                if(obj == Tab.noObj)
                    RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                else {
                    if(obj.getType().getElemType() != type) {
                        parser.report_error("Ne podudaraju se tipovi. ", typeleft);
                        RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                    }
                } 
                    
                classFields = null;
            :}
            LBRACK Expression:expr RBRACK
            {:
                if(expr.getKind() == Struct.Int)
                    RESULT = new Obj(Obj.NO_VALUE, "", new Struct(Struct.Array, type));
                else {
                    parser.report_error(": tip expr mora biti int", typeleft);
                    RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                } 
            :}
            /*| NEW Type:type LBRACK Expression:expr RBRACK
            {:
                if (expr.getKind() != Struct.Int)
                {
                    parser.report_error("Velicina niza mora biti int", exprleft);
                    RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                }
                else
                {
                    RESULT = new Obj(Obj.NO_VALUE, "", new Struct(Struct.Array, type));
                }
            :}*/
            | LPAREN Expression:expr RPAREN
            {: RESULT = new Obj(Obj.Con, "", expr); :}
            ;
            
Assignop ::= ASSIGN 
            | AddopRight
            | MulopRight
            ;

Relop ::=   EQUAL
            | NOT_EQUAL
            | GREATER
            | GREATER_EQUAL 
            | LESS
            | LESS_EQUAL
            ;

Addop ::=   AddopLeft 
            | AddopRight 
            ;

AddopLeft ::=   ADD 
                | SUB 
                ;

AddopRight ::=  ASSIGN_ADD 
                | ASSIGN_SUB 
                ;

Mulop ::=   MulopLeft 
            | MulopRight 
            ;

MulopLeft ::=   MUL 
                | DIV 
                | MOD 
                ;

MulopRight ::=  ASSIGN_MUL 
                | ASSIGN_DIV 
                | ASSIGN_MOD 
 ;