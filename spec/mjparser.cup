package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import java.util.Stack;
import java.util.stream.IntStream;
import rs.ac.bg.etf.pp1.MJParser.SCOPE;

// import java.io.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;

parser code {:
    public static enum SCOPE
    {
        METHOD_SCOPE,
        CLASS_SCOPE,
        CLASS_METHOD_SCOPE,
        MAIN_SCOPE
    }
    
    Stack<SCOPE> nestedScopes = new Stack<SCOPE>();
    
    int globalVariableCount = 0;
    int globalConstVariableCount = 0;
    int mainVariableCount = 0;
    int mainFunctionCallsCount = 0;
    int globalClassFunctionCount = 0;
    int staticClassFunctionCount = 0;
    int formalParamsCount = 0;
    int globalFunctionCount = 0;
    int classCount = 0;
    int classVariableCount = 0;
    
    boolean errorEncountered = false;
    boolean errorHandled = false;
    
    Struct lastType = null;
    Obj lastClass = null;
    Obj lastMethod = null;
    
    void ReportError(String errorMessage)
    {
        errorEncountered = true;
        log.debug(errorMessage);
    }
    
    void ReportVarDeclError(char errorChar)
    {
        errorEncountered = true;
        if (nestedScopes.empty())
        {
            log.debug("Doslo je do greske prilikom deklaracije globalne promenljive pre znaka \""+errorChar + '\"');
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            log.debug("Doslo je do greske prilikom definicije lokalne promenljive unutrasnje klase pre znaka \"" +errorChar+ '\"');
            return;
        }
    }
    
    void IncreaseVariableCount()
    {
        
        if (nestedScopes.empty()) // Global scope
        {
            globalVariableCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.MAIN_SCOPE)
        {
            mainVariableCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            classVariableCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.METHOD_SCOPE)
        {
            return;
        }
    }
    
    void IncreaseConstVariableCount()
    {
        if (nestedScopes.empty()) // Global scope
        {
            globalConstVariableCount++;
        }
    }
    
    void IncreaseFunctionCount()
    {
        if (nestedScopes.empty()) // Global Scope
        {
            globalFunctionCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            globalClassFunctionCount++;
        }
    }
    
    void IncreaseStaticFunctionCount()
    {
        if (nestedScopes.empty()) // Global Scope
        {
            // globalFunctionCount++;
            return;
        }
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            staticClassFunctionCount++;
        }
    }
    
    void IncreaseFunctionCallsCount()
    {
        if (nestedScopes.empty()) // Global scope
        {
            return;
        }
        
        if (nestedScopes.peek() == SCOPE.MAIN_SCOPE)
        {
            mainFunctionCallsCount++;   
            return;
        }
    }
    
    void InScope(SCOPE newScope)
    {
        if (nestedScopes.empty())
        {
            nestedScopes.push(newScope);
            return;
        }
        
        if (nestedScopes.peek() == SCOPE.CLASS_SCOPE && newScope == SCOPE.METHOD_SCOPE)
        {
            nestedScopes.push(SCOPE.CLASS_METHOD_SCOPE);
            return;
        }
        nestedScopes.push(newScope);   
    }
    
    void OutOfCurrentScope()
    {
        if (!nestedScopes.empty())
        {
            nestedScopes.pop();
        }
    }
    
    void VariableDeclaration(String name, int nameLocation, int objectType, 
        Obj assignedType, int assignLocation, boolean isConst)
    {
        if( Tab.currentScope.findSymbol(name) != null)
        {
             report_error(" " + name + " je vec deklarisano", nameLocation);
             return;
        }
        
        if(assignedType != null && assignedType.getType() != lastType)
        {
            report_error("neispravan tip promenljive koja se dodeljuje ", assignLocation);
            return;
        }
        
        if (lastType == null || lastType == Tab.noType)
        {
            report_error("Greska pri deklaraciji promenljive", null);
            return; 
        }
        
        Tab.insert(objectType, name, lastType);
        
        if (isConst) IncreaseConstVariableCount();
        else IncreaseVariableCount();
        
        report_info("Definisana promenljiva " + name + " tipa: "+lastType.getKind()+ " na liniji ", nameLocation);
    }

    // Overloading
    void VariableDeclaration(String name, int nameLocation, int objectType)
    {
        VariableDeclaration(name, nameLocation, objectType, null, 0, false);
    }
    
    void VariableDeclaration(String name, int nameLocation, int objectType, Obj assignedType, int assignedLocation)
    {
        VariableDeclaration(name, nameLocation, objectType, assignedType, assignedLocation, false);
    }

    void ClassDeclaration(String className, int classLocation)
    {
        if(Tab.currentScope.findSymbol(className) != null)
        {
            report_error("Klasa sa imenom " + className + "je vec deklarisana ", classLocation);
            return;
        }
        
        lastClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
        InScope(SCOPE.CLASS_SCOPE);
        Tab.openScope();
        classCount++;
        
        report_info("Definisana klasa " + className + " na liniji ", classLocation);
    }
    
    void ClassEnding()
    {
        // if (!nestedScopes.empty() && nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
            HandleScopeEnd(lastClass); 
            lastClass = null;
        }          
    }
    
    void MethodDeclaration(String methodName, int methodLocation, Struct type, int typeLocation, boolean isStaticMethod)
    {
        if(Tab.currentScope.findSymbol(methodName) != null)
        {
              report_error("Naziv metode "+methodName + "je vec u upotrebi", methodLocation);
              return;
        }
        
        if (methodName.equals("main"))
        {
            if(type != Tab.noType)
            {
                report_error("Main mora biti tipa \"void\"",typeLocation);
                return;
            }
            if (isStaticMethod)
            {
                report_error("Main ne sme biti staticka metoda",methodLocation);
                return;
            }
            InScope(SCOPE.MAIN_SCOPE);
            InsertMethod(methodName, methodLocation, type.getKind());
            Tab.openScope();
            return;
        } 
        
       if(isStaticMethod) 
       {
           InsertMethod(methodName, methodLocation, 6);
       }
       else 
       {
           InsertMethod(methodName, methodLocation, type.getKind());
       }
       
       InScope(SCOPE.METHOD_SCOPE);
       Tab.openScope();
    }
    
    void InsertMethod(String methodName, int methodLocation, int methodType)
    {
           if (methodType == 7 ) IncreaseFunctionCount();
           else IncreaseStaticFunctionCount();
           Struct s = new Struct(lastType.getKind()); s.setElementType(new Struct(methodType));
           lastMethod = Tab.insert(Obj.Meth, methodName, s);
           report_info("Ubacena metoda "+methodName+" u tabelu simbola", methodLocation);
    }
    
    void MethodEnding()
    {
        // if (!nestedScopes.empty() &&
        // nestedScopes.peek() == SCOPE.METHOD_SCOPE ||
        // nestedScopes.peek() == SCOPE.MAIN_SCOPE || 
        // nestedScopes.peek() == SCOPE.CLASS_METHOD_SCOPE)
        {
            HandleScopeEnd(lastMethod);
            lastMethod = null;
        }
    }
    
    void HandleScopeEnd(Obj scopeName)
    {
        OutOfCurrentScope();
        Tab.chainLocalSymbols(scopeName);
        Tab.closeScope();
    }

    void HandleProgramEnd(Obj progName, int programLocation)
    {
        if(Tab.find("main") == Tab.noObj)
        {
            report_error("Metoda \"main\" nije pronadjena!", programLocation);
        }
        
        HandleScopeEnd(progName);
    }
    
    Struct CheckTypeAndUpdateLastType(String typeName, int nameLocation)
    {
        Obj typeNode = Tab.find(typeName);
        
        if (Obj.Type == typeNode.getKind()) 
        {
             return lastType = typeNode.getType();
        }
        
        lastType = Tab.noType;
        if (typeNode == Tab.noObj) 
        {
            report_error("U tabeli simbola nije pronadjen tip " + typeName + " referenciran na lokaciji", nameLocation);            
            return Tab.noType;
        }
        
        report_error(" ime " + typeName + " ne predstavlja tip ", nameLocation);
        return Tab.noType;
    }

    Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null) 
        log.info(s.toString() + " " + s.value.toString());
    return s;
:}

init with {:
    Tab.init(); // Universe scope
:}

action code {:
int numberOfNestedFors = 0;

    String StructToTypeName(Struct structKind)
    {
        switch(structKind.getKind())
        {
            case 0:
            return "None";
            case 1:
            return "Int";
            case 2:
            return "Char";
            case 3:
            return "Array";
            case 4:
            return "Class";
            case 5:
            return "Bool";
            default:
            return "No such kind";
        }
    }
    
    public void EnteredFor()
    {
        ++numberOfNestedFors;
    }
    public void ExitedFor()
    {
        --numberOfNestedFors;
    }
    public boolean IsNotInForLoop()
    {
        return numberOfNestedFors == 0;
    }
    
    void ReturnCallCheck(Object returnCall, int returnLocation, Struct expr)
    {
        if(parser.lastMethod == null )
        {
            parser.report_error("Return mora biti iz funkcije pozvan ", returnLocation);
            return;
        }
        
        if(parser.lastMethod.getType() != Tab.noType)
        {
            parser.report_error("Funkcija mora vracati tip "+ StructToTypeName(parser.lastMethod.getType()), returnLocation);
            return;
        }
        
        if (expr != null && expr.getKind() != parser.lastMethod.getType().getKind())
        {
            parser.report_error("Funkcija vraca tip "+ StructToTypeName(expr) +" A mora vracati tip "+ 
            StructToTypeName(parser.lastMethod.getType()), returnLocation);
        }
    }
    
int [] correctObjTypes = {Obj.Var, Obj.Elem, Obj.Fld };
int [] correctStructTypes = {Struct.Int, Struct.Char, Struct.None};
    
    public boolean IsObjectVarElemOrFieldError(Obj designator, int designatorLocation)
    {
        if (!IntStream.of(correctObjTypes).anyMatch(x -> x == designator.getKind()))
        {
            parser.report_error(" " + designator.getName() + 
            " mora biti  promenljiva, element niza ili polje unutar objekta", designatorLocation);
            return;
        }
    }
    
    public boolean IsStructIntCharOrNone(Struct expr, int exprLocation)
    {
        if (!IntStream.of(correctStructTypes).anyMatch(x -> x == designator.getType().getKind()))
        {       
            parser.report_error(" " + designator.getName() + " mora biti tipa int, char ili bool.", designatorLocation);                
            return;
        }
    }
    
    public void CorrectTypesForFunctionCalls(Obj designator, int designatorLocation)
    {
        If (
            IsObjectVarElemOrFieldError(designator, designatorLocation) &&
            IsStructIntCharOrNone(designator.getType(), designatorLocation))
         {
            parser.IncreaseFunctionCallsCount(); 
         }
    }
    
    public boolean IsAssignable(Obj design,Struct expr)
    {
        if(expr.assignableTo(design.getType())) // If expr is assignable to design
        {
            return true;
        }
        
        if( expr.getKind() != design.getType().getKind() || // If they are not same Struct type
            expr.getElemType() != desig.getType().getElemType() || // If they are not same Struct.ElementType
            expr.getNumberOfFields() != desig.getType().getNumberOfFields() || // If they don't have same num of fields
            expr.getMembers() == desig.getType().getMembers()) // If they don't have same type of fields
        {
            return false;
        }
  /*
        if (desig.getType().getKind() == Struct.Array && // If desig is Struct.Array
            expr.getElemType() == null && // Expr is not array
            !expr.assignableTo(desig.getType().getElemType())) // if expr is assignable to type of desig elements
        {
            return false;
        }
     */   
        return true;
    }
    
    Struct GetResultIfBothInt(Obj result, int resultLocation, Struct term)
    {
        if (!IsObjectVarElemOrFieldError(result , resultLocation))
        {
            return Tab.noType;
        }
        
        if (result.getType.getKind() == Struct.Int && term.getKind() == Struct.Int)
        {
            return result.getType();
        }
        
       parser.report_error("Poslali ste tipove" + StructToTypeName(parser.lastMethod.getType()) +
            " i " + StructToTypeName(term) + " a moraju biti int ", resultleft);
        return Tab.noType;
    }
    
:}

terminal BREAK, CLASS, CONST, CONTINUE, ELSE, EXTENDS, FOR, IF, NEW, PRINT, PROG, READ, RETURN, STATIC, VOID;
terminal LBRACE, RBRACE, LBRACK, RBRACK, LPAREN, RPAREN;
terminal ADD, SUB, MUL, DIV, MOD;
terminal ASSIGN, ASSIGN_ADD, ASSIGN_SUB, ASSIGN_MUL, ASSIGN_DIV, ASSIGN_MOD;
terminal EQUAL, NOT_EQUAL, GREATER_EQUAL, LESS_EQUAL, GREATER, LESS;
terminal DEC, INC, OR, AND;
terminal SEMI, COMMA, DOT;
terminal BOOL, CHAR, NUMBER;

terminal String IDENT;

non terminal ClassDecl, ClassVarDecl, ClassVarDeclListOpt;
non terminal MethodDecl, MethodDeclOpt, MethodDeclListOpt, MethodVarDecl, MethodVarDeclListOpt, MethodIdentList;
non terminal DesignatorOpt, DesignatorListOpt, DesignatorStatement, DesignatorIdent;
non terminal Addop, AddopLeft, AddopRight; 
non terminal Mulop, MulopLeft, MulopRight;       
non terminal VarArgs, VarDecl, VarDeclList, Var;
non terminal ConstIdent, ConstDecl, ConstDeclList;
non terminal FormalParamDecl, FormParamsOpt, FormalParamList;
non terminal Statement, StatementListOpt, StatementIfElse;
non terminal Condition, CondTerm, CondFact, CondOpt;

non terminal Decl, DeclListOpt;
non terminal ExtendsOpt, NumOpt;
non terminal Assignop, AssignopError, ActPars ,ActParsListOpt, Relop;
non terminal Program, Factor;

non terminal Obj ProgramName, Const, Designator, AddopTermList, MulopFactorList, Term;
non terminal Boolean StaticOpt;
non terminal Struct Type, TypeVoid, Expression, AddopTermCombList;

precedence left ELSE;

Program ::= PROG ProgramName:progName DeclListOpt LBRACE MethodDeclListOpt RBRACE
{:
    parser.HandleProgramEnd(progName, progNameleft);
:};

ProgramName ::= IDENT:progName
{:
    RESULT = Tab.insert(Obj.Prog, progName, Tab.noType);
    Tab.openScope();
:};

DeclListOpt ::= DeclListOpt Decl
                | /* epsilon */ 
                ;


Decl ::=    ClassDecl 
            | ConstDecl 
            | VarDecl 
            ;

//CONST DECLARATION
ConstDecl ::= CONST Type ConstDeclList SEMI;

ConstDeclList ::=   ConstDeclList COMMA ConstIdent
                    | ConstIdent
                    ;
                    
                
ConstIdent ::= IDENT:name ASSIGN Const:type
{: 
    parser.VariableDeclaration(name, nameleft, Obj.Con, type, typeleft);
:}
;

Const ::=   BOOL  {: RESULT = new Obj(Obj.Con, "", Tab.intType); :}
            | CHAR {: RESULT = new Obj(Obj.Con, "", Tab.charType); :}
            | NUMBER {: RESULT = new Obj(Obj.Con, "", Tab.intType); :} // EEEEEEEEEEEEEEEEEE
            ;

//VAR DECLARATION
VarDecl ::= Type VarDeclList SEMI
            | Type error SEMI
            {: parser.ReportVarDeclError(';'); :}
            ;

VarDeclList ::= VarDeclList COMMA Var
                | error COMMA Var
                {: parser.ReportVarDeclError(','); :}
                | Var 
                ;

Var ::= IDENT:name LBRACK RBRACK  
{: 
    parser.lastType = new Struct(Struct.Array, parser.lastType);
    parser.VariableDeclaration(name, nameleft, Obj.Var); 
:}
        | IDENT:name {: parser.VariableDeclaration(name, nameleft, Obj.Var); :}
           ;

Type ::= IDENT:name
{:
    RESULT = parser.CheckTypeAndUpdateLastType(name, nameleft);
:}
;

//CLASS VAR DECLARATION
ClassVarDeclListOpt ::= ClassVarDeclListOpt ClassVarDecl
                        | /*epsilon*/
                        ;

ClassVarDecl ::=    STATIC VarDecl
                    | VarDecl
                    ;

//CLASS DECLARATION
ClassDecl ::= CLASS IDENT:className ExtendsOpt LBRACE
{: 
    parser.ClassDeclaration(className, classNameleft);
:}

 ClassVarDeclListOpt MethodDeclOpt RBRACE
{:  
    parser.ClassEnding();
:};


ExtendsOpt ::=  EXTENDS Type:type 
            {: 
                if(!(type.getKind() == Struct.Class))
                    parser.report_error(" Tip objekta iz kog se pokusava izvodjenje mora biti klasa! ", typeleft); 
            :}
                | EXTENDS error
                {: parser.ReportError("Doslo je do greske prilikom deklaracije prosirenja natklase"); :}
                | /* epsilon */
                ;
            
//METHOD VAR DECLARATION
MethodVarDeclListOpt ::= MethodVarDeclListOpt MethodVarDecl
                        | /* epsilon */
                        ;

MethodVarDecl ::= Type MethodIdentList SEMI ;
                
MethodIdentList ::= MethodIdentList COMMA Var
                    | Var
                    ;

//METHOD DECLARATION
MethodDeclOpt ::=   LBRACE MethodDeclListOpt RBRACE
                    | /*epsilon*/
                    ;

MethodDeclListOpt ::= MethodDeclListOpt MethodDecl
                    | /* epsilon */
                    ;

MethodDecl ::= StaticOpt:isStaticMethod TypeVoid:type IDENT:methodName LPAREN 
{:
    parser.MethodDeclaration(methodName, methodNameleft, type, typeleft, isStaticMethod);
:}
FormParamsOpt RPAREN MethodVarDeclListOpt LBRACE StatementListOpt RBRACE 
{: 
    parser.MethodEnding();
:};

StaticOpt ::= 
            STATIC 
            {: RESULT = true; :}
            | /*epsilon*/ 
            {: RESULT = false;:}
            ;

TypeVoid ::= Type: type
            {: RESULT = type; // = parser.lastType:}
            | VOID
            {: RESULT = parser.lastType = Tab.noType;:}
            ;

VarArgs ::= COMMA Type:type DOT DOT DOT IDENT:name
{:
    parser.lastType = new Struct(Struct.Array, parser.lastType);
    parser.VariableDeclaration(name, nameleft, Obj.Var);    
    parser.formalParamsCount++; 
:};

FormParamsOpt ::=   FormalParamList 
                    | FormalParamList VarArgs 
                    | VarArgs 
                    | error
                    {: parser.ReportError("Doslo je do greske prilikom deklaracije formalnog parametra funkcije pre znaka \")\""); :}
                    | /* epsilon */ 
                    ;

FormalParamList ::= FormalParamList COMMA FormalParamDecl 
                    | error COMMA FormalParamDecl {: parser.ReportError("Doslo je do greske prilikom deklaracije formalnog parametra funkcije pre znaka \",\""); :}
                    | FormalParamDecl;
                    

FormalParamDecl ::= Type IDENT:name LBRACK RBRACK 
{: 
    parser.lastType = new Struct(Struct.Array, parser.lastType);
    parser.VariableDeclaration(name, nameleft, Obj.Var);
    parser.formalParamsCount++; 
:}
                    | Type IDENT:name
{: 
    parser.VariableDeclaration(name, nameleft, Obj.Var);
    parser.formalParamsCount++; 
:}
                     ;

StatementListOpt ::= StatementListOpt Statement
                    | /* epsilon */
                    ;

Statement ::=   DesignatorStatement SEMI
                | StatementIfElse
                | FOR LPAREN DesignatorOpt SEMI CondOpt SEMI DesignatorOpt RPAREN {: EnteredFor(); :} Statement {: ExitedFor(); :}
                | BREAK SEMI:sem
                {: 
                if (IsNotInForLoop())
                        parser.report_error("Breakovati se moze samo iz unutar for petlje ", semleft);
                :}
                | CONTINUE SEMI:sem
                {:
                    if (IsNotInForLoop())
                        parser.report_error("Continue naredba se moze izvrsiti samo iz unutar for petlje ", semleft);
                :}
                | RETURN:ret SEMI
                {:
                    ReturnCallCheck(ret, retleft, null);
                :}
                | RETURN:ret Expression:expr SEMI
                {:
                    ReturnCallCheck(ret, retleft, expr);
                :}
                | READ LPAREN Designator:designator RPAREN SEMI
                {:
                    CorrectTypesForFunctionCalls(designator, designatorleft);
                :}
                | PRINT LPAREN Expression:expr NumOpt RPAREN SEMI
                {: 
                if (IsStructIntCharOrNone(expr, exprleft))
                {
                    parser.IncreaseFunctionCallsCount(); 
                }
                :}
                | LBRACE StatementListOpt RBRACE
                ;

StatementIfElse ::= IF LPAREN Condition RPAREN Statement 
                    | IF LPAREN Condition RPAREN Statement ELSE Statement 
                    | IF LPAREN error RPAREN Statement
                    {: parser.ReportError("Doslo je do greske u logickom izrazu unutar IF konstrukcije"); :}
                    | IF LPAREN error RPAREN Statement ELSE Statement 
                    {: parser.ReportError("Doslo je do greske u logickom izrazu unutar IF-ELSE konstrukcije"); :}
                    ;
                    
NumOpt ::=  COMMA NUMBER
            | /* epsilon */
            ;

DesignatorOpt ::= DesignatorStatement 
            | error
            {: parser.ReportError("Doslo je do greske unutar FOR(...) konstrukcije"); :}
            | /* epsilon */
            ;

CondOpt ::=  Condition
            | error
            {: parser.ReportError("Doslo je do greske u logickom iskazu unutar FOR(...) konstrukcije"); :}
            | /* epsilon */ 
            ;

DesignatorStatement ::= Designator:designator Assignop Expression:expr
                        {:
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if (!IsAssignable(designator, expr))
                                {
                                    parser.report_error("Nemoguce je dodeliti vrednost tipa "+StructToTypeName(expr) + "variabli tipa " +StructToTypeName(designator.getType()) , desigleft);
                                }
                            }
                        :}
                        | Designator LPAREN ActParsListOpt RPAREN
                        {: parser.IncreaseFunctionCallsCount() :}
                        | Designator:designator INC
                        {:  
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if(desig.getType().getKind() != Struct.Int)
                                {
                                    parser.report_error("Prilikom INC " + designator.getName() + " mora biti int ", designatorleft);
                                }
                            }
                        :}
                        | Designator:designator DEC
                        {:  
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if(desig.getType().getKind() != Struct.Int)
                                {
                                    parser.report_error("Prilikom INC " + designator.getName() + " mora biti int ", designatorleft);
                                }
                            }
                        :}
                        | Designator Assignop error 
                        {: parser.ReportError("Doslo je do prilikom dodele vrednosti pre znaka ;"); :}
                        ;

ActParsListOpt ::=  ActPars 
                    | /* epsilon */ 
                    ;

ActPars ::= ActPars COMMA Expression
            | Expression
            ;
            
Designator ::= IDENT DesignatorListOpt;

DesignatorListOpt ::= DesignatorListOpt DesignatorIdent
                 | /* epsilon */
                 ;

DesignatorIdent ::=  DOT IDENT
                | LBRACK Expression RBRACK
                ;
            

Condition ::=   Condition OR CondTerm
                | CondTerm
                ;
                          
CondTerm ::=    CondTerm AND CondFact
                | CondFact
                ;

CondFact ::=    Expression
                | Expression Relop Expression
                ;
    
                
Expression ::= SUB AddopTermCombList:result
            {: 
                RESULT = result;
                
                if (result.getKind() != Struct.Int)
                {
                     RESULT = Tab.noType;
                     parser.report_error("izraz nakon minusa mora biti tipa int", resultleft);
                }
            :}
            | AddopTermCombList:result
            {:
                RESULT = result;
            :}
            ;

AddopTermCombList ::=   AddopTermList:result  AddopRight  AddopTermCombList:term
                        {: 
                            RESULT = GetResultIfBothInt(result, resultleft, term);
                        :}
                        | AddopTermList:result
                        {:
                            RESULT = result.getType()
                        :}
                        ;

AddopTermList ::=   AddopTermList:result AddopLeft Term:term
                    {:
                        RESULT = Tab.noType;
                        Struct res = GetResultIfBothInt(result, resultleft, term);
                        
                        if (res != Tab.noType)
                        {
                            RESULT = new Obj(Obj.Con, "Addition result", Tab.intType); 
                        }
                    :}
                    | Term:result
                    {: RESULT = result; :}
                    ;

Term ::=    MulopFactorList:result  MulopRight Term:term
            {:
                RESULT = GetResultIfBothInt(result, resultleft, term);
            :}
            | MulopFactorList:result
            {: RESULT = result; :}
            ;

MulopFactorList ::= MulopFactorList:result MulopLeft Factor:fact
                    {:
                        RESULT = Tab.noType;
                        Struct res = GetResultIfBothInt(result, resultleft, fact.getType());
                        
                        if (res != Tab.noType)
                        {
                            RESULT = new Obj(Obj.Con, "Multiplication result", Tab.intType); 
                        }  
                    :}
                    | Factor:result
                    {: RESULT = result :}
                    ;

Factor ::=  Designator:designator
            {: RESULT = designator; :}
            | Designator:designator  LPAREN ActParsListOpt RPAREN
            {:
                parser.IncreaseFunctionCallsCount();
                if (designator.getKind() != Obj.Meth)
                { 
                    parser.report_error("Funkcija nije deklarisana",designatorleft);
                    RESULT = Tab.noObj;
                }
                else
                {
                    RESULT = new Obj(Obj.Meth, 
                        designator.getName(), 
                        new Struct(designator.getType().getKind()), 
                        designator.getAdr(), 
                        designator.getLevel());   
                }
            :}
            | NUMBER:number
            {: RESULT = new Obj(Obj.Con, "" + numumber, Tab.intType); :}
            | CHAR:char
            {: RESULT = new Obj(Obj.Con, "" + char, Tab.charType); :}
            | BOOL:bool
            {: RESULT = new Obj(Obj.Con, "" + bool, Tab.intType); :}
            | NEW Type
            | NEW Type:type LBRACK Expression:expr RBRACK
            {:
                if (expr.getKind() != Struct.Int)
                {
                    parser.report_error("Velicina niza mora biti int", exprleft);
                    RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                }
                else
                {
                    RESULT = new Obj(Obj.NO_VALUE, "", new Struct(Struct.Array, type));
                }
            :}
            | LPAREN Expression:expr RPAREN
            {: RESULT = new Obj(Obj.Con, "", expr); :}
            ;
            
Assignop ::= ASSIGN 
            | AddopRight
            | MulopRight
            ;

Relop ::=   EQUAL
            | NOT_EQUAL
            | GREATER
            | GREATER_EQUAL 
            | LESS
            | LESS_EQUAL
            ;

Addop ::=   AddopLeft 
            | AddopRight 
            ;

AddopLeft ::=   ADD 
                | SUB 
                ;

AddopRight ::=  ASSIGN_ADD 
                | ASSIGN_SUB 
                ;

Mulop ::=   MulopLeft 
            | MulopRight 
            ;

MulopLeft ::=   MUL 
                | DIV 
                | MOD 
                ;

MulopRight ::=  ASSIGN_MUL 
                | ASSIGN_DIV 
                | ASSIGN_MOD 
                ;