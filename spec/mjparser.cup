package rs.ac.bg.etf.pp1;
import rs.etf.pp1.mj.runtime.Code;
import java_cup.runtime.*;
import org.apache.log4j.*;
import java.util.*;
import java.util.stream.IntStream;
import rs.ac.bg.etf.pp1.util.ScopeEngine;
import rs.ac.bg.etf.pp1.util.EntityCounters;
import rs.ac.bg.etf.pp1.util.UtilFunctions;
import rs.ac.bg.etf.pp1.util.SCOPE;

// import java.io.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;

parser code {:

    Struct lastMethType = null;
    Struct lastType = null; // unneeded can get from up
    Obj lastClass = null;
    Obj lastMethod = null;
    Obj extendedClass = null;
    String curTypeName = "";
    
    boolean returnHappend = false;
    boolean errorEncountered = false;
    boolean errorHandled = false;
    
    void ReportError(String errorMessage)
    {
        errorEncountered = true;
        log.debug(errorMessage);
    }
    
    void ReportVarDeclError(char errorChar)
    {
        if (ScopeEngine.IsInGlobalScope())
        {
        	ReportError("Doslo je do greske prilikom deklaracije globalne promenljive pre znaka \""+errorChar + '\"');
            return;
        }
        if (ScopeEngine.IsInClassScope())
        {
        	ReportError("Doslo je do greske prilikom definicije lokalne promenljive unutrasnje klase pre znaka \"" +errorChar+ '\"');
            return;
        }
    }
    
    boolean CorrectNameAndType(String name, Struct type)
    {
        
        if( Tab.currentScope.findSymbol(name) != null)
        {
             report_error(" " + name + " je vec deklarisano " ,null );
             return false;
        }
        
        if (type == null || type == Tab.noType)
        {
            report_error("Greska u tipu pri deklaraciji ", null);
            return false; 
        }
        
        return true;
    }
    
    void VariableDeclaration(String name, int nameLocation, int objectKind, Struct lastType, 
        Obj assignedType, int assignLocation)
    {
    	if (!CorrectNameAndType(name, lastType))
    	{
    		return;
    	}
    	
        if(assignedType != null && assignedType.getType() != lastType)
        {
            report_error("neispravan tip promenljive koja se dodeljuje "+ UtilFunctions.StructToTypeName(lastType) +" = "+ UtilFunctions.StructToTypeName(assignedType.getType()) +"("+assignLocation+")",null );
            return;
        }
        
        Obj obj = Tab.insert(objectKind, name, lastType);
        if (assignedType!=null) obj.setAdr(assignedType.getAdr());
        report_info("Definisana promenljiva " + name + " tipa: "+UtilFunctions.StructToTypeName(lastType)+ " na liniji "+nameLocation, null);
    }

    // Overloading
    void VariableDeclaration(String name, int nameLocation, int objectType, Struct lastt)
    {
        VariableDeclaration(name, nameLocation, objectType, lastt, null, 0);
    }
    
    void ClassDeclaration(String className, int classLocation)
    {
        if(Tab.currentScope.findSymbol(className) != null)
        {
            report_error("Klasa sa imenom " + className + "je vec deklarisana ("+classLocation +")", null);
            return;
        }
        
        lastClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
        ScopeEngine.InScope(SCOPE.CLASS_SCOPE);
        Tab.openScope();
       	EntityCounters.IncreaseClassCount();
        
        report_info("Definisana klasa " + className + " na liniji "+classLocation,null );
    }
    
    void ClassEnding()
    {
        if(extendedClass != null) {
            for (Obj obj : extendedClass.getType().getMembers()) {
                if(Tab.currentScope.findSymbol(obj.getName()) == null)
                      Tab.insert(obj.getKind(), obj.getName(), obj.getType());
                }
       }   
       extendedClass = null;
       
        // if (!nestedScopes.empty() && nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
        	ScopeEngine.OutOfCurrentScope();
            Tab.chainLocalSymbols(lastClass.getType());
            Tab.closeScope();
            lastClass = null;
        }          
    }
    
    void MethodDeclaration(String methodName, int methodLocation, Struct type, int typeLocation, boolean isStaticMethod)
    {
        if(Tab.currentScope.findSymbol(methodName) != null)
        {
              report_error("Naziv metode "+methodName + "je vec u upotrebi ("+methodLocation+")", null);
              return;
        }
        
        if(extendedClass != null) 
        {
           for (Obj o : extendedClass.getType().getMembers()) 
           {
               if(o.getKind() == Obj.Meth && o.getName().equals(methodName)) 
               if(o.getType().getElemType().getKind() == 6) 
                   {
                   // error
                   return;
                   }
          }
        }
        if (methodName.equals("main"))
        {
            if(type != Tab.noType)
            {
                report_error("Main mora biti tipa \"void\" ("+typeLocation + ")",null);
                return;
            }
            if (isStaticMethod)
            {
                report_error("Main ne sme biti staticka metoda ("+methodLocation+")",null);
                return;
            }

            ScopeEngine.InScope(SCOPE.MAIN_SCOPE);
            InsertMethod(methodName, methodLocation, type.getKind());
            Tab.openScope();
            lastMethType = type;
            return;
        } 
        
       if(isStaticMethod) 
       {
           InsertMethod(methodName, methodLocation, 6);
       }
       else 
       {
           InsertMethod(methodName, methodLocation, type.getKind());
       }
       
       lastMethType = type;
       ScopeEngine.InScope(SCOPE.METHOD_SCOPE);
       Tab.openScope();
    }
    
    void InsertMethod(String methodName, int methodLocation, int methodType)
    {
           if (methodType == 6 ) EntityCounters.IncreaseStaticFunctionCount();
           else EntityCounters.IncreaseFunctionCount();
           // lastType.setElementType(new Struct(methodType));
           
           Struct methType = new Struct(lastType.getKind());
           methType.setElementType(new Struct(methodType));
           
           lastMethod = Tab.insert(Obj.Meth, methodName, methType);
           report_info("Ubacena metoda "+methodName+" u tabelu simbola na liniji "+ methodLocation,null );
    }
    
    void MethodEnding()
    {
        // if (!nestedScopes.empty() &&
        // nestedScopes.peek() == SCOPE.METHOD_SCOPE ||
        // nestedScopes.peek() == SCOPE.MAIN_SCOPE || 
        // nestedScopes.peek() == SCOPE.CLASS_METHOD_SCOPE)
        {
            HandleScopeEnd(lastMethod);
            lastMethod = null;
            lastMethType = null;
        }
    }
    
    void HandleScopeEnd(Obj scopeName)
    {
    	ScopeEngine.OutOfCurrentScope();
        Tab.chainLocalSymbols(scopeName);
        Tab.closeScope();
    }

    void HandleProgramEnd(Obj progName, int programLocation)
    {
        if(Tab.find("main") == Tab.noObj)
        {
            report_error("Metoda \"main\" nije pronadjena! ("+programLocation+")", null);
        }
        
        HandleScopeEnd(progName);
    }
    
    Struct CheckTypeAndUpdateLastType(String typeName, int nameLocation)
    {
        Obj typeNode = Tab.find(typeName);
        
        if (Obj.Type == typeNode.getKind()) 
        {
        	/* if (typeName="int")
        	{
                if (typeNode.getType().getElemType()== null)
                    return lastType = typeNode.getType();
                else 
                	return lastType = typeNode.getType().getElemType();
        	}*/
        	
             curTypeName = typeName;
             return lastType = typeNode.getType();
        }
        
        lastType = Tab.noType;
        if (typeNode == Tab.noObj) 
        {
            report_error("U tabeli simbola nije pronadjen tip " + typeName + " referenciran na lokaciji "+nameLocation, null);            
            return Tab.noType;
        }
        
        report_error(" ime " + typeName + " ne predstavlja tip "+nameLocation, null);
        return Tab.noType;
    }

    Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null) 
        log.info(s.toString() + " " + s.value.toString());
    return s;
:}

init with {:
    Tab.init(); // Universe scope
    Tab.currentScope.addToLocals(new Obj(Obj.Type, "bool",CUP$MJParser$actions.boolType));
:}

action code {:
int numberOfNestedFors = 0;
boolean isThisSpecified = false;
Obj backupDesig = null;
public static final int STATIC = 6;
public static final int Bool = 5;
public static final Struct boolType = new Struct(Struct.Bool);
boolean varArgs = false;
Obj lastDesignator = null;

Collection<Obj> classFields = null;
List<Struct> actParams= new LinkedList<Struct>();
    
    Stack<Integer> forStack = new Stack<Integer>();
    Stack<Integer> cond = new Stack<Integer>();
    Stack<Integer> andAdr = new Stack<Integer>();    
    Stack<Integer> orAdr = new Stack<Integer>();     
    Stack<Integer> endAdr = new Stack<Integer>();
    Stack<Integer> forAdr = new Stack<Integer>();
    Stack<Integer> endFor = new Stack<Integer>();
    Stack<Integer> noCond = new Stack<Integer>();
    Stack<Integer> desi = new Stack<Integer>();
    
    public void EnteredFor()
    {
        ++numberOfNestedFors;
    }
    public void ExitedFor()
    {
        --numberOfNestedFors;
    }
    public boolean IsNotInForLoop()
    {
        return numberOfNestedFors == 0;
    }
    
    void ReturnCallCheck(int returnLocation, Struct expr)
    {
       parser.returnHappend = true;
        
        if(parser.lastMethod == null )
        {
            parser.report_error("Return mora biti iz funkcije pozvan ("+returnLocation+")", null);
            return;
        }
        
        if (parser.lastMethType == Tab.noType)
        {
            parser.report_error("Return mora biti iz funkcije pozvan ("+returnLocation+")", null);
            return;
        }

        if (expr != null && expr.getKind() != parser.lastMethType.getKind())
        {
            parser.report_error("Funkcija vraca tip "+ UtilFunctions.StructToTypeName(expr) +" A mora vracati tip "+ 
            		UtilFunctions.StructToTypeName(parser.lastMethod.getType()) + "("+returnLocation+")", null);
        }
    }
    
int [] correctObjTypes = {Obj.Var, Obj.Elem, Obj.Fld };
int [] correctStructTypes = {Struct.Int, Struct.Char, Struct.None};
    
    public boolean IsObjectVarElemOrFieldError(Obj designator, int designatorLocation)
    {
        if (designator == null)
            return false;
        if (!IntStream.of(correctObjTypes).anyMatch(x -> x == designator.getKind()))
        {
            parser.report_error(" " + designator.getName() + 
            " mora biti  promenljiva, element niza ili polje unutar objekta ("+ designatorLocation+")", null);
            return false;
        }
        return true;
    }
    
    public boolean IsStructIntCharOrNone(Struct expr, int exprLocation)
    {
        if (!IntStream.of(correctStructTypes).anyMatch(x -> x == expr.getKind()))
        {       
            parser.report_error(" " + expr.getKind() + " mora biti tipa int, char ili bool. ("+exprLocation+")", null);                
            return false;
        }
        return true;
    }
    
    public void CorrectTypesForFunctionCalls(Obj designator, int designatorLocation)
    {
        if (IsObjectVarElemOrFieldError(designator, designatorLocation) &&
            IsStructIntCharOrNone(designator.getType(), designatorLocation))
         {
        	EntityCounters.IncreaseFunctionCallsCount(); 
         }
    }
    
    public boolean IsAssignable(Obj design, Struct expr)
    {
        if(expr.assignableTo(design.getType())) // If expr is assignable to design
        {
            return true;
        }
        
        if( expr.getKind() == design.getType().getKind() || // If they are not same Struct type
            expr.getElemType() != design.getType().getElemType() || // If they are not same Struct.ElementType
            expr.getNumberOfFields() != design.getType().getNumberOfFields() || // If they don't have same params of fields
            expr.getMembers() == design.getType().getMembers()) // If they don't have same type of fields
        {
            return false;
        }
  /*
        if (design.getType().getKind() == Struct.Array && // If designator is Struct.Array
            expr.getElemType() == null && // Expression is not array
            !expr.assignableTo(design.getType().getElemType())) // if expr is assignable to type of designator elements
        {
            return false;
        }
     */   
        return true;
    }
    
    Obj GetResultIfBothInt(Obj result, int resultLocation, Struct term)
    {
        /*if (!IsObjectVarElemOrFieldError(result , resultLocation))
        {
            return Tab.noObj;
        }*/
        
        if (result.getType().getKind() == Struct.Int && term.getKind() == Struct.Int)
        {
            return result;
        }
        
       parser.report_error("Poslali ste tipove" + UtilFunctions.StructToTypeName(parser.lastMethod.getType()) +
            " i " + UtilFunctions.StructToTypeName(term) + " a moraju biti int ("+resultLocation+")", null);
        return Tab.noObj;
    }
    
    void SaveExtendedClassMembers(Struct extendsClass)
    {
        if(extendsClass != null && extendsClass != Tab.noType && extendsClass.getKind() == Struct.Class) 
        {
            for (Obj obj : extendsClass.getMembers()) 
            {
                if(Tab.currentScope.findSymbol(obj.getName()) == null)
                      Tab.insert(obj.getKind(), obj.getName(), obj.getType());
            }
        }
    }
    
    boolean CheckIfArgumentsMatch(Obj designator, int designatorLocation, int args, int argsLocation)
    {
        if(designator.getKind() != Obj.Meth)
        {
              parser.report_error("Funkcija mora biti deklarisana pre poziva ("+designatorLocation+")", null);
              return false;
        }  
                                
        if(args != designator.getLevel()) 
        {
                parser.report_error(" Broj argumenata funkcije nije dobar."+ designator.getName() +" ("+argsLocation+")", null);
                return false;
        }
        
        for(int i = 0; i < args; i++) 
        {
             Obj o = ((Obj) designator.getLocalSymbols().toArray()[i]);
             Struct s = actParams.get(actParams.size() - (args - i)); // sta ce aoba
             if(!o.getType().compatibleWith(s))
                if(!(o.getType().getKind() != Struct.Class && o.getType().getKind() == s.getKind() && o.getType().getElemType() == s.getElemType() && o.getType().getNumberOfFields() == s.getNumberOfFields()))
             //if (!o.getType().compatibleWith(s) && !IsAssignable(o,s)) 
             {
                 parser.report_error(" _Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva. ("+argsLocation+")", null);
                 return false;
             }
        }
        EntityCounters.IncreaseFunctionCallsCount();
        return true;
    }
    
    public boolean ThisIsSpecified(String name, int nameLocation)
    {
        if(!"this".equals(name)) return false;
     
        if(parser.lastMethod != null) 
        {
          if(!ScopeEngine.IsInClassScope() || parser.lastMethod.getType().getElemType().getKind() == STATIC)
          {
               parser.report_error("This se moze navoditi samo u nestatickim metodama ("+nameLocation+")", null);
          }
          
          isThisSpecified = true;
       } 
       return true;
    }                       
:}

terminal BREAK, CLASS, CONST, CONTINUE, ELSE, EXTENDS, FOR, IF, NEW, PRINT, PROG, READ, RETURN, STATIC, VOID;
terminal LBRACE, RBRACE, LBRACK, RBRACK, LPAREN, RPAREN;
terminal ADD, SUB, MUL, DIV, MOD;
terminal ASSIGN, ASSIGN_ADD, ASSIGN_SUB, ASSIGN_MUL, ASSIGN_DIV, ASSIGN_MOD;
terminal EQUAL, NOT_EQUAL, GREATER_EQUAL, LESS_EQUAL, GREATER, LESS;
terminal DEC, INC, OR, AND;
terminal SEMI, COMMA, DOT;
terminal Integer NUMBER;
terminal char CHAR;
terminal Boolean BOOL;
terminal String IDENT;


non terminal ClassDecl, ClassVarDecl, ClassVarDeclListOpt;
non terminal MethodDecl, MethodDeclOpt, MethodDeclListOpt, MethodVarDecl, MethodVarDeclListOpt, MethodIdentList;
non terminal DesignatorOpt, DesignatorStatement;
non terminal Addop, AddopLeft; 
non terminal Integer MulopRight, Mulop, Assignop, Relop, AddopRight, MulopLeft;       
non terminal VarArgs, VarDecl, VarDeclList, Var;
non terminal ConstIdent, ConstDecl, ConstDeclList;
non terminal FormalParamDecl;
non terminal Statement, StatementListOpt, StatementIfElse;
non terminal Condition, CondTerm, CondFact, CondOpt;

non terminal Decl, DeclListOpt;
non terminal Integer NumOpt;
non terminal AssignopError;
non terminal Program;

non terminal Obj ProgramName, Const, Designator, AddopTermList, MulopFactorList, Term, Factor, DesignatorListOpt, DesignatorIdent;
non terminal Boolean StaticOpt;
non terminal Struct Type, TypeVoid, Expression, AddopTermCombList, ExtendsOpt;
non terminal Integer ActParsListOpt, FormParamsOpt, FormalParamList, ActPars;

precedence left ELSE;

Program ::= PROG ProgramName:progName DeclListOpt LBRACE MethodDeclListOpt RBRACE
{:
    Code.dataSize = Tab.currentScope().getnVars();
    parser.HandleProgramEnd(progName, progNameleft);
:};

ProgramName ::= IDENT:progName
{:
    RESULT = Tab.insert(Obj.Prog, progName, Tab.noType);
    Tab.openScope();
    
:};

DeclListOpt ::= DeclListOpt Decl
                | /* epsilon */ 
                ;


Decl ::=    ClassDecl 
            | ConstDecl 
            | VarDecl 
            ;

//CONST DECLARATION
ConstDecl ::= CONST Type ConstDeclList SEMI;

ConstDeclList ::=   ConstDeclList COMMA ConstIdent
                    | ConstIdent
                    ;
                    
                
ConstIdent ::= IDENT:name ASSIGN Const:type
{: 
    parser.VariableDeclaration(name, nameleft, Obj.Con, parser.lastType, type, typeleft);
	EntityCounters.IncreaseConstVariableCount();
:}
;

Const ::=   BOOL:booll  
	{:
	Obj obj= new Obj(Obj.Con, "", boolType); 
obj.setAdr(booll?1:0); 
	RESULT = obj;
:}
            | CHAR:charr {:
            	Obj obj = new Obj(Obj.Con, "", Tab.charType); 
	obj.setAdr(charr); 
	RESULT=obj;
	:}
            | NUMBER:numberr {: Obj obj = new Obj(Obj.Con, "", Tab.intType); 
	obj.setAdr((int)numberr);
	RESULT=obj; :}
            ;

//VAR DECLARATION
VarDecl ::= Type VarDeclList SEMI
            | Type error SEMI
            {: parser.ReportVarDeclError(';'); :}
            ;

VarDeclList ::= VarDeclList COMMA Var
                | error COMMA Var
                {: parser.ReportVarDeclError(','); :}
                | Var 
                ;

Var ::= IDENT:name LBRACK RBRACK  
        {: 
            parser.VariableDeclaration(name, nameleft, Obj.Var, new Struct(Struct.Array, parser.lastType));
			EntityCounters.IncreaseVariableCount();
        :}
        | IDENT:name {: parser.VariableDeclaration(name, nameleft, Obj.Var, parser.lastType); EntityCounters.IncreaseVariableCount(); :}
        ;

Type ::= IDENT:name
        {:
            RESULT = parser.CheckTypeAndUpdateLastType(name, nameleft);
        :}
        ;

//CLASS VAR DECLARATION
ClassVarDeclListOpt ::= ClassVarDeclListOpt ClassVarDecl
                        | /*epsilon*/
                        ;

ClassVarDecl ::=    STATIC VarDecl
                    | VarDecl
                    ;

//CLASS DECLARATION
ClassDecl ::= CLASS IDENT:className ExtendsOpt:extendsClass LBRACE
{: 
    parser.ClassDeclaration(className, classNameleft);
:}

 			ClassVarDeclListOpt MethodDeclOpt RBRACE
{:  
    SaveExtendedClassMembers(extendsClass);
    parser.ClassEnding();
:};


ExtendsOpt ::=  EXTENDS Type:type 
                {: 
                    if(!(type.getKind() == Struct.Class))
                        parser.report_error(" Tip objekta iz kog se pokusava izvodjenje mora biti klasa! ", typeleft);
                    else 
                        parser.extendedClass = Tab.find(parser.curTypeName);
                    RESULT = type;
                :}
                | EXTENDS error
                {:
                    parser.ReportError("Doslo je do greske prilikom deklaracije prosirenja natklase"); 
                    RESULT = Tab.noType;
                :}
                | /* epsilon */
                ;
            
//METHOD VAR DECLARATION
MethodVarDeclListOpt ::= MethodVarDeclListOpt MethodVarDecl
                        | /* epsilon */
                        ;

MethodVarDecl ::= Type MethodIdentList SEMI ;
                
MethodIdentList ::= MethodIdentList COMMA Var
                    | Var
                    ;

//METHOD DECLARATION
MethodDeclOpt ::=   LBRACE MethodDeclListOpt RBRACE
                    | /*epsilon*/
                    ;

MethodDeclListOpt ::= MethodDeclListOpt MethodDecl
                    | /* epsilon */
                    ;

MethodDecl ::= StaticOpt:isStaticMethod TypeVoid:type IDENT:methodName
                {:
                    parser.MethodDeclaration(methodName, methodNameleft, type, typeleft, isStaticMethod);
                :}
LPAREN FormParamsOpt:numOfParams RPAREN MethodVarDeclListOpt LBRACE
{:
	parser.lastMethod.setAdr(Code.pc);
	if ("main".equals(parser.lastMethod.getName()))
	{
		Code.mainPc = Code.pc;
	}    
    parser.lastMethod.setLevel(numOfParams);
	Code.put(Code.enter);
	Code.put(parser.lastMethod.getLevel());
	Code.put(Tab.currentScope.getnVars());
:}
StatementListOpt RBRACE 
{: 
    if (numOfParams == null) numOfParams = 0;
    
    if (methodName.equals("main") &&  numOfParams >0)
    {
        parser.report_error("Main ne sme imati argumente!", numOfParamsleft);
    }

    
    if (!parser.returnHappend && type != Tab.noType)
    {
        parser.report_error("Fali vam povratna vrednost funkcije!",null);
    }

    Code.put(Code.exit);
    Code.put(Code.return_);
    
    parser.MethodEnding();
    parser.returnHappend = false;
:};

StaticOpt ::= 
            STATIC 
            {: RESULT = true; :}
            | /*epsilon*/ 
            {: RESULT = false;:}
            ;

TypeVoid ::= Type: type
            {: RESULT = type; // = parser.lastType:}
            | VOID
            {: RESULT = parser.lastType = Tab.noType;:}
            ;

VarArgs ::= COMMA Type:type DOT DOT DOT IDENT:name
            {:
                parser.lastType = new Struct(Struct.Array, parser.lastType);
                parser.VariableDeclaration(name, nameleft, Obj.Var, parser.lastType);    
                EntityCounters.IncreaseFormalParamsCount();
            :};

FormParamsOpt ::=   FormalParamList:result
                    {: RESULT = result; :}
                    | FormalParamList:numOfParams VarArgs
                    {: RESULT = numOfParams+1; :}
                    | VarArgs 
                    {: RESULT = 1; :}
                    | error
                    {: parser.ReportError("Doslo je do greske prilikom deklaracije formalnog parametra funkcije pre znaka \")\""); :}
                    | /* epsilon */ 
                    {: RESULT = 0; :}
                    ;

FormalParamList ::= FormalParamList:numberOfParams COMMA FormalParamDecl
                    {: RESULT = numberOfParams + 1; :}
                    | error COMMA FormalParamDecl 
                    {: parser.ReportError("Doslo je do greske prilikom deklaracije formalnog parametra funkcije pre znaka \",\""); :}
                    | FormalParamDecl
                    {: RESULT = 1; :}
                    ;

FormalParamDecl ::= Type IDENT:name LBRACK RBRACK 
                    {: 
                        parser.VariableDeclaration(name, nameleft, Obj.Var, new Struct(Struct.Array, parser.lastType));
                        EntityCounters.IncreaseFormalParamsCount(); 
                    :}
                    | Type IDENT:name
                    {: 
                        parser.VariableDeclaration(name, nameleft, Obj.Var, parser.lastType);
                        EntityCounters.IncreaseFormalParamsCount();
                    :}
                     ;

StatementListOpt ::= StatementListOpt Statement
                    | /* epsilon */
                    ;

Statement ::=   DesignatorStatement SEMI
                | StatementIfElse
                | FOR LPAREN DesignatorOpt SEMI 
                {:
                    cond.push(Code.pc);
                :}
                CondOpt
                {:
                    Code.putJump(0);
                    forAdr.push(Code.pc - 2);
                    
                    if(endAdr.peek() != -1) 
                        endFor.push(endAdr.peek()); 
                    else {
                        Code.putJump(0);
                        noCond.push(Code.pc - 2);
                        endFor.push(noCond.peek());
                    }
                :}
                SEMI 
                {:
                    desi.push(Code.pc);
                :}
                DesignatorOpt
                {: 
                    Code.putJump(cond.pop());
                :}
                RPAREN
                {: 
                    forStack.push(1); 
                    Code.fixup(forAdr.pop());
                    EnteredFor();
                :}
                Statement
                {: 
                    
                    forStack.pop();
                    Code.putJump(desi.pop());
                    if(endAdr.peek() != -1)
                        Code.fixup(endAdr.pop());
                    else {
                        Code.fixup(noCond.pop());
                        endAdr.pop();
                    }
                    ExitedFor();
                :}
                | BREAK SEMI:sem
                {: 
                if (IsNotInForLoop())
                        parser.report_error("Breakovati se moze samo iz unutar for petlje ", semleft);
                    else
                        Code.putJump(endFor.pop() - 1);
                :}
                | CONTINUE SEMI:sem
                {:
                    if (IsNotInForLoop())
                        parser.report_error("Continue naredba se moze izvrsiti samo iz unutar for petlje ", semleft);
                    else
                        Code.putJump(desi.peek());
                :}
                | RETURN:ret SEMI
                {:
                    ReturnCallCheck(retleft, null);
                :}
                | RETURN:ret Expression:expr SEMI
                {:
                    ReturnCallCheck(retleft, expr);
                :}
                | READ LPAREN Designator:designator RPAREN SEMI
                {:
                    CorrectTypesForFunctionCalls(designator, designatorleft);
                    if (designator.getType() == Tab.charType ) 
                        Code.put(Code.bread);           
                     else
                        Code.put(Code.read);
                    Code.store(designator);
                :}
                | PRINT LPAREN Expression:expr NumOpt:width RPAREN SEMI
                {: 
                if (IsStructIntCharOrNone(expr, exprleft))
                {
                	EntityCounters.IncreaseFunctionCallsCount(); 
                     if (expr.getKind() == Struct.Char ) {
                    Code.loadConst(width);
                    Code.put(Code.bprint);
                 }
                 
                 else{
                    Code.loadConst(width);
                    Code.put(Code.print);
                 }
                }
                :}
                | LBRACE StatementListOpt RBRACE
                ;

StatementIfElse ::= IF LPAREN Condition RPAREN Statement 
                {: 
                    Code.fixup(endAdr.pop());
                :}
                |
                IF LPAREN Condition RPAREN Statement ELSE 
                {:
                    Code.pc += 3; 
                    Code.fixup(endAdr.pop());
                    Code.pc -= 3;
                    
                    Code.putJump(0); // dummy
                    endAdr.push(Code.pc - 2);
                :}
                Statement 
                {: 
                    Code.fixup(endAdr.pop());
                :}
                    | IF LPAREN error RPAREN Statement
                    {: parser.ReportError("Doslo je do greske u logickom izrazu unutar IF konstrukcije"); :}
                    | IF LPAREN error RPAREN Statement ELSE Statement 
                    {: parser.ReportError("Doslo je do greske u logickom izrazu unutar IF-ELSE konstrukcije"); :}
                    ;
                    
NumOpt ::=  COMMA NUMBER:width
            {: RESULT = width; :}
            | /* epsilon */
            {: RESULT = 5; :}
            ;

DesignatorOpt ::= DesignatorStatement 
            | error
            {: parser.ReportError("Doslo je do greske unutar FOR(...) konstrukcije"); :}
            | /* epsilon */
            ;

CondOpt ::=  Condition
            | error
            {: parser.ReportError("Doslo je do greske u logickom iskazu unutar FOR(...) konstrukcije"); :}
            | /* epsilon */ 
            {: endAdr.push(-1); :}
            ;

DesignatorStatement ::=Designator:desig Assignop :op
                        {:
                        if((int)op != 0) { 
                                if(desig.getKind() == Obj.Elem)
                                    Code.put(Code.dup2);
                                Code.load(desig); 
                            }
                        
                        :}
                        Expression:expr
                        {:
                            if (IsObjectVarElemOrFieldError(desig, desigleft))
                            {
                                boolean comp = true;
                                if(!expr.assignableTo(desig.getType())) {
                                
                                    if(expr.getKind() != desig.getType().getKind())
                                        parser.report_error(""+expr.getKind() +" != " +desig.getType().getKind()+"expr.getKind() != desig.getType().getKind()", desigleft); 
                                    if (desig.getType().getElemType() == null)
                                    {
                                        if (expr.getElemType() != desig.getType().getElemType()) parser.report_error(""+expr.getElemType() +" != "+ desig.getType().getElemType()+ " . expr.getElemType() != desig.getType().getElemType()", desigleft);
                                    
                                    }else  if(expr.getElemType() != desig.getType().getElemType().getElemType())
                                    {
                                    	 parser.report_error(""+expr.getElemType() +" != "+ desig.getType().getElemType()+ " .. expr.getElemType() != desig.getType().getElemType()", desigleft);
                                    }
                                    
                                    if (expr.getNumberOfFields() != desig.getType().getNumberOfFields())
                                        parser.report_error(" expr.getNumberOfFields() != desig.getType().getNumberOfFields()", desigleft);
                                    if (expr.getMembers() == desig.getType().getMembers())
                                        parser.report_error("expr.getMembers() == desig.getType().getMembers()", desigleft);
                                    if(desig.getType().getKind() == Struct.Array && expr.getElemType() == null)
                                        if(!expr.assignableTo(desig.getType().getElemType()))
                                            comp = false;
                                }
                                if(!comp)
                                    parser.report_error(" nekompatibilni tipovi u dodeli vrednosti", desigleft);
                            }
                            if((int)op != 0) 
                                Code.put((int)op); 
                            
                            Code.store(desig);
                            /*
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if (!IsAssignable(designator, expr))
                                {
                                    parser.report_error("Nemoguce je dodeliti vrednost tipa "+parser.StructToTypeName(expr) + " variabli tipa " +parser.StructToTypeName(designator.getType())+"("+designatorleft+")" ,null );
                                }
                            }*/
                        :}
                        | Designator:designator LPAREN ActParsListOpt:args RPAREN
                        {:
                            //CheckIfArgumentsMatch(designator, designatorleft, args, argsleft);
                            if(designator != Tab.noObj) {
                            if((!varArgs && args == designator.getLevel())||(varArgs && args > designator.getLevel())) {
                                boolean flag = true;
                                Obj o=null;
                                for(int i = 0; i < args; i++) {
                                    if(i<designator.getLevel()) o = ((Obj) designator.getLocalSymbols().toArray()[i]);
                                    Struct s = actParams.get(actParams.size() - (args - i));
                                    if(!o.getType().compatibleWith(s))
                                        if(!(o.getType().getKind() != Struct.Class && o.getType().getKind() == s.getKind() && o.getType().getElemType() == s.getElemType() && o.getType().getNumberOfFields() == s.getNumberOfFields()))
                                            flag = false;
                                }
                                
                                if(!flag)
                                    parser.report_error(" Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva.", argsleft);
                                else{
                                int destAdr = designator.getAdr() - Code.pc;
                                Code.put(Code.call);
                                Code.put2(destAdr);
                                if(designator.getType().getKind() != Struct.None)
                                Code.put(Code.pop);
                                }
                            } else {
                                parser.report_error(" Broj argumenata funkcije nije dobar."+ designator.getName(), argsleft);                     
                            }
                            
                            for (int i =0; i < args ; i++)
                                actParams.remove(actParams.size() - 1);
                                }
                        :}
                        | Designator:designator INC
                        {:  
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if(designator.getType().getKind() != Struct.Int)
                                {
                                    parser.report_error("Prilikom INC " + designator.getName() + " mora biti int ", designatorleft);
                                }else
                                {
                                if(designator.getKind() == Obj.Elem)
                                Code.put(Code.dup2);
                            Code.load(designator);
                            Code.put(Code.const_1);
                            Code.put(Code.add);
                            Code.store(designator);
                                }
                            }
                        :}
                        | Designator:designator DEC
                        {:  
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if(designator.getType().getKind() != Struct.Int)
                                {
                                    parser.report_error("Prilikom INC " + designator.getName() + " mora biti int ", designatorleft);
                                }
                                else
                                {
                                 if(designator.getKind() == Obj.Elem)
                                Code.put(Code.dup2);
                                    Code.load(designator);
                                    Code.put(Code.const_1);
                                    Code.put(Code.sub);
                                    Code.store(designator);
                                }
                            }
                        :}
                        | Designator Assignop error 
                        {: parser.ReportError("Doslo je do prilikom dodele vrednosti pre znaka ;"); :}
                        ;

ActParsListOpt ::=  ActPars:args
                    {: RESULT = args; :} 
                    | /* epsilon */ 
                    {: RESULT = 0; :}
                    ;

ActPars ::= ActPars:args COMMA Expression:expr
            {:
                actParams.add(expr);
                RESULT = args+1;
            :}
            | Expression:expr
            {:
                actParams.add(expr);
                RESULT = 1;
            :}
            ;
            
Designator ::= IDENT:name 
                {:
                  if(name.equals("this")) {
                    if(parser.lastMethod != null) {
                        if(ScopeEngine.IsInGlobalScope() || !ScopeEngine.IsInClassMethodScope() ||
                        parser.lastMethod.getType().getElemType().getKind() == STATIC)
                        {
                         parser.report_error("this moze postojati samo u nestatickim metodama", nameleft);
                         }
                            isThisSpecified = true;
                    }
                  } else {
                    Obj o = Tab.currentScope.findSymbol(name);
                    if(o == null) {
                        Obj o1 = Tab.find(name);
                        if(o1 != Tab.noObj) {
                            if(o1.getType().getKind() == Struct.Array)
                                lastDesignator = o1;
                    }
                    else {
                            Obj found = null;
                            if(parser.extendedClass != null) {
                                for (Obj o2 : parser.extendedClass.getType().getMembers()) {
                                    if(o2.getName().equals(name))
                                        found = o2;
                                }
                            }
                            if(found != null) {
                                if(found.getType().getKind() == Struct.Array) {
                                    lastDesignator = found;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                o1 = found;
                            } else
                                parser.report_error("" + name + "nije nadjeno "+nameleft,null );
                        }
                        lastDesignator = o1;
                        RESULT = o1;
                    }
                    else {
                      if(parser.lastMethod != null) {
                        if(o.getType().getKind() == Struct.Array)
                            lastDesignator = o;                       
                      }
                        RESULT = lastDesignator = o;
                    }  
                  }
                :}
                DesignatorListOpt:res {: if(res != null) RESULT = res; :}
                ;

DesignatorListOpt ::= DesignatorListOpt DesignatorIdent:val
                    {: 
                        if (val != null) RESULT = val;
                    :}
                     | /* epsilon */
                     ;

DesignatorIdent ::=  DOT IDENT:name
            {:
            if(!(isThisSpecified || (lastDesignator != null && (lastDesignator.getKind() == Obj.Elem || lastDesignator.getKind() == Obj.Var || lastDesignator.getKind() == Obj.Fld )&& lastDesignator.getType().getKind() == Struct.Class))) {
                        if(lastDesignator.getKind() == Obj.Type) {
                            if(isThisSpecified) {
                                Obj o = Tab.currentScope().getOuter().findSymbol(name);
                                if(o != null) {
                                    if(o.getKind() != Obj.Meth) {
                                        parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                        lastDesignator = Tab.noObj;
                                    } else if(o.getType().getElemType().getKind() != STATIC) {
                                        parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                        lastDesignator = Tab.noObj;
                                    } else {
                                        lastDesignator = o;
                                    }
                                }
                                else { // ako koristimo this a nema ga u toj klasi, proveravamo da li je klasa izvedena
                                      // i ima li u osnovnoj onda
                                    Obj found = null;
                                    if(parser.extendedClass != null) {
                                        for (Obj o1 : parser.extendedClass.getType().getMembers()) {
                                            if(o1.getName().equals(name))
                                                found = o1;
                                        }
                                    }
                                    if(found != null) {
                                        if(found.getKind() != Obj.Meth) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else if(found.getType().getElemType().getKind() != 6) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else {
                                            lastDesignator = found;
                                        }
                                    } else {
                                        parser.report_error("(this." + name + ") nije nadjeno", nameleft);
                                        lastDesignator = Tab.noObj;
                                    }
                                }
                            } else {
                                Obj found = null;
                                if(lastDesignator != null) {
                                    for (Obj o : lastDesignator.getType().getMembers()) { //pronalazimo u klasi ovaj naziv
                                        if(o.getName().equals(name))
                                            found = o;
                                    }
                                    if(found != null){
                                        if(found.getKind() != Obj.Meth) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else if(found.getType().getElemType().getKind() != 6) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else {
                                            lastDesignator = found;
                                        }
                                    } else {
                                        parser.report_error("(" + lastDesignator.getName() + "." + name + ") nije nadjeno", nameleft);
                                        lastDesignator = Tab.noObj;
                                    }
                                }
                            }
                            isThisSpecified = false;
                            RESULT = lastDesignator;
                        }
                        else {
                            parser.report_error(": " + lastDesignator.getName() + " nije klasa", nameleft);
                            lastDesignator = Tab.noObj;
                        }
                } else {
                    if(isThisSpecified) {
                        Obj o = Tab.currentScope().getOuter().findSymbol(name);
                        if(o != null) {
                            if(o.getType().getKind() == Struct.Array) {
                                lastDesignator = o;
                                if(lastDesignator != null && lastDesignator.getType() != null)
                                    classFields = lastDesignator.getType().getMembers();
                            }
                            lastDesignator = o;
                        }
                        else { // ako koristimo this a nema ga u toj klasi, proveravamo da li je klasa izvedena
                              // i ima li u osnovnoj onda
                            Obj found = null;
                            if(parser.extendedClass != null) {
                                for (Obj o1 : parser.extendedClass.getType().getMembers()) {
                                    if(o1.getName().equals(name))
                                        found = o1;
                                }
                            }
                            if(found != null) {
                                if(found.getType().getKind() == Struct.Array) {
                                    lastDesignator = found;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                lastDesignator = found;
                            } else
                                parser.report_error("(this." + name + ") nije nadjeno", nameleft);
                        }
                    } else {
                        Obj found = null;
                        if(lastDesignator != null) {
                            for (Obj o : lastDesignator.getType().getMembers()) { //pronalazimo u klasi ovaj naziv
                                if(o.getName().equals(name))
                                    found = o;
                            }
                            if(found != null){
                                if(found.getType().getKind() == Struct.Array) {
                                     lastDesignator = found;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                lastDesignator = found;
                            } else
                                parser.report_error("(" + lastDesignator.getName() + "." + name + ") nije nadjeno", nameleft);
                        }
                    }
                    isThisSpecified = false;
                    RESULT = lastDesignator;
                }
            :}
            |
            LBRACK:brack
            {:
            if(lastDesignator.getType().getKind() != Struct.Array) {
                    parser.report_error(": " + lastDesignator.getName() + " nije niz", brackleft);
                    RESULT = Tab.noObj;
            } else
                   backupDesig = lastDesignator;
                   
                   Code.load(lastDesignator);
             :}
             Expression:expr RBRACK   
             {:  
            if(expr.getKind() != Struct.Int)
                parser.report_error(" tip u zagradama niza mora biti int a vama je :"+ expr.getKind(),exprleft);
              else {
                    //if(RESULT == null) {
                        if(backupDesig != null)
                            RESULT = lastDesignator = new Obj(Obj.Elem, backupDesig.getName(), backupDesig.getType().getElemType(), backupDesig.getAdr(), backupDesig.getLevel());
                        else
                            RESULT = lastDesignator = Tab.noObj;
                    //}
                }
                
            :}
           
            ;
            

Condition ::= Condition OR CondTerm
        {:
        
        Code.putJump(0); 
        endAdr.push(Code.pc - 2);
    
        while(!orAdr.empty()) 
            Code.fixup(orAdr.pop());
                        
        
        :}
                |
                CondTerm
                        {:
        
        Code.putJump(0); 
        endAdr.push(Code.pc - 2);
    
        while(!orAdr.empty()) 
            Code.fixup(orAdr.pop());
                        
        
        :}
                ;
                          
CondTerm ::= CondTerm AND CondFact
            {:
                        Code.putJump(0); 
                        orAdr.push(Code.pc - 2);                    
                        while(!andAdr.empty()) 
                            Code.fixup(andAdr.pop());
                    :}
                |
                CondFact
                {:
                        Code.putJump(0); 
                        orAdr.push(Code.pc - 2);                    
                        while(!andAdr.empty()) 
                            Code.fixup(andAdr.pop());
                    :}
                ;

CondFact ::= Expression:exp
            {:
            if(exp.getKind() != Struct.Bool)
                    parser.report_error("Exp mora biti tipa bool", expleft);
            Code.loadConst(0); //expr je bool i samo proverimo da li je jednako sa 0
                Code.putFalseJump(Code.ne, 0); // dummy //ako nije tacan uslov odmah preskacemo AND uslove i idemo na OR ako ima
                andAdr.push(Code.pc - 2);
            :}
            |
            Expression:exp1 Relop:op Expression:exp2
            {:
            if(!exp1.compatibleWith(exp2)) {
                    if(!(exp1.getKind() == exp2.getKind() && exp1.getElemType() == exp2.getElemType() && exp1.getNumberOfFields() == exp2.getNumberOfFields()))
                        parser.report_error(" Tipovi nisu kompatibilni", exp1left);
                }
                else {
                    if(exp1.getKind() == Struct.Array || exp1.getKind() == Struct.Class) {
                        if(op != Code.eq && op != Code.ne)
                            parser.report_error("Uz promenljive tipa klase ili niza mogu se koristiti samo != i ==", exp1left);
                    }
                Code.putFalseJump(op, 0); // dummy
                andAdr.push(Code.pc - 2);   
                }
            :}
            ;
    
                
Expression ::= SUB AddopTermCombList:result
            {: 
                RESULT = result;
                
                if (result.getKind() != Struct.Int)
                {
                     RESULT = Tab.noType;
                     parser.report_error("izraz nakon minusa mora biti tipa int", resultleft);
                }
                Code.put(Code.neg);
            :}
            | AddopTermCombList:result
            {:
                RESULT = result;
            :}
            ;

AddopTermCombList ::=   AddopTermList:atl
                    
                    {:
                    if(atl.getKind() == Obj.Elem) {
                                Code.put(Code.dup2);
                                Code.put(Code.dup2);
                            }
                            if(atl.getKind() != Obj.Con)
                    Code.load(atl); 
                    :}
                    
                     AddopRight:op  AddopTermCombList:atcl
                        {:
                        Code.put((int)op);
                            Code.store(atl);
                            Code.load(atl);
                        if(atl.getKind() != Obj.Var && atl.getKind()!= Obj.Fld && atl.getKind() != Obj.Elem)
                                {
                                parser.report_error(" " + atl.getName() + " mora oznacavati  promenljivu, element niza ili polje objekta unutrasnje objekta", atlleft);
                                RESULT = Tab.noType;
                                }
                            else{
                                if(atl.getType().getKind() != Struct.Int)
                                    {
                                    parser.report_error(" mora biti int ", atlleft);
                                    RESULT = Tab.noType;
                                    }
                                else{
                                     if(atcl.getKind() != Struct.Int)
                                    {
                                        parser.report_error(" mora biti int ", atclleft);
                                        RESULT = Tab.noType;
                                    }
                                    else{
                                        RESULT = atl.getType();
                                    }
                                }
                            }
                        :}
                        |
                        AddopTermList:atl
                        {:
                        if(atl != null)
                        {
                        RESULT = atl.getType();
                        if(atl.getKind() == Obj.Var || atl.getKind() == Obj.Elem)
                            Code.load(atl);
                        }
                        else
                        RESULT = Tab.noType;
                        
                        :}
                        ;

AddopTermList ::=   AddopTermList:atl {:if(atl.getKind() != Obj.Con) Code.load(atl);:}
                    AddopLeft:op Term:term
                    {:
                     if(atl.getType().getKind() != Struct.Int)
                        {
                            parser.report_error(" " + atl.getName() + "mora biti int ", atlleft);
                            RESULT = Tab.noObj;
                         }
                     else{
                        if(term.getType().getKind() != Struct.Int)
                        {
                            parser.report_error(" " + term.getName() + "mora biti int ", termleft);
                            RESULT = Tab.noObj;
                        }
                        else{
                        RESULT = new Obj(Obj.Con, "rezultat sabiranja", Tab.intType);
                           }
                      }
                      if(term.getKind() != Obj.Con)
                            Code.load(term);
                        
                        Code.put((int)op);
                    :}
                    | Term:result
                    {: RESULT = result; :}
                    ;

Term ::=    MulopFactorList:mfl
        {:
        if(mfl.getKind() == Obj.Elem) {
                    Code.put(Code.dup2);
                    Code.put(Code.dup2);
                }
                if(mfl.getKind() != Obj.Con)
                    Code.load(mfl); 
        :}
             MulopRight:op Term:term
            {:
            if(term.getKind() != Obj.Con)
                    Code.load(term);
                    
                Code.put((int)op);
                Code.store(mfl);
            if(mfl.getKind() != Obj.Var && mfl.getKind()!= Obj.Fld && mfl.getKind() != Obj.Elem)
                    {
                    parser.report_error(" " + mfl.getName() + " mora oznacavati  promenljivu, element niza ili polje objekta unutrasnje objekta", mflleft);
                    RESULT = Tab.noObj;
                    }
                else{
                    if(mfl.getType().getKind() != Struct.Int)
                        {
                        parser.report_error(" " + mfl.getName() + "mora biti int ", mflleft);
                        RESULT = Tab.noObj;
                        }
                    else{
                         if(term.getType().getKind() != Struct.Int)
                        {
                            parser.report_error(" " + term.getName() + "mora biti int ", termleft);
                            RESULT = Tab.noObj;
                        }
                        else{
                            RESULT = mfl;
                        }
                    }
                }:}
            | MulopFactorList:result
            {: RESULT = result; :}
            ;

MulopFactorList ::= MulopFactorList:mfl 
                    {:
                    if(mfl.getKind() != Obj.Con)
                            Code.load(mfl);
                    :}
                
                    MulopLeft:op Factor:fact    
                    {:
                    if(fact.getKind() != Obj.Con) 
                            Code.load(fact);
                        
                        Code.put((int)op);
                    if(mfl.getType().getKind() != Struct.Int)
                        {
                            parser.report_error(" " + mfl.getName() + "mora biti int ", mflleft);
                            RESULT = Tab.noObj;
                         }
                     else{
                        if(fact.getType().getKind() != Struct.Int)
                        {
                            parser.report_error(" " + fact.getName() + "mora biti int ", factleft);
                            RESULT = Tab.noObj;
                        }
                        else{
                        RESULT = new Obj(Obj.Con, "rezultat mnozenja", Tab.intType);
                           }
                      }
                        /*RESULT = Tab.noObj;
                        if (GetResultIfBothInt(mfl, mflleft, fact.getType()) != Tab.noObj)
                        {
                            RESULT = new Obj(Obj.Con, "Multiplication result", Tab.intType); 
                        }  */
                    :}
                    | Factor:result
                    {: RESULT = result; :}
                    ;

Factor ::=  Designator:designator
            {:  RESULT = designator;
                if(designator.getKind() == Obj.Con)
                    Code.load(designator);
            :}
            | Designator:designator  LPAREN ActParsListOpt:params RPAREN
            {:
            	EntityCounters.IncreaseFunctionCallsCount();
                if (designator.getKind() != Obj.Meth)
                { 
                    parser.report_error("Funkcija nije deklarisana",designatorleft);
                    RESULT = Tab.noObj;
                }
                else
                {
                    RESULT = new Obj(Obj.Meth, 
                        designator.getName(), 
                        new Struct(designator.getType().getKind()), 
                        designator.getAdr(), 
                        designator.getLevel());   
                }
                
                if(RESULT != Tab.noObj) {
                    if(params == RESULT.getLevel()) {
                        boolean flag = true;
                        for(int i = 0; i < params; i++) {
                            Obj o = ((Obj) designator.getLocalSymbols().toArray()[i]);
                            Struct s = actParams.get(actParams.size() - (params - i));
                             if(!o.getType().compatibleWith(s))
                                if(!(o.getType().getKind() != Struct.Class && o.getType().getKind() == s.getKind() && o.getType().getElemType() == s.getElemType() && o.getType().getNumberOfFields() == s.getNumberOfFields()))
                             //if (!IsAssignable(o,s))
                                    flag = false;
                        }
                        
                        if(!flag)
                            parser.report_error(" __Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva.", paramsleft);
                        else {
                            if(RESULT.getType() != Tab.noType)
                                RESULT = new Obj(Obj.Con, "", RESULT.getType());
                                
                            else                            
                                parser.report_error(" Funkcija nema povratnu vrednost.", paramsleft);
                            
                            int destAdr = designator.getAdr() - Code.pc;
                            Code.put(Code.call);
                            Code.put2(destAdr);
                        }
                    } else {
                        parser.report_error(" Broj argumenata funkcije nije dobar."+ RESULT.getName(), paramsleft);                        
                    }
                    for(int i = 0; i < params; i++)
                            actParams.remove(actParams.size() - 1);
                }
            :}
            | NUMBER:num
            {: 
            Obj value = new Obj(Obj.Con, "" + num, Tab.intType); 
            value.setAdr(num.intValue());
            Code.load(value);
            RESULT = value;  
            :}
            | CHAR:chr
            {: 
            Obj value = new Obj(Obj.Con, "" + chr, Tab.charType); 
            value.setAdr(chr);
            Code.load(value);
            RESULT = value; 
             :}
            
            | BOOL:boo
            {:
            Obj value = new Obj(Obj.Con, "" + boo, new Struct (Struct.Bool)); 
            value.setAdr(boo? 1:0);
            Code.load(value);
            RESULT = value;  
            :}
            | NEW Type:type
            {:
                if(type.getKind()!=Struct.Class)
                    parser.report_error("tip prilikom pravljenja objekta mora biti unutrasnja klasa",typeleft);
                else
                {
                if(lastDesignator.getType().getKind() != type.getKind()) {
                      parser.report_error(": tipovi se ne podudaraju ", typeleft);
                      RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                } else
                      RESULT = new Obj(Obj.NO_VALUE, "", type);
                
                }
            :}
            |
            NEW Type:type 
            {:
                Obj obj = Tab.noObj;
                if(classFields == null)
                    obj = Tab.find(lastDesignator.getName());      
                else  { 
                    for (Obj o : classFields) { 
                        if(o.getName().equals(lastDesignator.getName()))
                            obj = o;
                    }
                } 
                                
                if(obj == Tab.noObj)
                    RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                else {
                    if(obj.getType().getElemType() != type) {
                        parser.report_error("Ne podudaraju se tipovi." +type+ " i "+obj.getType()+ " + "+ obj.getType()+"("+typeleft+")",null );
                        RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                    }
                } 
                    
                classFields = null;
            :}
            LBRACK Expression:expr RBRACK
            {:
                if(expr.getKind() == Struct.Int)
                    RESULT = new Obj(Obj.NO_VALUE, "", new Struct(Struct.Array, type));
                else {
                    parser.report_error(": tip expr mora biti int", typeleft);
                    RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                } 
                
                Code.put(Code.newarray);
                Code.put(type == Tab.charType ? 0 : 1); 
            :}
            | LPAREN Expression:expr RPAREN
            {: RESULT = new Obj(Obj.Con, "", expr); :}
            ;
            
Assignop ::= ASSIGN 
            {: RESULT = 0 ; :}
            | AddopRight:addOp
            {: RESULT = addOp ; :}
            | MulopRight:mulOp
            {: RESULT = mulOp ; :}
            ;

Relop ::=   EQUAL
            {: RESULT = Code.eq ; :}
            | NOT_EQUAL
            {: RESULT = Code.ne ; :}
            | GREATER
            {: RESULT = Code.gt ; :} 
            | GREATER_EQUAL 
            {: RESULT = Code.ge ; :}
            | LESS
            {: RESULT = Code.lt ; :}
            | LESS_EQUAL
            {: RESULT = Code.le ; :}
            ;

Addop ::=   AddopLeft 
            | AddopRight 
            ;

AddopLeft ::=   ADD 
                {: RESULT = Code.add ; :}
                | SUB 
                {: RESULT = Code.sub ; :}
                ;

AddopRight ::=  ASSIGN_ADD 
                {: RESULT = Code.add ; :}
                | ASSIGN_SUB 
                {: RESULT = Code.sub ; :}
                ;

Mulop ::=   MulopLeft 
            | MulopRight 
            ;

MulopLeft ::=   MUL 
                {: RESULT = Code.mul ; :}
                | DIV 
                {: RESULT = Code.div ; :}
                | MOD 
                {: RESULT = Code.rem ; :}
                ;

MulopRight ::=  ASSIGN_MUL 
                {: RESULT = Code.mul ; :}
                | ASSIGN_DIV 
                {: RESULT = Code.div ; :}
                | ASSIGN_MOD 
                {: RESULT = Code.rem ; :}
            ;