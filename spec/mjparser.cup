package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.MJParser.SCOPE;

// import java.io.*;


parser code {:
    public static enum SCOPE
    {
        GLOBAL_SCOPE,
        METHOD_SCOPE,
        CLASS_SCOPE,
        CLASS_METHOD_SCOPE,
        MAIN_SCOPE
    }
    
    SCOPE currentScope = SCOPE.GLOBAL_SCOPE;
    
    int globalVariableCount = 0;
    int globalConstVariableCount = 0;
    int mainVariableCount = 0;
    int globalClassFunctionCount = 0;
    int staticClassFunctionCount = 0;
    int formalParamsCount = 0;
    int globalFunctionCount = 0;
    int classCount = 0;
    int classVariableCount = 0;
    
    void IncreaseVariableCount()
    {
        if (currentScope == SCOPE.GLOBAL_SCOPE) 
        {
            globalVariableCount++;
            return;
        }
        if (currentScope == SCOPE.MAIN_SCOPE)
        {
            mainVariableCount++;
            return;
        }
        if (currentScope == SCOPE.CLASS_SCOPE)
        {
            classVariableCount++;
        }
    }
    
    void IncreaseConstVariableCount()
    {
        if (currentScope == SCOPE.GLOBAL_SCOPE)
        {
            globalConstVariableCount++;
        }
    }
    
    void IncreaseStaticFunctionNumber()
    {
        if (currentScope == SCOPE.CLASS_SCOPE)
        {
            staticClassFunctionCount++;
        }
        /*if (currentScope == SCOPE.GLOBAL_SCOPE)
        {
            globalFunctionCount++;
        }*/
    }
    
    void IncreaseFunctionNumber()
    {
        if (currentScope == SCOPE.CLASS_SCOPE)
        {
            globalClassFunctionCount++;
        }
        if (currentScope == SCOPE.GLOBAL_SCOPE)
        {
            globalFunctionCount++;
        }
        
    }
    
    void InScope(SCOPE newScope)
    {
        if (currentScope == SCOPE.CLASS_SCOPE && newScope == SCOPE.METHOD_SCOPE)
        {
            currentScope = SCOPE.CLASS_METHOD_SCOPE;
            return;
        }
        currentScope = newScope;   
    }
    
    void OutOfCurrentScope()
    {
        if (currentScope == SCOPE.CLASS_METHOD_SCOPE)
        {
            currentScope = SCOPE.CLASS_SCOPE;
            return;
        }
        currentScope = SCOPE.GLOBAL_SCOPE;
    }
    
    Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null) 
        log.info(s.toString() + " " + s.value.toString());
    return s;
:}

terminal BREAK, CLASS, CONST, CONTINUE, ELSE, EXTENDS, FOR, IF, NEW, PRINT, PROG, READ, RETURN, STATIC, VOID;
terminal LBRACE, RBRACE, LBRACK, RBRACK, LPAREN, RPAREN;
terminal ADD, SUB, MUL, DIV, MOD;
terminal ASSIGN, ASSIGN_ADD, ASSIGN_SUB, ASSIGN_MUL, ASSIGN_DIV, ASSIGN_MOD;
terminal EQUAL, NOT_EQUAL, GREATER_EQUAL, LESS_EQUAL, GREATER, LESS;
terminal DEC, INC, OR, AND;
terminal SEMI, COMMA, DOT;
terminal BOOL, CHAR, NUMBER, IDENT;

non terminal ClassDecl, ClassVarDecl, ClassVarDeclListOpt, InClassStart, InClassEnd;
non terminal MethodDecl, MethodDeclOpt, MethodDeclListOpt, MethodVarDecl, MethodVarDeclListOpt, MethodIdentList,
             InMethodStart, InMethodEnd;
non terminal Designator, DesignatorOpt, DesignatorListOpt, DesignatorStatement, DesignatorIdent;
non terminal Addop, AddopLeft, AddopRight, AddopTermList, AddopTermCombList; 
non terminal Mulop, MulopLeft, MulopRight, MulopFactorList;       
non terminal VarArgs, VarDecl, VarDeclList, Var;
non terminal Const, ConstIdent, ConstDecl, ConstDeclList;
non terminal FormalParamDecl, FormParamsOpt, FormalParamList;
non terminal Statement, StatementListOpt, StatementIfElse;
non terminal Condition, CondTerm, CondFact, CondOpt;

non terminal Decl, DeclListOpt;
non terminal ExtendsOpt, StaticOpt, NumOpt;
non terminal Assignop, ActPars ,ActParsListOpt, Relop;
non terminal Program, Expression, Term, Type, TypeVoid, Factor;

precedence left ELSE;

Program ::= PROG IDENT DeclListOpt LBRACE MethodDeclListOpt RBRACE;

DeclListOpt ::= DeclListOpt Decl
                | /* epsilon */ 
                ;


Decl ::=    ClassDecl 
            | ConstDecl 
            | VarDecl 
            ;

//CONST DECLARATION
ConstDecl ::= CONST Type ConstDeclList SEMI;

ConstDeclList ::=   ( ConstDeclList COMMA ConstIdent | ConstIdent )
                    {: parser.IncreaseConstVariableCount(); :};
                
ConstIdent ::= IDENT ASSIGN Const;

Const ::=   BOOL
            | CHAR
            | NUMBER
            ;

//VAR DECLARATION
VarDecl ::= Type VarDeclList SEMI;

VarDeclList ::= VarDeclList COMMA Var
                | Var 
                ;

Var ::=    ( IDENT LBRACK RBRACK | IDENT  )
           {: parser.IncreaseVariableCount(); :}
           ;

Type ::= IDENT;

//CLASS VAR DECLARATION
ClassVarDeclListOpt ::= ClassVarDeclListOpt ClassVarDecl
                        | /*epsilon*/
                        ;

ClassVarDecl ::=    STATIC VarDecl
                    | VarDecl
                    ;

//CLASS DECLARATION
ClassDecl ::= CLASS IDENT ExtendsOpt LBRACE
{: 
    parser.InScope(SCOPE.CLASS_SCOPE);
    parser.classCount++;
:}
 ClassVarDeclListOpt MethodDeclOpt RBRACE
{: parser.OutOfCurrentScope(); :};


ExtendsOpt ::=  EXTENDS Type
                | /* epsilon */
                ;
            
//METHOD VAR DECLARATION
MethodVarDeclListOpt ::= MethodVarDeclListOpt MethodVarDecl
                        | /* epsilon */
                        ;

MethodVarDecl ::= Type MethodIdentList SEMI ;
                
MethodIdentList ::= MethodIdentList COMMA Var
                    | Var
                    ;

//METHOD DECLARATION
MethodDeclOpt ::=   LBRACE MethodDeclListOpt RBRACE
                    | /*epsilon*/
                    ;

MethodDeclListOpt ::= MethodDeclListOpt MethodDecl
                    | /* epsilon */
                    ;

MethodDecl ::= StaticOpt TypeVoid IDENT LPAREN FormParamsOpt RPAREN MethodVarDeclListOpt LBRACE 
{: 
    parser.InScope(SCOPE.METHOD_SCOPE);
:}
StatementListOpt RBRACE 
{: parser.OutOfCurrentScope(); :};

StaticOpt ::= 
            STATIC 
            {: parser.IncreaseStaticFunctionNumber(); :}
            | /*epsilon*/ 
            {: parser.IncreaseFunctionNumber(); :}
            ;

TypeVoid ::= Type
            | VOID
            ;

VarArgs ::= COMMA Type DOT DOT DOT IDENT {: parser.formalParamsCount++; :};

FormParamsOpt ::=   FormalParamList 
                    | FormalParamList VarArgs 
                    | VarArgs 
                    | /* epsilon */ 
                    ;

FormalParamList ::= FormalParamList COMMA FormalParamDecl | FormalParamDecl;
                    

FormalParamDecl ::= (Type IDENT LBRACK RBRACK | Type IDENT)
                    {: parser.formalParamsCount++; :}
                    ;

StatementListOpt ::= StatementListOpt Statement
                    | /* epsilon */
                    ;

Statement ::=   Designator DesignatorStatement SEMI
                | StatementIfElse
                | FOR LPAREN DesignatorOpt SEMI CondOpt SEMI DesignatorOpt RPAREN Statement
                | BREAK SEMI
                | CONTINUE SEMI
                | RETURN SEMI
                | RETURN Expression SEMI
                | READ LPAREN Designator RPAREN SEMI
                | PRINT LPAREN Expression NumOpt RPAREN SEMI
                | LBRACE StatementListOpt RBRACE
                ;

StatementIfElse ::= IF LPAREN Condition RPAREN Statement 
                    | IF LPAREN Condition RPAREN Statement ELSE Statement 
                    ;
                    
NumOpt ::=  COMMA NUMBER
            | /* epsilon */;

DesignatorOpt ::=  Designator DesignatorStatement 
            | /* epsilon */
            ;

CondOpt ::=  Condition 
            | /* epsilon */ 
            ;

DesignatorStatement ::= Assignop Expression
                        | LPAREN ActParsListOpt RPAREN
                        | INC
                        | DEC
                        ;

ActParsListOpt ::=  ActPars 
                    | /* epsilon */ 
                    ;

ActPars ::= ActPars COMMA Expression
            | Expression
            ;
            
Designator ::= IDENT DesignatorListOpt;

DesignatorListOpt ::= DesignatorListOpt DesignatorIdent
                 | /* epsilon */
                 ;

DesignatorIdent ::=  DOT IDENT
                | LBRACK Expression RBRACK
                ;
            

Condition ::=   Condition OR CondTerm
                | CondTerm
                ;
                          
CondTerm ::=    CondTerm AND CondFact
                | CondFact
                ;

CondFact ::=    Expression
                | Expression Relop Expression
                ;
    
                
Expression ::=    SUB AddopTermCombList
            | AddopTermCombList
            ;

AddopTermCombList ::=   AddopTermList    AddopRight  AddopTermCombList
                        | AddopTermList
                        ;

AddopTermList ::=   AddopTermList AddopLeft Term
                    | Term
                    ;

Term ::=    MulopFactorList MulopRight Term
            | MulopFactorList
            ;

MulopFactorList ::= MulopFactorList MulopLeft Factor
                    | Factor
                    ;

Factor ::=  Designator
            | Designator LPAREN ActParsListOpt RPAREN
            | NUMBER
            | CHAR
            | BOOL
            | NEW Type
            | NEW Type LBRACK Expression RBRACK
            | LPAREN Expression RPAREN
            ;
            
Assignop ::= ASSIGN 
            | AddopRight
            | MulopRight
            ;

Relop ::=   EQUAL
            | NOT_EQUAL
            | GREATER
            | GREATER_EQUAL 
            | LESS
            | LESS_EQUAL
            ;

Addop ::=   AddopLeft 
            | AddopRight 
            ;

AddopLeft ::=   ADD 
                | SUB 
                ;

AddopRight ::=  ASSIGN_ADD 
                | ASSIGN_SUB 
                ;

Mulop ::=   MulopLeft 
            | MulopRight 
            ;

MulopLeft ::=   MUL 
                | DIV 
                | MOD 
                ;

MulopRight ::=  ASSIGN_MUL 
                | ASSIGN_DIV 
                | ASSIGN_MOD 
                ;