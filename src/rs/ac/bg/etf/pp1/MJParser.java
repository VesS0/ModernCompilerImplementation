
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sat Sep 16 09:09:55 CEST 2017
//----------------------------------------------------

package rs.ac.bg.etf.pp1;

import rs.etf.pp1.mj.runtime.Code;
import java_cup.runtime.*;
import org.apache.log4j.*;
import java.util.*;
import java.util.stream.IntStream;
import rs.ac.bg.etf.pp1.util.ScopeEngine;
import rs.ac.bg.etf.pp1.util.EntityCounters;
import rs.ac.bg.etf.pp1.util.UtilFunctions;
import rs.ac.bg.etf.pp1.util.SCOPE;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Sat Sep 16 09:09:55 CEST 2017
  */
public class MJParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public MJParser() {super();}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\236\000\002\050\010\000\002\002\004\000\002\051" +
    "\003\000\002\045\004\000\002\045\002\000\002\044\003" +
    "\000\002\044\003\000\002\044\003\000\002\032\006\000" +
    "\002\033\005\000\002\033\003\000\002\031\005\000\002" +
    "\052\003\000\002\052\003\000\002\052\003\000\002\026" +
    "\005\000\002\026\005\000\002\027\005\000\002\027\005" +
    "\000\002\027\003\000\002\030\005\000\002\030\003\000" +
    "\002\063\003\000\002\004\004\000\002\004\002\000\002" +
    "\003\004\000\002\003\003\000\002\074\002\000\002\002" +
    "\012\000\002\067\004\000\002\067\004\000\002\067\002" +
    "\000\002\011\004\000\002\011\002\000\002\010\005\000" +
    "\002\012\005\000\002\012\003\000\002\006\005\000\002" +
    "\006\002\000\002\007\004\000\002\007\002\000\002\075" +
    "\002\000\002\076\002\000\002\005\016\000\002\062\003" +
    "\000\002\062\002\000\002\064\003\000\002\064\003\000" +
    "\002\025\010\000\002\071\003\000\002\071\004\000\002" +
    "\071\003\000\002\071\003\000\002\071\002\000\002\072" +
    "\005\000\002\072\005\000\002\072\003\000\002\034\006" +
    "\000\002\034\004\000\002\036\004\000\002\036\002\000" +
    "\002\035\004\000\002\035\003\000\002\077\002\000\002" +
    "\100\002\000\002\101\002\000\002\102\002\000\002\103" +
    "\002\000\002\035\020\000\002\035\004\000\002\035\004" +
    "\000\002\035\004\000\002\035\005\000\002\035\007\000" +
    "\002\035\010\000\002\035\005\000\002\037\007\000\002" +
    "\104\002\000\002\037\012\000\002\037\007\000\002\037" +
    "\011\000\002\046\004\000\002\046\002\000\002\013\003" +
    "\000\002\013\003\000\002\013\002\000\002\043\003\000" +
    "\002\043\003\000\002\043\002\000\002\105\002\000\002" +
    "\014\006\000\002\014\006\000\002\014\004\000\002\014" +
    "\004\000\002\014\005\000\002\070\003\000\002\070\002" +
    "\000\002\073\005\000\002\073\003\000\002\106\002\000" +
    "\002\053\005\000\002\060\004\000\002\060\002\000\002" +
    "\061\004\000\002\107\002\000\002\061\006\000\002\040" +
    "\005\000\002\040\003\000\002\041\005\000\002\041\003" +
    "\000\002\042\003\000\002\042\005\000\002\065\004\000" +
    "\002\065\003\000\002\110\002\000\002\066\006\000\002" +
    "\066\003\000\002\111\002\000\002\054\006\000\002\054" +
    "\003\000\002\112\002\000\002\056\006\000\002\056\003" +
    "\000\002\113\002\000\002\055\006\000\002\055\003\000" +
    "\002\057\003\000\002\057\006\000\002\057\003\000\002" +
    "\057\003\000\002\057\003\000\002\057\004\000\002\114" +
    "\002\000\002\057\010\000\002\057\005\000\002\021\003" +
    "\000\002\021\003\000\002\021\003\000\002\022\003\000" +
    "\002\022\003\000\002\022\003\000\002\022\003\000\002" +
    "\022\003\000\002\022\003\000\002\015\003\000\002\015" +
    "\003\000\002\016\003\000\002\016\003\000\002\023\003" +
    "\000\002\023\003\000\002\020\003\000\002\020\003\000" +
    "\002\024\003\000\002\024\003\000\002\024\003\000\002" +
    "\017\003\000\002\017\003\000\002\017\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\370\000\004\016\005\001\002\000\004\002\372\001" +
    "\002\000\004\064\007\001\002\000\012\005\ufffd\006\ufffd" +
    "\023\ufffd\064\ufffd\001\002\000\012\005\uffff\006\uffff\023" +
    "\uffff\064\uffff\001\002\000\012\005\020\006\021\023\013" +
    "\064\014\001\002\000\006\003\362\064\120\001\002\000" +
    "\012\005\ufffe\006\ufffe\023\ufffe\064\ufffe\001\002\000\012" +
    "\021\uffd9\022\uffd9\024\uffd9\064\uffd9\001\002\000\070\003" +
    "\uffeb\023\uffeb\025\uffeb\026\uffeb\030\uffeb\031\uffeb\032\uffeb" +
    "\033\uffeb\034\uffeb\035\uffeb\037\uffeb\040\uffeb\041\uffeb\042" +
    "\uffeb\043\uffeb\044\uffeb\045\uffeb\046\uffeb\047\uffeb\050\uffeb" +
    "\051\uffeb\054\uffeb\055\uffeb\056\uffeb\057\uffeb\060\uffeb\064" +
    "\uffeb\001\002\000\012\005\ufffa\006\ufffa\023\ufffa\064\ufffa" +
    "\001\002\000\012\005\ufffc\006\ufffc\023\ufffc\064\ufffc\001" +
    "\002\000\012\005\ufffb\006\ufffb\023\ufffb\064\ufffb\001\002" +
    "\000\004\064\036\001\002\000\004\064\014\001\002\000" +
    "\004\064\024\001\002\000\006\056\034\057\033\001\002" +
    "\000\004\036\026\001\002\000\006\056\ufff7\057\ufff7\001" +
    "\002\000\010\061\027\062\032\063\031\001\002\000\006" +
    "\056\ufff3\057\ufff3\001\002\000\006\056\ufff6\057\ufff6\001" +
    "\002\000\006\056\ufff5\057\ufff5\001\002\000\006\056\ufff4" +
    "\057\ufff4\001\002\000\004\064\024\001\002\000\012\005" +
    "\ufff9\006\ufff9\023\ufff9\064\ufff9\001\002\000\006\056\ufff8" +
    "\057\ufff8\001\002\000\006\011\040\023\uffe2\001\002\000" +
    "\004\023\043\001\002\000\006\003\042\064\014\001\002" +
    "\000\004\023\uffe4\001\002\000\004\023\uffe3\001\002\000" +
    "\012\021\uffe6\023\uffe6\024\uffe6\064\uffe6\001\002\000\012" +
    "\021\uffe9\023\uffe9\024\uffe9\064\uffe9\001\002\000\012\021" +
    "\047\023\046\024\uffdb\064\014\001\002\000\012\021\uffd9" +
    "\022\uffd9\024\uffd9\064\uffd9\001\002\000\004\064\014\001" +
    "\002\000\012\021\uffe7\023\uffe7\024\uffe7\064\uffe7\001\002" +
    "\000\012\021\uffea\023\uffea\024\uffea\064\uffea\001\002\000" +
    "\004\024\053\001\002\000\012\005\uffe5\006\uffe5\023\uffe5" +
    "\064\uffe5\001\002\000\012\021\uffe8\023\uffe8\024\uffe8\064" +
    "\uffe8\001\002\000\012\021\056\022\uffd4\024\057\064\uffd4" +
    "\001\002\000\006\022\uffd5\064\uffd5\001\002\000\004\024" +
    "\uffdc\001\002\000\012\021\uffda\022\uffda\024\uffda\064\uffda" +
    "\001\002\000\006\022\064\064\014\001\002\000\004\064" +
    "\uffd3\001\002\000\004\064\065\001\002\000\004\064\uffd2" +
    "\001\002\000\004\027\uffd8\001\002\000\004\027\067\001" +
    "\002\000\012\003\072\030\uffcc\057\070\064\014\001\002" +
    "\000\004\064\014\001\002\000\004\064\103\001\002\000" +
    "\006\030\uffcd\057\354\001\002\000\004\030\112\001\002" +
    "\000\006\030\uffd0\057\077\001\002\000\004\030\uffce\001" +
    "\002\000\006\030\uffc9\057\uffc9\001\002\000\004\064\014" +
    "\001\002\000\004\030\uffcf\001\002\000\006\060\104\064" +
    "\103\001\002\000\006\030\uffcb\057\uffcb\001\002\000\010" +
    "\025\110\030\uffc7\057\uffc7\001\002\000\004\060\105\001" +
    "\002\000\004\060\106\001\002\000\004\064\107\001\002" +
    "\000\004\030\uffd1\001\002\000\004\026\111\001\002\000" +
    "\006\030\uffc8\057\uffc8\001\002\000\006\023\uffe0\064\uffe0" +
    "\001\002\000\006\023\114\064\014\001\002\000\026\004" +
    "\uffd7\007\uffd7\012\uffd7\013\uffd7\015\uffd7\017\uffd7\020\uffd7" +
    "\023\uffd7\024\uffd7\064\uffd7\001\002\000\004\064\120\001" +
    "\002\000\006\023\uffe1\064\uffe1\001\002\000\006\056\125" +
    "\057\124\001\002\000\010\025\122\056\uffec\057\uffec\001" +
    "\002\000\006\056\uffdd\057\uffdd\001\002\000\004\026\123" +
    "\001\002\000\006\056\uffed\057\uffed\001\002\000\004\064" +
    "\120\001\002\000\006\023\uffdf\064\uffdf\001\002\000\006" +
    "\056\uffde\057\uffde\001\002\000\026\004\uffc5\007\uffc5\012" +
    "\uffc5\013\uffc5\015\uffc5\017\uffc5\020\uffc5\023\uffc5\024\uffc5" +
    "\064\uffc5\001\002\000\026\004\146\007\143\012\134\013" +
    "\136\015\141\017\131\020\144\023\132\024\145\064\133" +
    "\001\002\000\004\027\350\001\002\000\026\004\uffc5\007" +
    "\uffc5\012\uffc5\013\uffc5\015\uffc5\017\uffc5\020\uffc5\023\uffc5" +
    "\024\uffc5\064\uffc5\001\002\000\072\025\uff9e\026\uff9e\027" +
    "\uff9e\030\uff9e\031\uff9e\032\uff9e\033\uff9e\034\uff9e\035\uff9e" +
    "\036\uff9e\037\uff9e\040\uff9e\041\uff9e\042\uff9e\043\uff9e\044" +
    "\uff9e\045\uff9e\046\uff9e\047\uff9e\050\uff9e\051\uff9e\052\uff9e" +
    "\053\uff9e\054\uff9e\055\uff9e\056\uff9e\057\uff9e\060\uff9e\001" +
    "\002\000\004\027\314\001\002\000\024\027\306\036\303" +
    "\037\211\040\210\041\174\042\175\043\176\052\305\053" +
    "\304\001\002\000\004\027\245\001\002\000\026\004\uffc6" +
    "\007\uffc6\012\uffc6\013\uffc6\015\uffc6\017\uffc6\020\uffc6\023" +
    "\uffc6\024\uffc6\064\uffc6\001\002\000\004\056\244\001\002" +
    "\000\004\027\235\001\002\000\030\004\uffc3\007\uffc3\010" +
    "\uffc3\012\uffc3\013\uffc3\015\uffc3\017\uffc3\020\uffc3\023\uffc3" +
    "\024\uffc3\064\uffc3\001\002\000\004\056\234\001\002\000" +
    "\022\014\151\027\164\032\161\056\156\061\154\062\165" +
    "\063\152\064\133\001\002\000\012\021\uffd6\022\uffd6\024" +
    "\uffd6\064\uffd6\001\002\000\004\056\147\001\002\000\030" +
    "\004\uffbc\007\uffbc\010\uffbc\012\uffbc\013\uffbc\015\uffbc\017" +
    "\uffbc\020\uffbc\023\uffbc\024\uffbc\064\uffbc\001\002\000\032" +
    "\026\uff90\030\uff90\044\uff90\045\uff90\046\uff90\047\uff90\050" +
    "\uff90\051\uff90\054\uff90\055\uff90\056\uff90\057\uff90\001\002" +
    "\000\004\064\014\001\002\000\056\026\uff7f\030\uff7f\031" +
    "\uff7f\032\uff7f\033\uff7f\034\uff7f\035\uff7f\037\uff7f\040\uff7f" +
    "\041\uff7f\042\uff7f\043\uff7f\044\uff7f\045\uff7f\046\uff7f\047" +
    "\uff7f\050\uff7f\051\uff7f\054\uff7f\055\uff7f\056\uff7f\057\uff7f" +
    "\001\002\000\060\026\uff83\027\220\030\uff83\031\uff83\032" +
    "\uff83\033\uff83\034\uff83\035\uff83\037\uff83\040\uff83\041\uff83" +
    "\042\uff83\043\uff83\044\uff83\045\uff83\046\uff83\047\uff83\050" +
    "\uff83\051\uff83\054\uff83\055\uff83\056\uff83\057\uff83\001\002" +
    "\000\056\026\uff81\030\uff81\031\uff81\032\uff81\033\uff81\034" +
    "\uff81\035\uff81\037\uff81\040\uff81\041\uff81\042\uff81\043\uff81" +
    "\044\uff81\045\uff81\046\uff81\047\uff81\050\uff81\051\uff81\054" +
    "\uff81\055\uff81\056\uff81\057\uff81\001\002\000\042\026\uff8d" +
    "\030\uff8d\031\uff8c\032\uff8c\037\uff8f\040\uff8f\044\uff8d\045" +
    "\uff8d\046\uff8d\047\uff8d\050\uff8d\051\uff8d\054\uff8d\055\uff8d" +
    "\056\uff8d\057\uff8d\001\002\000\030\004\uffba\007\uffba\010" +
    "\uffba\012\uffba\013\uffba\015\uffba\017\uffba\020\uffba\023\uffba" +
    "\024\uffba\064\uffba\001\002\000\004\056\205\001\002\000" +
    "\056\026\uff87\030\uff87\031\uff87\032\uff87\033\uff86\034\uff86" +
    "\035\uff86\037\uff87\040\uff87\041\uff89\042\uff89\043\uff89\044" +
    "\uff87\045\uff87\046\uff87\047\uff87\050\uff87\051\uff87\054\uff87" +
    "\055\uff87\056\uff87\057\uff87\001\002\000\016\014\151\027" +
    "\164\061\154\062\165\063\152\064\133\001\002\000\042" +
    "\026\uff8a\030\uff8a\031\uff8a\032\uff8a\037\uff8a\040\uff8a\044" +
    "\uff8a\045\uff8a\046\uff8a\047\uff8a\050\uff8a\051\uff8a\054\uff8a" +
    "\055\uff8a\056\uff8a\057\uff8a\001\002\000\056\026\uff84\030" +
    "\uff84\031\uff84\032\uff84\033\uff84\034\uff84\035\uff84\037\uff84" +
    "\040\uff84\041\uff84\042\uff84\043\uff84\044\uff84\045\uff84\046" +
    "\uff84\047\uff84\050\uff84\051\uff84\054\uff84\055\uff84\056\uff84" +
    "\057\uff84\001\002\000\020\014\151\027\164\032\161\061" +
    "\154\062\165\063\152\064\133\001\002\000\056\026\uff80" +
    "\030\uff80\031\uff80\032\uff80\033\uff80\034\uff80\035\uff80\037" +
    "\uff80\040\uff80\041\uff80\042\uff80\043\uff80\044\uff80\045\uff80" +
    "\046\uff80\047\uff80\050\uff80\051\uff80\054\uff80\055\uff80\056" +
    "\uff80\057\uff80\001\002\000\004\030\167\001\002\000\056" +
    "\026\uff7b\030\uff7b\031\uff7b\032\uff7b\033\uff7b\034\uff7b\035" +
    "\uff7b\037\uff7b\040\uff7b\041\uff7b\042\uff7b\043\uff7b\044\uff7b" +
    "\045\uff7b\046\uff7b\047\uff7b\050\uff7b\051\uff7b\054\uff7b\055" +
    "\uff7b\056\uff7b\057\uff7b\001\002\000\032\026\uff91\030\uff91" +
    "\044\uff91\045\uff91\046\uff91\047\uff91\050\uff91\051\uff91\054" +
    "\uff91\055\uff91\056\uff91\057\uff91\001\002\000\010\033\201" +
    "\034\203\035\200\001\002\000\010\041\174\042\175\043" +
    "\176\001\002\000\016\014\151\027\164\061\154\062\165" +
    "\063\152\064\133\001\002\000\022\003\uff66\014\uff66\027" +
    "\uff66\032\uff66\061\uff66\062\uff66\063\uff66\064\uff66\001\002" +
    "\000\022\003\uff65\014\uff65\027\uff65\032\uff65\061\uff65\062" +
    "\uff65\063\uff65\064\uff65\001\002\000\022\003\uff64\014\uff64" +
    "\027\uff64\032\uff64\061\uff64\062\uff64\063\uff64\064\uff64\001" +
    "\002\000\042\026\uff88\030\uff88\031\uff88\032\uff88\037\uff88" +
    "\040\uff88\044\uff88\045\uff88\046\uff88\047\uff88\050\uff88\051" +
    "\uff88\054\uff88\055\uff88\056\uff88\057\uff88\001\002\000\016" +
    "\014\uff67\027\uff67\061\uff67\062\uff67\063\uff67\064\uff67\001" +
    "\002\000\016\014\uff69\027\uff69\061\uff69\062\uff69\063\uff69" +
    "\064\uff69\001\002\000\016\014\151\027\164\061\154\062" +
    "\165\063\152\064\133\001\002\000\016\014\uff68\027\uff68" +
    "\061\uff68\062\uff68\063\uff68\064\uff68\001\002\000\056\026" +
    "\uff85\030\uff85\031\uff85\032\uff85\033\uff85\034\uff85\035\uff85" +
    "\037\uff85\040\uff85\041\uff85\042\uff85\043\uff85\044\uff85\045" +
    "\uff85\046\uff85\047\uff85\050\uff85\051\uff85\054\uff85\055\uff85" +
    "\056\uff85\057\uff85\001\002\000\030\004\uffb9\007\uffb9\010" +
    "\uffb9\012\uffb9\013\uffb9\015\uffb9\017\uffb9\020\uffb9\023\uffb9" +
    "\024\uffb9\064\uffb9\001\002\000\006\031\215\032\214\001" +
    "\002\000\006\037\211\040\210\001\002\000\022\003\uff6c" +
    "\014\uff6c\027\uff6c\032\uff6c\061\uff6c\062\uff6c\063\uff6c\064" +
    "\uff6c\001\002\000\022\003\uff6d\014\uff6d\027\uff6d\032\uff6d" +
    "\061\uff6d\062\uff6d\063\uff6d\064\uff6d\001\002\000\016\014" +
    "\151\027\164\061\154\062\165\063\152\064\133\001\002" +
    "\000\032\026\uff8e\030\uff8e\044\uff8e\045\uff8e\046\uff8e\047" +
    "\uff8e\050\uff8e\051\uff8e\054\uff8e\055\uff8e\056\uff8e\057\uff8e" +
    "\001\002\000\016\014\uff6e\027\uff6e\061\uff6e\062\uff6e\063" +
    "\uff6e\064\uff6e\001\002\000\016\014\uff6f\027\uff6f\061\uff6f" +
    "\062\uff6f\063\uff6f\064\uff6f\001\002\000\016\014\151\027" +
    "\164\061\154\062\165\063\152\064\133\001\002\000\042" +
    "\026\uff8b\030\uff8b\031\uff8b\032\uff8b\037\uff8b\040\uff8b\044" +
    "\uff8b\045\uff8b\046\uff8b\047\uff8b\050\uff8b\051\uff8b\054\uff8b" +
    "\055\uff8b\056\uff8b\057\uff8b\001\002\000\022\014\151\027" +
    "\164\030\uffa1\032\161\061\154\062\165\063\152\064\133" +
    "\001\002\000\006\030\uffa2\057\225\001\002\000\004\030" +
    "\224\001\002\000\006\030\uff9f\057\uff9f\001\002\000\056" +
    "\026\uff82\030\uff82\031\uff82\032\uff82\033\uff82\034\uff82\035" +
    "\uff82\037\uff82\040\uff82\041\uff82\042\uff82\043\uff82\044\uff82" +
    "\045\uff82\046\uff82\047\uff82\050\uff82\051\uff82\054\uff82\055" +
    "\uff82\056\uff82\057\uff82\001\002\000\020\014\151\027\164" +
    "\032\161\061\154\062\165\063\152\064\133\001\002\000" +
    "\006\030\uffa0\057\uffa0\001\002\000\060\025\uff7d\026\uff7e" +
    "\030\uff7e\031\uff7e\032\uff7e\033\uff7e\034\uff7e\035\uff7e\037" +
    "\uff7e\040\uff7e\041\uff7e\042\uff7e\043\uff7e\044\uff7e\045\uff7e" +
    "\046\uff7e\047\uff7e\050\uff7e\051\uff7e\054\uff7e\055\uff7e\056" +
    "\uff7e\057\uff7e\001\002\000\004\025\231\001\002\000\020" +
    "\014\151\027\164\032\161\061\154\062\165\063\152\064" +
    "\133\001\002\000\004\026\233\001\002\000\056\026\uff7c" +
    "\030\uff7c\031\uff7c\032\uff7c\033\uff7c\034\uff7c\035\uff7c\037" +
    "\uff7c\040\uff7c\041\uff7c\042\uff7c\043\uff7c\044\uff7c\045\uff7c" +
    "\046\uff7c\047\uff7c\050\uff7c\051\uff7c\054\uff7c\055\uff7c\056" +
    "\uff7c\057\uff7c\001\002\000\030\004\uffbb\007\uffbb\010\uffbb" +
    "\012\uffbb\013\uffbb\015\uffbb\017\uffbb\020\uffbb\023\uffbb\024" +
    "\uffbb\064\uffbb\001\002\000\020\014\151\027\164\032\161" +
    "\061\154\062\165\063\152\064\133\001\002\000\006\030" +
    "\uffaf\057\237\001\002\000\004\061\243\001\002\000\004" +
    "\030\241\001\002\000\004\056\242\001\002\000\030\004" +
    "\uffb7\007\uffb7\010\uffb7\012\uffb7\013\uffb7\015\uffb7\017\uffb7" +
    "\020\uffb7\023\uffb7\024\uffb7\064\uffb7\001\002\000\004\030" +
    "\uffb0\001\002\000\030\004\uffc4\007\uffc4\010\uffc4\012\uffc4" +
    "\013\uffc4\015\uffc4\017\uffc4\020\uffc4\023\uffc4\024\uffc4\064" +
    "\uffc4\001\002\000\022\003\247\014\151\027\164\032\161" +
    "\061\154\062\165\063\152\064\133\001\002\000\012\030" +
    "\uff94\054\uff94\055\uff94\056\uff94\001\002\000\004\030\274" +
    "\001\002\000\012\030\uff96\054\uff96\055\266\056\uff96\001" +
    "\002\000\006\030\263\054\264\001\002\000\026\030\uff93" +
    "\044\256\045\253\046\255\047\260\050\254\051\257\054" +
    "\uff93\055\uff93\056\uff93\001\002\000\020\014\uff76\027\uff76" +
    "\032\uff76\061\uff76\062\uff76\063\uff76\064\uff76\001\002\000" +
    "\020\014\uff75\027\uff75\032\uff75\061\uff75\062\uff75\063\uff75" +
    "\064\uff75\001\002\000\020\014\uff74\027\uff74\032\uff74\061" +
    "\uff74\062\uff74\063\uff74\064\uff74\001\002\000\020\014\uff77" +
    "\027\uff77\032\uff77\061\uff77\062\uff77\063\uff77\064\uff77\001" +
    "\002\000\020\014\uff73\027\uff73\032\uff73\061\uff73\062\uff73" +
    "\063\uff73\064\uff73\001\002\000\020\014\uff72\027\uff72\032" +
    "\uff72\061\uff72\062\uff72\063\uff72\064\uff72\001\002\000\020" +
    "\014\151\027\164\032\161\061\154\062\165\063\152\064" +
    "\133\001\002\000\012\030\uff92\054\uff92\055\uff92\056\uff92" +
    "\001\002\000\024\004\146\007\143\012\134\013\136\015" +
    "\141\017\131\020\144\023\132\064\133\001\002\000\020" +
    "\014\151\027\164\032\161\061\154\062\165\063\152\064" +
    "\133\001\002\000\012\030\uff97\054\uff97\055\266\056\uff97" +
    "\001\002\000\020\014\151\027\164\032\161\061\154\062" +
    "\165\063\152\064\133\001\002\000\012\030\uff95\054\uff95" +
    "\055\uff95\056\uff95\001\002\000\030\004\uffb5\007\uffb5\010" +
    "\271\012\uffb5\013\uffb5\015\uffb5\017\uffb5\020\uffb5\023\uffb5" +
    "\024\uffb5\064\uffb5\001\002\000\024\004\uffb4\007\uffb4\012" +
    "\uffb4\013\uffb4\015\uffb4\017\uffb4\020\uffb4\023\uffb4\064\uffb4" +
    "\001\002\000\024\004\146\007\143\012\134\013\136\015" +
    "\141\017\131\020\144\023\132\064\133\001\002\000\030" +
    "\004\uffb3\007\uffb3\010\uffb3\012\uffb3\013\uffb3\015\uffb3\017" +
    "\uffb3\020\uffb3\023\uffb3\024\uffb3\064\uffb3\001\002\000\024" +
    "\004\146\007\143\012\134\013\136\015\141\017\131\020" +
    "\144\023\132\064\133\001\002\000\030\004\uffb2\007\uffb2" +
    "\010\276\012\uffb2\013\uffb2\015\uffb2\017\uffb2\020\uffb2\023" +
    "\uffb2\024\uffb2\064\uffb2\001\002\000\024\004\146\007\143" +
    "\012\134\013\136\015\141\017\131\020\144\023\132\064" +
    "\133\001\002\000\030\004\uffb1\007\uffb1\010\uffb1\012\uffb1" +
    "\013\uffb1\015\uffb1\017\uffb1\020\uffb1\023\uffb1\024\uffb1\064" +
    "\uffb1\001\002\000\022\003\uff78\014\uff78\027\uff78\032\uff78" +
    "\061\uff78\062\uff78\063\uff78\064\uff78\001\002\000\022\003" +
    "\uff79\014\uff79\027\uff79\032\uff79\061\uff79\062\uff79\063\uff79" +
    "\064\uff79\001\002\000\022\003\311\014\uffa8\027\uffa8\032" +
    "\uffa8\061\uffa8\062\uffa8\063\uffa8\064\uffa8\001\002\000\022" +
    "\003\uff7a\014\uff7a\027\uff7a\032\uff7a\061\uff7a\062\uff7a\063" +
    "\uff7a\064\uff7a\001\002\000\006\030\uffa5\056\uffa5\001\002" +
    "\000\006\030\uffa4\056\uffa4\001\002\000\022\014\151\027" +
    "\164\030\uffa1\032\161\061\154\062\165\063\152\064\133" +
    "\001\002\000\004\030\310\001\002\000\006\030\uffa6\056" +
    "\uffa6\001\002\000\006\030\uffa3\056\uffa3\001\002\000\020" +
    "\014\151\027\164\032\161\061\154\062\165\063\152\064" +
    "\133\001\002\000\006\030\uffa7\056\uffa7\001\002\000\010" +
    "\003\315\056\uffac\064\133\001\002\000\006\030\uffad\056" +
    "\uffad\001\002\000\006\030\uffae\056\uffae\001\002\000\004" +
    "\056\320\001\002\000\024\003\uffc2\014\uffc2\027\uffc2\032" +
    "\uffc2\056\uffc2\061\uffc2\062\uffc2\063\uffc2\064\uffc2\001\002" +
    "\000\024\003\323\014\151\027\164\032\161\056\uffa9\061" +
    "\154\062\165\063\152\064\133\001\002\000\004\056\uffc1" +
    "\001\002\000\004\056\uffaa\001\002\000\006\054\264\056" +
    "\uffab\001\002\000\004\056\326\001\002\000\010\003\uffc0" +
    "\030\uffc0\064\uffc0\001\002\000\010\003\315\030\uffac\064" +
    "\133\001\002\000\004\030\uffbf\001\002\000\004\030\332" +
    "\001\002\000\024\004\uffbe\007\uffbe\012\uffbe\013\uffbe\015" +
    "\uffbe\017\uffbe\020\uffbe\023\uffbe\064\uffbe\001\002\000\024" +
    "\004\146\007\143\012\134\013\136\015\141\017\131\020" +
    "\144\023\132\064\133\001\002\000\030\004\uffbd\007\uffbd" +
    "\010\uffbd\012\uffbd\013\uffbd\015\uffbd\017\uffbd\020\uffbd\023" +
    "\uffbd\024\uffbd\064\uffbd\001\002\000\072\025\uff9b\026\uff9b" +
    "\027\uff9b\030\uff9b\031\uff9b\032\uff9b\033\uff9b\034\uff9b\035" +
    "\uff9b\036\uff9b\037\uff9b\040\uff9b\041\uff9b\042\uff9b\043\uff9b" +
    "\044\uff9b\045\uff9b\046\uff9b\047\uff9b\050\uff9b\051\uff9b\052" +
    "\uff9b\053\uff9b\054\uff9b\055\uff9b\056\uff9b\057\uff9b\060\uff9b" +
    "\001\002\000\072\025\340\026\uff9d\027\uff9d\030\uff9d\031" +
    "\uff9d\032\uff9d\033\uff9d\034\uff9d\035\uff9d\036\uff9d\037\uff9d" +
    "\040\uff9d\041\uff9d\042\uff9d\043\uff9d\044\uff9d\045\uff9d\046" +
    "\uff9d\047\uff9d\050\uff9d\051\uff9d\052\uff9d\053\uff9d\054\uff9d" +
    "\055\uff9d\056\uff9d\057\uff9d\060\341\001\002\000\072\025" +
    "\uff9c\026\uff9c\027\uff9c\030\uff9c\031\uff9c\032\uff9c\033\uff9c" +
    "\034\uff9c\035\uff9c\036\uff9c\037\uff9c\040\uff9c\041\uff9c\042" +
    "\uff9c\043\uff9c\044\uff9c\045\uff9c\046\uff9c\047\uff9c\050\uff9c" +
    "\051\uff9c\052\uff9c\053\uff9c\054\uff9c\055\uff9c\056\uff9c\057" +
    "\uff9c\060\uff9c\001\002\000\020\014\uff99\027\uff99\032\uff99" +
    "\061\uff99\062\uff99\063\uff99\064\uff99\001\002\000\004\064" +
    "\342\001\002\000\072\025\uff9a\026\uff9a\027\uff9a\030\uff9a" +
    "\031\uff9a\032\uff9a\033\uff9a\034\uff9a\035\uff9a\036\uff9a\037" +
    "\uff9a\040\uff9a\041\uff9a\042\uff9a\043\uff9a\044\uff9a\045\uff9a" +
    "\046\uff9a\047\uff9a\050\uff9a\051\uff9a\052\uff9a\053\uff9a\054" +
    "\uff9a\055\uff9a\056\uff9a\057\uff9a\060\uff9a\001\002\000\020" +
    "\014\151\027\164\032\161\061\154\062\165\063\152\064" +
    "\133\001\002\000\004\026\345\001\002\000\072\025\uff98" +
    "\026\uff98\027\uff98\030\uff98\031\uff98\032\uff98\033\uff98\034" +
    "\uff98\035\uff98\036\uff98\037\uff98\040\uff98\041\uff98\042\uff98" +
    "\043\uff98\044\uff98\045\uff98\046\uff98\047\uff98\050\uff98\051" +
    "\uff98\052\uff98\053\uff98\054\uff98\055\uff98\056\uff98\057\uff98" +
    "\060\uff98\001\002\000\026\004\146\007\143\012\134\013" +
    "\136\015\141\017\131\020\144\023\132\024\347\064\133" +
    "\001\002\000\030\004\uffb6\007\uffb6\010\uffb6\012\uffb6\013" +
    "\uffb6\015\uffb6\017\uffb6\020\uffb6\023\uffb6\024\uffb6\064\uffb6" +
    "\001\002\000\004\064\133\001\002\000\004\030\352\001" +
    "\002\000\004\056\353\001\002\000\030\004\uffb8\007\uffb8" +
    "\010\uffb8\012\uffb8\013\uffb8\015\uffb8\017\uffb8\020\uffb8\023" +
    "\uffb8\024\uffb8\064\uffb8\001\002\000\004\064\014\001\002" +
    "\000\006\030\uffca\057\uffca\001\002\000\004\060\104\001" +
    "\002\000\012\021\056\022\uffd4\024\360\064\uffd4\001\002" +
    "\000\004\002\001\001\002\000\006\056\370\057\367\001" +
    "\002\000\006\056\365\057\364\001\002\000\006\056\uffee" +
    "\057\uffee\001\002\000\004\064\120\001\002\000\016\005" +
    "\ufff1\006\ufff1\021\ufff1\023\ufff1\024\ufff1\064\ufff1\001\002" +
    "\000\006\056\uffef\057\uffef\001\002\000\004\064\120\001" +
    "\002\000\016\005\ufff2\006\ufff2\021\ufff2\023\ufff2\024\ufff2" +
    "\064\ufff2\001\002\000\006\056\ufff0\057\ufff0\001\002\000" +
    "\004\002\000\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\370\000\004\050\003\001\001\000\002\001\001\000" +
    "\004\051\005\001\001\000\004\045\007\001\001\000\002" +
    "\001\001\000\014\002\015\026\014\032\016\044\011\063" +
    "\010\001\001\000\006\027\360\030\362\001\001\000\002" +
    "\001\001\000\004\007\356\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\063\021\001\001\000\006\031\024\033" +
    "\022\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\052\027\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\031\034\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\067\036\001\001\000\002\001\001\000\004\063\040" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\074" +
    "\043\001\001\000\004\004\044\001\001\000\012\003\050" +
    "\006\051\026\047\063\010\001\001\000\004\007\054\001" +
    "\001\000\006\026\053\063\010\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\005\057\062\060\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\063" +
    "\061\064\062\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\075\065\001\001\000\002\001" +
    "\001\000\014\025\074\034\075\063\070\071\072\072\073" +
    "\001\001\000\004\063\355\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\025\077\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\034\101\063" +
    "\100\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\011\112\001\001\000\006\010" +
    "\115\063\114\001\001\000\004\076\126\001\001\000\006" +
    "\012\116\030\120\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\030\125\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\036\127\001\001\000\012" +
    "\014\137\035\136\037\141\053\134\001\001\000\002\001" +
    "\001\000\004\036\345\001\001\000\004\106\334\001\001" +
    "\000\002\001\001\000\010\017\277\021\301\023\300\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\020\053\152\054\154\055\157\056\161\057\162\065\156" +
    "\066\147\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\063\226\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\110\206\111\205\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\112\171\113\170\001\001\000\016\053" +
    "\152\054\154\055\157\056\161\057\162\066\167\001\001" +
    "\000\002\001\001\000\002\001\001\000\020\053\152\054" +
    "\154\055\157\056\161\057\162\065\165\066\147\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\024\201\001\001\000\004\017\172" +
    "\001\001\000\012\053\152\055\157\056\176\057\162\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\053\152\057\203\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\016\215\001\001\000" +
    "\004\023\211\001\001\000\002\001\001\000\002\001\001" +
    "\000\016\053\152\054\154\055\157\056\161\057\162\066" +
    "\212\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\012\053\152\055\157\056\216\057\162\001" +
    "\001\000\002\001\001\000\024\053\152\054\154\055\157" +
    "\056\161\057\162\065\222\066\147\070\221\073\220\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\020\053\152\054\154\055\157\056" +
    "\161\057\162\065\225\066\147\001\001\000\002\001\001" +
    "\000\004\114\227\001\001\000\002\001\001\000\020\053" +
    "\152\054\154\055\157\056\161\057\162\065\231\066\147" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\020\053\152\054\154\055\157\056\161\057\162" +
    "\065\235\066\147\001\001\000\004\046\237\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\026\040" +
    "\250\041\247\042\245\053\152\054\154\055\157\056\161" +
    "\057\162\065\251\066\147\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\022\260\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\020\053\152\054\154\055\157\056\161\057" +
    "\162\065\261\066\147\001\001\000\002\001\001\000\012" +
    "\014\137\035\267\037\141\053\134\001\001\000\024\041" +
    "\264\042\245\053\152\054\154\055\157\056\161\057\162" +
    "\065\251\066\147\001\001\000\002\001\001\000\022\042" +
    "\266\053\152\054\154\055\157\056\161\057\162\065\251" +
    "\066\147\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\104\271\001\001\000\012\014\137\035\272\037\141" +
    "\053\134\001\001\000\002\001\001\000\012\014\137\035" +
    "\274\037\141\053\134\001\001\000\002\001\001\000\012" +
    "\014\137\035\276\037\141\053\134\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\105\311" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\024\053\152\054\154\055\157\056\161\057\162" +
    "\065\222\066\147\070\306\073\220\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\020\053\152" +
    "\054\154\055\157\056\161\057\162\065\312\066\147\001" +
    "\001\000\002\001\001\000\010\013\316\014\315\053\134" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\077\320\001\001\000\030\040\323\041\247" +
    "\042\245\043\321\053\152\054\154\055\157\056\161\057" +
    "\162\065\251\066\147\001\001\000\004\100\324\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\101\326\001\001\000\010\013\327\014\315\053\134" +
    "\001\001\000\004\102\330\001\001\000\002\001\001\000" +
    "\004\103\332\001\001\000\012\014\137\035\333\037\141" +
    "\053\134\001\001\000\002\001\001\000\004\060\335\001" +
    "\001\000\004\061\336\001\001\000\002\001\001\000\004" +
    "\107\342\001\001\000\002\001\001\000\002\001\001\000" +
    "\020\053\152\054\154\055\157\056\161\057\162\065\343" +
    "\066\147\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\014\137\035\136\037\141\053\134\001\001\000\002" +
    "\001\001\000\004\053\350\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\034\354\063\070" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\005" +
    "\057\062\060\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\030\365\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\030\370" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MJParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MJParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MJParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

    Tab.init(); // Universe scope
    Tab.currentScope.addToLocals(new Obj(Obj.Type, "bool",CUP$MJParser$actions.boolType));

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null) 
        log.info(s.toString() + " " + s.value.toString());
    return s;

    }



    Struct lastMethType = null;
    Struct lastType = null; // unneeded can get from up
    Obj lastClass = null;
    Obj lastMethod = null;
    Obj extendedClass = null;
    String curTypeName = "";
    
    boolean returnHappend = false;
    boolean errorEncountered = false;
    boolean errorHandled = false;
    
    void ReportError(String errorMessage)
    {
        errorEncountered = true;
        log.debug(errorMessage);
    }
    
    void ReportVarDeclError(char errorChar)
    {
        if (ScopeEngine.IsInGlobalScope())
        {
        	ReportError("Doslo je do greske prilikom deklaracije globalne promenljive pre znaka \""+errorChar + '\"');
            return;
        }
        if (ScopeEngine.IsInClassScope())
        {
        	ReportError("Doslo je do greske prilikom definicije lokalne promenljive unutrasnje klase pre znaka \"" +errorChar+ '\"');
            return;
        }
    }
    
    boolean CorrectNameAndType(String name, Struct type)
    {
        
        if( Tab.currentScope.findSymbol(name) != null)
        {
             report_error(" " + name + " je vec deklarisano " ,null );
             return false;
        }
        
        if (type == null || type == Tab.noType)
        {
            report_error("Greska u tipu pri deklaraciji ", null);
            return false; 
        }
        
        return true;
    }
    
    void VariableDeclaration(String name, int nameLocation, int objectKind, Struct lastType, 
        Obj assignedType, int assignLocation)
    {
    	if (!CorrectNameAndType(name, lastType))
    	{
    		return;
    	}
    	
        if(assignedType != null && assignedType.getType() != lastType)
        {
            report_error("neispravan tip promenljive koja se dodeljuje "+ UtilFunctions.StructToTypeName(lastType) +" = "+ UtilFunctions.StructToTypeName(assignedType.getType()) +"("+assignLocation+")",null );
            return;
        }
        
        Obj obj = Tab.insert(objectKind, name, lastType);
        if (assignedType!=null) obj.setAdr(assignedType.getAdr());
        report_info("Definisana promenljiva " + name + " tipa: "+UtilFunctions.StructToTypeName(lastType)+ " na liniji "+nameLocation, null);
    }

    // Overloading
    void VariableDeclaration(String name, int nameLocation, int objectType, Struct lastt)
    {
        VariableDeclaration(name, nameLocation, objectType, lastt, null, 0);
    }
    
    void ClassDeclaration(String className, int classLocation)
    {
        if(Tab.currentScope.findSymbol(className) != null)
        {
            report_error("Klasa sa imenom " + className + "je vec deklarisana ("+classLocation +")", null);
            return;
        }
        
        lastClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
        ScopeEngine.InScope(SCOPE.CLASS_SCOPE);
        Tab.openScope();
       	EntityCounters.IncreaseClassCount();
        
        report_info("Definisana klasa " + className + " na liniji "+classLocation,null );
    }
    
    void ClassEnding()
    {
        if(extendedClass != null) {
            for (Obj obj : extendedClass.getType().getMembers()) {
                if(Tab.currentScope.findSymbol(obj.getName()) == null)
                      Tab.insert(obj.getKind(), obj.getName(), obj.getType());
                }
       }   
       extendedClass = null;
       
        // if (!nestedScopes.empty() && nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
        	ScopeEngine.OutOfCurrentScope();
            Tab.chainLocalSymbols(lastClass.getType());
            Tab.closeScope();
            lastClass = null;
        }          
    }
    
    void MethodDeclaration(String methodName, int methodLocation, Struct type, int typeLocation, boolean isStaticMethod)
    {
        if(Tab.currentScope.findSymbol(methodName) != null)
        {
              report_error("Naziv metode "+methodName + "je vec u upotrebi ("+methodLocation+")", null);
              return;
        }
        
        if(extendedClass != null) 
        {
           for (Obj o : extendedClass.getType().getMembers()) 
           {
               if(o.getKind() == Obj.Meth && o.getName().equals(methodName)) 
               if(o.getType().getElemType().getKind() == 6) 
                   {
                   // error
                   return;
                   }
          }
        }
        if (methodName.equals("main"))
        {
            if(type != Tab.noType)
            {
                report_error("Main mora biti tipa \"void\" ("+typeLocation + ")",null);
                return;
            }
            if (isStaticMethod)
            {
                report_error("Main ne sme biti staticka metoda ("+methodLocation+")",null);
                return;
            }

            ScopeEngine.InScope(SCOPE.MAIN_SCOPE);
            InsertMethod(methodName, methodLocation, type.getKind());
            Tab.openScope();
            lastMethType = type;
            return;
        } 
        
       if(isStaticMethod) 
       {
           InsertMethod(methodName, methodLocation, 6);
       }
       else 
       {
           InsertMethod(methodName, methodLocation, type.getKind());
       }
       
       lastMethType = type;
       ScopeEngine.InScope(SCOPE.METHOD_SCOPE);
       Tab.openScope();
    }
    
    void InsertMethod(String methodName, int methodLocation, int methodType)
    {
           if (methodType == 6 ) EntityCounters.IncreaseStaticFunctionCount();
           else EntityCounters.IncreaseFunctionCount();
           // lastType.setElementType(new Struct(methodType));
           
           Struct methType = new Struct(lastType.getKind());
           methType.setElementType(new Struct(methodType));
           
           lastMethod = Tab.insert(Obj.Meth, methodName, methType);
           report_info("Ubacena metoda "+methodName+" u tabelu simbola na liniji "+ methodLocation,null );
    }
    
    void MethodEnding()
    {
        // if (!nestedScopes.empty() &&
        // nestedScopes.peek() == SCOPE.METHOD_SCOPE ||
        // nestedScopes.peek() == SCOPE.MAIN_SCOPE || 
        // nestedScopes.peek() == SCOPE.CLASS_METHOD_SCOPE)
        {
            HandleScopeEnd(lastMethod);
            lastMethod = null;
            lastMethType = null;
        }
    }
    
    void HandleScopeEnd(Obj scopeName)
    {
    	ScopeEngine.OutOfCurrentScope();
        Tab.chainLocalSymbols(scopeName);
        Tab.closeScope();
    }

    void HandleProgramEnd(Obj progName, int programLocation)
    {
        if(Tab.find("main") == Tab.noObj)
        {
            report_error("Metoda \"main\" nije pronadjena! ("+programLocation+")", null);
        }
        
        HandleScopeEnd(progName);
    }
    
    Struct CheckTypeAndUpdateLastType(String typeName, int nameLocation)
    {
        Obj typeNode = Tab.find(typeName);
        
        if (Obj.Type == typeNode.getKind()) 
        {
        	/* if (typeName="int")
        	{
                if (typeNode.getType().getElemType()== null)
                    return lastType = typeNode.getType();
                else 
                	return lastType = typeNode.getType().getElemType();
        	}*/
        	
             curTypeName = typeName;
             return lastType = typeNode.getType();
        }
        
        lastType = Tab.noType;
        if (typeNode == Tab.noObj) 
        {
            report_error("U tabeli simbola nije pronadjen tip " + typeName + " referenciran na lokaciji "+nameLocation, null);            
            return Tab.noType;
        }
        
        report_error(" ime " + typeName + " ne predstavlja tip "+nameLocation, null);
        return Tab.noType;
    }

    Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$MJParser$actions {


int numberOfNestedFors = 0;
boolean isThisSpecified = false;
Obj backupDesig = null;
public static final int STATIC = 6;
public static final int Bool = 5;
public static final Struct boolType = new Struct(Struct.Bool);
boolean varArgs = false;
Obj lastDesignator = null;

Collection<Obj> classFields = null;
List<Struct> actParams= new LinkedList<Struct>();
    
    Stack<Integer> forStack = new Stack<Integer>();
    Stack<Integer> cond = new Stack<Integer>();
    Stack<Integer> andAdr = new Stack<Integer>();    
    Stack<Integer> orAdr = new Stack<Integer>();     
    Stack<Integer> endAdr = new Stack<Integer>();
    Stack<Integer> forAdr = new Stack<Integer>();
    Stack<Integer> endFor = new Stack<Integer>();
    Stack<Integer> noCond = new Stack<Integer>();
    Stack<Integer> desi = new Stack<Integer>();
    
    public void EnteredFor()
    {
        ++numberOfNestedFors;
    }
    public void ExitedFor()
    {
        --numberOfNestedFors;
    }
    public boolean IsNotInForLoop()
    {
        return numberOfNestedFors == 0;
    }
    
    void ReturnCallCheck(int returnLocation, Struct expr)
    {
       parser.returnHappend = true;
        
        if(parser.lastMethod == null )
        {
            parser.report_error("Return mora biti iz funkcije pozvan ("+returnLocation+")", null);
            return;
        }
        
        if (parser.lastMethType == Tab.noType)
        {
            parser.report_error("Return mora biti iz funkcije pozvan ("+returnLocation+")", null);
            return;
        }

        if (expr != null && expr.getKind() != parser.lastMethType.getKind())
        {
            parser.report_error("Funkcija vraca tip "+ UtilFunctions.StructToTypeName(expr) +" A mora vracati tip "+ 
            		UtilFunctions.StructToTypeName(parser.lastMethod.getType()) + "("+returnLocation+")", null);
        }
    }
    
int [] correctObjTypes = {Obj.Var, Obj.Elem, Obj.Fld };
int [] correctStructTypes = {Struct.Int, Struct.Char, Struct.None};
    
    public boolean IsObjectVarElemOrFieldError(Obj designator, int designatorLocation)
    {
        if (designator == null)
            return false;
        if (!IntStream.of(correctObjTypes).anyMatch(x -> x == designator.getKind()))
        {
            parser.report_error(" " + designator.getName() + 
            " mora biti  promenljiva, element niza ili polje unutar objekta ("+ designatorLocation+")", null);
            return false;
        }
        return true;
    }
    
    public boolean IsStructIntCharOrNone(Struct expr, int exprLocation)
    {
        if (!IntStream.of(correctStructTypes).anyMatch(x -> x == expr.getKind()))
        {       
            parser.report_error(" " + expr.getKind() + " mora biti tipa int, char ili bool. ("+exprLocation+")", null);                
            return false;
        }
        return true;
    }
    
    public void CorrectTypesForFunctionCalls(Obj designator, int designatorLocation)
    {
        if (IsObjectVarElemOrFieldError(designator, designatorLocation) &&
            IsStructIntCharOrNone(designator.getType(), designatorLocation))
         {
        	EntityCounters.IncreaseFunctionCallsCount(); 
         }
    }
    
    public boolean IsAssignable(Obj design, Struct expr)
    {
        if(expr.assignableTo(design.getType())) // If expr is assignable to design
        {
            return true;
        }
        
        if( expr.getKind() != design.getType().getKind() || // If they are not same Struct type
            expr.getElemType() != design.getType().getElemType() || // If they are not same Struct.ElementType
            expr.getNumberOfFields() != design.getType().getNumberOfFields() || // If they don't have same params of fields
            expr.getMembers() == design.getType().getMembers()) // If they don't have same type of fields
        {
            return false;
        }
  
        if (design.getType().getKind() == Struct.Array && // If designator is Struct.Array
            expr.getElemType() == null && // Expression is not array
            !expr.assignableTo(design.getType().getElemType())) // if expr is not assignable to type of designator elements
        {
            return false;
        }
       
        return true;
    }
    
    Obj GetResultIfBothInt(Obj result, int resultLocation, Struct term)
    {
        /*if (!IsObjectVarElemOrFieldError(result , resultLocation))
        {
            return Tab.noObj;
        }*/
        
        if (result.getType().getKind() == Struct.Int && term.getKind() == Struct.Int)
        {
            return result;
        }
        
       parser.report_error("Poslali ste tipove" + UtilFunctions.StructToTypeName(parser.lastMethod.getType()) +
            " i " + UtilFunctions.StructToTypeName(term) + " a moraju biti int ("+resultLocation+")", null);
        return Tab.noObj;
    }
    
    void SaveExtendedClassMembers(Struct extendsClass)
    {
        if(extendsClass != null && extendsClass != Tab.noType && extendsClass.getKind() == Struct.Class) 
        {
            for (Obj obj : extendsClass.getMembers()) 
            {
                if(Tab.currentScope.findSymbol(obj.getName()) == null)
                      Tab.insert(obj.getKind(), obj.getName(), obj.getType());
            }
        }
    }
    
    boolean CheckIfArgumentsMatch(Obj designator, int designatorLocation, int args, int argsLocation)
    {
        if(designator.getKind() != Obj.Meth)
        {
              parser.report_error("Funkcija mora biti deklarisana pre poziva ("+designatorLocation+")", null);
              return false;
        }  
                                
        if(args != designator.getLevel()) 
        {
                parser.report_error(" Broj argumenata funkcije nije dobar."+ designator.getName() +" ("+argsLocation+")", null);
                return false;
        }
        
        for(int i = 0; i < args; i++) 
        {
             Obj o = ((Obj) designator.getLocalSymbols().toArray()[i]);
             Struct s = actParams.get(actParams.size() - (args - i)); // sta ce aoba
            // if(!(o.getType().getKind() != Struct.Class && o.getType().getKind() == s.getKind() && o.getType().getElemType() == s.getElemType() && o.getType().getNumberOfFields() == s.getNumberOfFields())) if(!o.getType().compatibleWith(s)) 
             if (!o.getType().compatibleWith(s) && !IsAssignable(o,s)) 
             {
                 parser.report_error(" _Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva. ("+argsLocation+")", null);
                 return false;
             }
        }
        EntityCounters.IncreaseFunctionCallsCount();
        return true;
    }
    
    public boolean ThisIsSpecified(String name, int nameLocation)
    {
        if(!"this".equals(name)) return false;
     
        if(parser.lastMethod != null) 
        {
          if(!ScopeEngine.IsInClassScope() || parser.lastMethod.getType().getElemType().getKind() == STATIC)
          {
               parser.report_error("This se moze navoditi samo u nestatickim metodama ("+nameLocation+")", null);
          }
          
          isThisSpecified = true;
       } 
       return true;
    }                       

  private final MJParser parser;

  /** Constructor */
  CUP$MJParser$actions(MJParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$MJParser$do_action(
    int                        CUP$MJParser$act_num,
    java_cup.runtime.lr_parser CUP$MJParser$parser,
    java.util.Stack            CUP$MJParser$stack,
    int                        CUP$MJParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MJParser$result;

      /* select the action based on the action number */
      switch (CUP$MJParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // MulopRight ::= ASSIGN_MOD 
            {
              Integer RESULT =null;
		 RESULT = Code.rem ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopRight",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // MulopRight ::= ASSIGN_DIV 
            {
              Integer RESULT =null;
		 RESULT = Code.div ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopRight",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // MulopRight ::= ASSIGN_MUL 
            {
              Integer RESULT =null;
		 RESULT = Code.mul ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopRight",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // MulopLeft ::= MOD 
            {
              Integer RESULT =null;
		 RESULT = Code.rem ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopLeft",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // MulopLeft ::= DIV 
            {
              Integer RESULT =null;
		 RESULT = Code.div ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopLeft",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // MulopLeft ::= MUL 
            {
              Integer RESULT =null;
		 RESULT = Code.mul ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopLeft",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // Mulop ::= MulopRight 
            {
              Integer RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // Mulop ::= MulopLeft 
            {
              Integer RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // AddopRight ::= ASSIGN_SUB 
            {
              Integer RESULT =null;
		 RESULT = Code.sub ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopRight",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // AddopRight ::= ASSIGN_ADD 
            {
              Integer RESULT =null;
		 RESULT = Code.add ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopRight",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // AddopLeft ::= SUB 
            {
              Object RESULT =null;
		 RESULT = Code.sub ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopLeft",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // AddopLeft ::= ADD 
            {
              Object RESULT =null;
		 RESULT = Code.add ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopLeft",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // Addop ::= AddopRight 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // Addop ::= AddopLeft 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // Relop ::= LESS_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.le ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // Relop ::= LESS 
            {
              Integer RESULT =null;
		 RESULT = Code.lt ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // Relop ::= GREATER_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.ge ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // Relop ::= GREATER 
            {
              Integer RESULT =null;
		 RESULT = Code.gt ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // Relop ::= NOT_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.ne ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // Relop ::= EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.eq ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // Assignop ::= MulopRight 
            {
              Integer RESULT =null;
		int mulOpleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int mulOpright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer mulOp = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = mulOp ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignop",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // Assignop ::= AddopRight 
            {
              Integer RESULT =null;
		int addOpleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int addOpright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer addOp = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = addOp ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignop",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // Assignop ::= ASSIGN 
            {
              Integer RESULT =null;
		 RESULT = 0 ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignop",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // Factor ::= LPAREN Expression RPAREN 
            {
              Obj RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 RESULT = new Obj(Obj.Con, "", expr); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // Factor ::= NEW Type NT$16 LBRACK Expression RBRACK 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$16
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		  
                if(expr.getKind() == Struct.Int) 
                    RESULT = new Obj(Obj.NO_VALUE, "", new Struct(Struct.Array, type));  
                else { 
                    parser.report_error(": tip expr mora biti int", typeleft); 
                    RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType); 
                } 
                 
                Code.put(Code.newarray); 
                Code.put(type == Tab.charType ? 0  : 1);  
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // NT$16 ::= 
            {
              Obj RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                Obj obj = Tab.noObj; 
                if(classFields != null) 
                	for (Obj o : classFields) { 
                        if(o.getName().equals(lastDesignator.getName())) 
                            obj = o;
                    }     
                else  { 
                	obj = Tab.find(lastDesignator.getName());  
                } 
                                 
                if(obj != Tab.noObj) 
                	if(obj.getType().getElemType() != type) { 
                        parser.report_error("Ne podudaraju se tipovi." +type+ "  i "+obj.getType()+ " + "+ obj.getType()+"("+typeleft+")",null  ); 
                        RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType); 
                    }
                else {  
                	RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                }  
                    
                classFields = null; 
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$16",74, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // Factor ::= NEW Type 
            {
              Obj RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                if(type.getKind()==Struct.Class)
                	if(lastDesignator.getType().getKind() != type.getKind()) {
                        parser.report_error(": tipovi se ne podudaraju ", typeleft);
                        RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                  } else
                        RESULT = new Obj(Obj.NO_VALUE, "", type);
                else
                {
                	parser.report_error("tip prilikom pravljenja objekta mora biti unutrasnja klasa",typeleft);
                
                }
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // Factor ::= BOOL 
            {
              Obj RESULT =null;
		int booleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int booright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean boo = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
            Obj value = new Obj(Obj.Con, "" + boo, new Struct (Struct.Bool)); 
            value.setAdr(boo? 1:0);
            Code.load(value);
            RESULT = value;  
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // Factor ::= CHAR 
            {
              Obj RESULT =null;
		int chrleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int chrright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		char chr = (char)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
            Obj value = new Obj(Obj.Con, "" + chr, Tab.charType); 
            value.setAdr(chr);
            Code.load(value);
            RESULT = value; 
             
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // Factor ::= NUMBER 
            {
              Obj RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer num = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
            Obj value = new Obj(Obj.Con, "" + num, Tab.intType); 
            value.setAdr(num.intValue());
            Code.load(value);
            RESULT = value;  
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // Factor ::= Designator LPAREN ActParsListOpt RPAREN 
            {
              Obj RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer params = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
            	EntityCounters.IncreaseFunctionCallsCount();
                if (designator.getKind() != Obj.Meth)
                { 
                   
                    RESULT = Tab.noObj; 
                    
                    parser.report_error("Funkcija nije deklarisana",designatorleft);
                } 
                else 
                {
                    RESULT = new Obj(Obj.Meth,  
                        designator.getName(),  
                        new Struct(designator.getType().getKind()),  
                        designator.getAdr(),  
                        designator.getLevel());    
                }
                 
                if(RESULT != Tab.noObj) { 
                    if(params == RESULT.getLevel() ) { 
                        boolean ggflag = false;
                        for(int i = 0; i < params; i++) { 
                            Obj o = ((Obj) designator.getLocalSymbols().toArray()[i]);   
                             Struct s = actParams.get(actParams.size() - (params - i)); 
                             if (!o.getType().compatibleWith(s) && !IsAssignable(o,s)) 
                                    ggflag = true; 
                        } 
                        
                        if(ggflag)
                            parser.report_error(" __Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva.", paramsleft); 
                        else { 
                            if(RESULT.getType() == Tab.noType) 
                            	parser.report_error(" Funkcija nema povratnu vrednost.", paramsleft); 
                            else                            
                            	RESULT = new Obj(Obj.Con, "", RESULT.getType()); 
                            
                            int destAdr = designator.getAdr() - Code.pc;
                            Code.put(Code.call);
                            Code.put2(destAdr);
                        }
                    } else {
                        parser.report_error(" Broj argumenata funkcije nije dobar."+ RESULT.getName(), paramsleft);                        
                    }
                    for(int i = 0; i < params; i++)
                            actParams.remove(actParams.size() - 1);
                }
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // Factor ::= Designator 
            {
              Obj RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		  RESULT = designator;
                if(designator.getKind() == Obj.Con)
                    Code.load(designator);
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // MulopFactorList ::= Factor 
            {
              Obj RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj result = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = result; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopFactorList",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // MulopFactorList ::= MulopFactorList NT$15 MulopLeft Factor 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$15
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int mflleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int mflright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj mfl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int factleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int factright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj fact = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
                    if(fact.getKind() != Obj.Con)  
                            Code.load(fact); 
                        
                        Code.put((int)op);
                    if(mfl.getType().getKind() != Struct.Int) 
                        { 
                            parser.report_error(" " + mfl.getName() + "mora biti int ", mflleft);
                            RESULT = Tab.noObj; 
                         }
                     else{
                        if(fact.getType().getKind() != Struct.Int)
                        {
                            parser.report_error(" " + fact.getName() + "mora biti int ", factleft); // lrbo
                            RESULT = Tab.noObj;
                        }
                        else{
                        RESULT = new Obj(Obj.Con, "rezultat mnozenja", Tab.intType); // sd 
                           }
                      }
                        /*RESULT = Tab.noObj;
                        if (GetResultIfBothInt(mfl, mflleft, fact.getType()) != Tab.noObj)
                        {
                            RESULT = new Obj(Obj.Con, "Multiplication result", Tab.intType); 
                        }  */
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopFactorList",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // NT$15 ::= 
            {
              Obj RESULT =null;
		int mflleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int mflright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj mfl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                    if(mfl.getKind() != Obj.Con) 
                            Code.load(mfl); 
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$15",73, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // Term ::= MulopFactorList 
            {
              Obj RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj result = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = result; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // Term ::= MulopFactorList NT$14 MulopRight Term 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$14
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int mflleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int mflright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj mfl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int termleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int termright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj term = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
            if(term.getKind() != Obj.Con)
                    Code.load(term);
                    
                Code.put((int)op);   
                Code.store(mfl); 
            if(mfl.getKind() != Obj.Var && mfl.getKind()!= Obj.Fld && mfl.getKind() != Obj.Elem)// hj 
                    {
            	RESULT = Tab.noObj;
            	
            	parser.report_error(" " + mfl.getName() + " mora oznacavati  promenljivu, element niza ili polje objekta unutrasnje objekta", mflleft);
                    
                    }
                else{
                    if(mfl.getType().getKind() == Struct.Int)
                        {
                    	 
                        if(term.getType().getKind() != Struct.Int)
                       {
                           parser.report_error(" " + term.getName() + "mora biti int ", termleft);
                           RESULT = Tab.noObj; 
                       }
                       else
                           RESULT = mfl; 
                       
                    	
                        
                        }
                    else{
                    	
                    		RESULT = Tab.noObj;
                    	
                        
                        parser.report_error(" " + mfl.getName() + "mora biti int ", mflleft); 
                    }
                }
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // NT$14 ::= 
            {
              Obj RESULT =null;
		int mflleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int mflright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj mfl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

        	if(mfl.getKind() != Obj.Con) 
        	{
        	if(mfl.getKind() == Obj.Elem) { 
                    Code.put(Code.dup2); 
                    Code.put(Code.dup2);
                }
        		Code.load(mfl);  
        	}
                
        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$14",72, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // AddopTermList ::= Term 
            {
              Obj RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj result = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = result; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopTermList",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // AddopTermList ::= AddopTermList NT$13 AddopLeft Term 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int atlleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int atlright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj atl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int termleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int termright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj term = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                     if(atl.getType().getKind() != Struct.Int)
                        {
                            parser.report_error(" " + atl.getName() + "mora biti int ", atlleft);
                            RESULT = Tab.noObj;
                         }
                     else{
                        if(term.getType().getKind() != Struct.Int)
                        {
                        	RESULT = Tab.noObj;
                        	
                        
                            parser.report_error(" " + term.getName() + "mora biti int ", termleft);
                            
                        }
                        else{
                        RESULT = new Obj(Obj.Con, "rezultat sabiranja", Tab.intType);
                           }
                      }
                      if(term.getKind() != Obj.Con)
                            Code.load(term);
                        
                        Code.put((int)op);
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopTermList",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // NT$13 ::= 
            {
              Obj RESULT =null;
		int atlleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int atlright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj atl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
if(atl.getKind() != Obj.Con) Code.load(atl);
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$13",71, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // AddopTermCombList ::= AddopTermList 
            {
              Struct RESULT =null;
		int addoleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int addoright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj addo = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                        if(addo != null)
                        {
                        RESULT = addo.getType(); 
                        if(addo.getKind() == Obj.Var || addo.getKind() == Obj.Elem) 
                            Code.load(addo);
                        }
                        else
                        RESULT = Tab.noType;
                        
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopTermCombList",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // AddopTermCombList ::= AddopTermList NT$12 AddopRight AddopTermCombList 
            {
              Struct RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (Struct) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int addoleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int addoright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj addo = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int atclleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int atclright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct atcl = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                        Code.put((int)op);   
                            Code.store(addo);   
                            Code.load(addo);  
                        if(addo.getKind() != Obj.Var && addo.getKind()!= Obj.Fld && addo.getKind() != Obj.Elem)  
                                {  
                                parser.report_error(" " + addo.getName() + " mora oznacavati  promenljivu, element niza ili polje objekta unutrasnje objekta", addoleft);  
                                RESULT = Tab.noType;   
                                }  
                            else{
                                if(addo.getType().getKind() != Struct.Int)  // jj 
                                    {   
                                    parser.report_error(" mora biti int ", addoleft);  
                                    RESULT = Tab.noType;  
                                    }
                                else{
                                     if(atcl.getKind() != Struct.Int)   // care !! 
                                    {
                                        parser.report_error(" mora biti int ", atclleft);  
                                        RESULT = Tab.noType;  
                                    }
                                    else{
                                        RESULT = addo.getType(); 
                                    }
                                }
                            }
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopTermCombList",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // NT$12 ::= 
            {
              Struct RESULT =null;
		int addoleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int addoright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj addo = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                    if(addo.getKind() == Obj.Elem) {
                                Code.put(Code.dup2);
                                Code.put(Code.dup2); 
                            }
                            if(addo.getKind() != Obj.Con) 
                    Code.load(addo); 
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$12",70, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // Expression ::= AddopTermCombList 
            {
              Struct RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct result = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                RESULT = result;
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expression",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // Expression ::= SUB AddopTermCombList 
            {
              Struct RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct result = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
                RESULT = result;
                
                if (result.getKind() != Struct.Int)
                {
                     RESULT = Tab.noType;  
                     parser.report_error("izraz nakon minusa mora biti tipa int", resultleft); // 
                }
                Code.put(Code.neg);
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expression",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // CondFact ::= Expression Relop Expression 
            {
              Object RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct exp1 = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct exp2 = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
            if(!exp1.compatibleWith(exp2)) {
                    if(!(exp1.getKind() == exp2.getKind() && exp1.getElemType() == exp2.getElemType() && exp1.getNumberOfFields() == exp2.getNumberOfFields())) 
                        parser.report_error(" Tipovi nisu kompatibilni", exp1left); 
                }
                else {
                    if(exp1.getKind() == Struct.Array || exp1.getKind() == Struct.Class) { 
                        if(op != Code.eq && op != Code.ne) 
                            parser.report_error("Uz promenljive tipa klase ili niza mogu se koristiti samo != i ==", exp1left); 
                    }
                Code.putFalseJump(op, 0);    // dd
                andAdr.push(Code.pc - 2);   
                }
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // CondFact ::= Expression 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct exp = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
            if(exp.getKind() != Struct.Bool) 
                    parser.report_error("Exp mora biti tipa bool", expleft);
            Code.loadConst(0); //expr je bool i samo proverimo da li je jednako sa 0
                Code.putFalseJump(Code.ne, 0); // dummy //ako nije tacan uslov odmah preskacemo AND uslove i idemo na OR ako ima
                andAdr.push(Code.pc - 2); 
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // CondTerm ::= CondFact 
            {
              Object RESULT =null;
		
                        Code.putJump(0); 
                        orAdr.push(Code.pc - 2);                    
                        while(!andAdr.empty()) 
                            Code.fixup(andAdr.pop()); 
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // CondTerm ::= CondTerm AND CondFact 
            {
              Object RESULT =null;
		
                        Code.putJump(0);  

                        orAdr.push(Code.pc - 2);                     
                        while(!andAdr.empty())   
                            Code.fixup(andAdr.pop());
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // Condition ::= CondTerm 
            {
              Object RESULT =null;
		
        Code.putJump(0); 
        endAdr.push(Code.pc - 2);
    
        while(!orAdr.empty()) 
            Code.fixup(orAdr.pop()); 
                        
        
        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // Condition ::= Condition OR CondTerm 
            {
              Object RESULT =null;
		
        
        Code.putJump(0); 
        endAdr.push(Code.pc - 2);
    
        while(!orAdr.empty()) 
            Code.fixup(orAdr.pop());
                        
        
        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // DesignatorIdent ::= LBRACK NT$11 Expression RBRACK 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Object brack = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		  
            if(expr.getKind() != Struct.Int)
                parser.report_error(" tip u zagradama niza mora biti int a vama je :"+ expr.getKind(),exprleft);
              else {  
                     {  // res null
                        if(backupDesig != null)  
                            RESULT = lastDesignator = new Obj(Obj.Elem, backupDesig.getName(), backupDesig.getType().getElemType(), backupDesig.getAdr(), backupDesig.getLevel());
                        else
                            RESULT = lastDesignator = Tab.noObj; 
                    }//
                }
                
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorIdent",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // NT$11 ::= 
            {
              Obj RESULT =null;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object brack = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 
            if(lastDesignator.getType().getKind() != Struct.Array) {
                    parser.report_error(": " + lastDesignator.getName() + " nije niz", brackleft);
                    RESULT = Tab.noObj; 
            } else
                   backupDesig = lastDesignator;
                   
                   Code.load(lastDesignator);
             
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$11",69, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // DesignatorIdent ::= DOT IDENT 
            {
              Obj RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
            if(!(isThisSpecified ||   (lastDesignator != null && (lastDesignator.getKind() == Obj.Elem || lastDesignator.getKind() == Obj.Var || lastDesignator.getKind() == Obj.Fld )&& lastDesignator.getType().getKind() == Struct.Class))) {
                        if(lastDesignator.getKind() == Obj.Type) { 
                            if(isThisSpecified) {
                                Obj o = Tab.currentScope().getOuter().findSymbol(name); 
                                if(o != null) {
                                    if(o.getKind() != Obj.Meth) { 
                                        parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);  
                                        lastDesignator = Tab.noObj;  
                                    } else if(o.getType().getElemType().getKind() != STATIC) {
                                        parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);  
                                        lastDesignator = Tab.noObj;   
                                    } else {
                                        lastDesignator = o;  
                                     }
                                }
                                else { // ako koristimo this a nema ga u toj klasi, proveravamo da li je klasa izvedena
                                      // i ima li u osnovnoj onda
                                    Obj acquired = null;
                                    if(parser.extendedClass != null) {
                                         for (Obj o1 : parser.extendedClass.getType().getMembers()) {
                                            if(o1.getName().equals(name))
                                            	acquired = o1;
                                        }
                                    }
                                    if(acquired != null) {
                                        if(acquired.getKind() != Obj.Meth) {
                                             parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else if(acquired.getType().getElemType().getKind() != 6) {
                                             parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj; 
                                        } else { 
                                            lastDesignator = acquired;
                                         }
                                    } else {
                                        parser.report_error("(this." + name + ") nije nadjeno", nameleft);
                                         lastDesignator = Tab.noObj;
                                    } 
                                } 
                            } else { 
                                Obj acquired = null;
                                if(lastDesignator != null) {
                                    for (Obj o : lastDesignator.getType().getMembers()) { //pronalazimo u klasi ovaj naziv
                                         if(o.getName().equals(name)) 
                                        	 acquired = o;
                                    }
                                    if(acquired != null){  
                                        if(acquired.getKind() != Obj.Meth) {  
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);   
                                            lastDesignator = Tab.noObj; 
                                         } else if(acquired.getType().getElemType().getKind() != 6) {  
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft); 
                                            lastDesignator = Tab.noObj;  
                                        } else {
                                            lastDesignator = acquired; 
                                         }
                                     } else {
                                        parser.report_error("(" + lastDesignator.getName() + "." + name + ") nije nadjeno", nameleft);  
                                        lastDesignator = Tab.noObj;
                                    }
                                }
                            }
                             isThisSpecified = false;
                            RESULT = lastDesignator;
                        }
                        else {
                            parser.report_error(": " + lastDesignator.getName() + " nije klasa", nameleft);
                              lastDesignator = Tab.noObj;
                        }
                } else {
                     if(isThisSpecified) {
                        Obj o = Tab.currentScope().getOuter().findSymbol(name);
                        if(o != null) {
                              if(o.getType().getKind() == Struct.Array) {
                                lastDesignator = o;
                                if(lastDesignator != null && lastDesignator.getType() != null)
                                     classFields = lastDesignator.getType().getMembers();
                             }
                             lastDesignator = o;
                         }
                        else { // ako koristimo this a nema ga u toj klasi, proveravamo da li je klasa izvedena
                              // i ima li u osnovnoj onda
                             Obj acquired = null;
                              if(parser.extendedClass != null) {
                                for (Obj o1 : parser.extendedClass.getType().getMembers()) {
                                    if(o1.getName().equals(name))
                                    	acquired = o1;
                                }
                            }
                              if(acquired != null) {  
                                 if(acquired.getType().getKind() == Struct.Array) {   
                                      lastDesignator = acquired;  
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                          classFields = lastDesignator.getType().getMembers();  
                                }
                                   lastDesignator = acquired;
                            } else
                                 parser.report_error("(this." + name + ") nije nadjeno", nameleft);  
                        }
                    } else {
                        Obj acquired = null;
                        if(lastDesignator != null) {
                            for (Obj o : lastDesignator.getType().getMembers()) { //pbb ronalazimb o u kb lasi ov vajv  naziv v
                                if(o.getName().equals(name))
                                	acquired = o;
                            }   
                            if(acquired == null) 
                            	 parser.report_error("(" + lastDesignator.getName() + "." + name + ") nije nadjeno", nameleft);   
                            else
                            {
                                if(acquired.getType().getKind() == Struct.Array) { 
                                     lastDesignator = acquired;
                                    if(lastDesignator != null && lastDesignator.getType() != null) 
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                lastDesignator = acquired; 
                            }
                               
                        }  
                    }
                    isThisSpecified = false;    
                    RESULT = lastDesignator;
                } 
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorIdent",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // DesignatorListOpt ::= 
            {
              Obj RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorListOpt",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // DesignatorListOpt ::= DesignatorListOpt DesignatorIdent 
            {
              Obj RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj val = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
                        if (val != null) RESULT = val;
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorListOpt",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // Designator ::= IDENT NT$10 DesignatorListOpt 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int resleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj res = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 if(res != null) RESULT = res; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // NT$10 ::= 
            {
              Obj RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                  if(name.equals("this")) {
                    if(parser.lastMethod != null) {
                        if(ScopeEngine.IsInGlobalScope() || !ScopeEngine.IsInClassMethodScope() ||
                        parser.lastMethod.getType().getElemType().getKind() == STATIC)  
                        {  
                         parser.report_error("this moze postojati samo u nestatickim metodama", nameleft);
                         }   
                            isThisSpecified = true;
                    }
                  } else {  
                    Obj o = Tab.currentScope.findSymbol(name);
                    
                    if(o == null) {
                        Obj o1 = Tab.find(name);
                        if(o1 != Tab.noObj) {     
                            if(o1.getType().getKind() == Struct.Array)
                                lastDesignator = o1;
                    }
                    else {
                            Obj acquired = null;  
                            if(parser.extendedClass != null) {
                                for (Obj o2 : parser.extendedClass.getType().getMembers()) {
                                    if(o2.getName().equals(name))
                                    	acquired = o2;  
                                }
                            }
                            if(acquired != null) {
                                if(acquired.getType().getKind() == Struct.Array) {  
                                    lastDesignator = acquired;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                o1 = acquired;
                            } else   
                                parser.report_error("" + name + "nije nadjeno "+nameleft,null );
                        }  
                        lastDesignator = o1;
                        RESULT = o1;
                    }
                    else {
                      if(parser.lastMethod != null) {
                        if(o.getType().getKind() == Struct.Array)
                            lastDesignator = o;                       
                      }   
                        RESULT = lastDesignator = o;
                    }  
                  }
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$10",68, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // ActPars ::= Expression 
            {
              Integer RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                actParams.add(expr);
                RESULT = 1;
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // ActPars ::= ActPars COMMA Expression 
            {
              Integer RESULT =null;
		int argsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer args = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                actParams.add(expr);
                RESULT = args+1;
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // ActParsListOpt ::= 
            {
              Integer RESULT =null;
		 RESULT = 0; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActParsListOpt",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // ActParsListOpt ::= ActPars 
            {
              Integer RESULT =null;
		int argsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer args = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = args; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActParsListOpt",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // DesignatorStatement ::= Designator Assignop error 
            {
              Object RESULT =null;
		 parser.ReportError("Doslo je do prilikom dodele vrednosti pre znaka ;"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // DesignatorStatement ::= Designator DEC 
            {
              Object RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		  
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if(designator.getType().getKind() != Struct.Int)
                                {
                                    parser.report_error("Prilikom INC " + designator.getName() + " mora biti int ", designatorleft);
                                }
                                else
                                {
                                 if(designator.getKind() == Obj.Elem)
                                Code.put(Code.dup2);
                                    Code.load(designator);
                                    Code.put(Code.const_1);
                                    Code.put(Code.sub);
                                    Code.store(designator);
                                }
                            }
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // DesignatorStatement ::= Designator INC 
            {
              Object RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		  
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if(designator.getType().getKind() != Struct.Int)
                                {
                                    parser.report_error("Prilikom INC " + designator.getName() + " mora biti int ", designatorleft);
                                }else
                                {
                                	if(designator.getKind() == Obj.Elem)
                                		Code.put(Code.dup2);
			                        Code.load(designator);
			                        Code.put(Code.const_1);
			                        Code.put(Code.add);
			                        Code.store(designator);
	                            }
                            }
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // DesignatorStatement ::= Designator LPAREN ActParsListOpt RPAREN 
            {
              Object RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int argsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer args = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
                            if (CheckIfArgumentsMatch(designator, designatorleft, args, argsleft))
                            {
                                int destAdr = designator.getAdr() - Code.pc;
                                Code.put(Code.call);
                                Code.put2(destAdr);
                                if(designator.getType().getKind() != Struct.None)
                                Code.put(Code.pop);
                            }
                        
                            for (int i =0; designator!= Tab.noObj &&  i < args ; i++)
                                actParams.remove(actParams.size() - 1);
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // DesignatorStatement ::= Designator Assignop NT$9 Expression 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                            	 if (!IsAssignable(designator, expr))
                                 {
                                     parser.report_error("Nemoguce je dodeliti vrednost tipa "+UtilFunctions.StructToTypeName(expr) + " variabli tipa " +UtilFunctions.StructToTypeName(designator.getType())+"("+designatorleft+")" ,null );
                                 }
                            }
                            
                            if((int)op != 0) 
                                Code.put((int)op); 
                            
                            Code.store(designator);
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // NT$9 ::= 
            {
              Object RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                        if((int)op != 0) { 
                                if(designator.getKind() == Obj.Elem)
                                    Code.put(Code.dup2);
                                Code.load(designator); 
                            }
                        
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$9",67, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // CondOpt ::= 
            {
              Object RESULT =null;
		 endAdr.push(-1); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondOpt",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // CondOpt ::= error 
            {
              Object RESULT =null;
		 parser.ReportError("Doslo je do greske u logickom iskazu unutar FOR(...) konstrukcije"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondOpt",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // CondOpt ::= Condition 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondOpt",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // DesignatorOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorOpt",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // DesignatorOpt ::= error 
            {
              Object RESULT =null;
		 parser.ReportError("Doslo je do greske unutar FOR(...) konstrukcije"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorOpt",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // DesignatorOpt ::= DesignatorStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorOpt",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // NumOpt ::= 
            {
              Integer RESULT =null;
		 RESULT = 5; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NumOpt",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // NumOpt ::= COMMA NUMBER 
            {
              Integer RESULT =null;
		int widthleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int widthright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer width = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = width; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NumOpt",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // StatementIfElse ::= IF LPAREN error RPAREN Statement ELSE Statement 
            {
              Object RESULT =null;
		 parser.ReportError("Doslo je do greske u logickom izrazu unutar IF-ELSE konstrukcije"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementIfElse",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // StatementIfElse ::= IF LPAREN error RPAREN Statement 
            {
              Object RESULT =null;
		 parser.ReportError("Doslo je do greske u logickom izrazu unutar IF konstrukcije"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementIfElse",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // StatementIfElse ::= IF LPAREN Condition RPAREN Statement ELSE NT$8 Statement 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 
                    Code.fixup(endAdr.pop());
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementIfElse",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // NT$8 ::= 
            {
              Object RESULT =null;

                    Code.pc += 3; 
                    Code.fixup(endAdr.pop());
                    Code.pc -= 3;
                    
                    Code.putJump(0); // dummy
                    endAdr.push(Code.pc - 2);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$8",66, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // StatementIfElse ::= IF LPAREN Condition RPAREN Statement 
            {
              Object RESULT =null;
		 
                    Code.fixup(endAdr.pop());
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementIfElse",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // Statement ::= LBRACE StatementListOpt RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // Statement ::= PRINT LPAREN Expression NumOpt RPAREN SEMI 
            {
              Object RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int widthleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int widthright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer width = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
                if (IsStructIntCharOrNone(expr, exprleft))
                {
                	EntityCounters.IncreaseFunctionCallsCount(); 
                     if (expr.getKind() == Struct.Char ) {
                    Code.loadConst(width);
                    Code.put(Code.bprint);
                 }
                 
                 else{
                    Code.loadConst(width);
                    Code.put(Code.print);
                 }
                }
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // Statement ::= READ LPAREN Designator RPAREN SEMI 
            {
              Object RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
                    CorrectTypesForFunctionCalls(designator, designatorleft);
                    if (designator.getType() == Tab.charType ) 
                        Code.put(Code.bread);           
                     else
                        Code.put(Code.read);
                    Code.store(designator);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // Statement ::= RETURN Expression SEMI 
            {
              Object RESULT =null;
		int retleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int retright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object ret = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
                    ReturnCallCheck(retleft, expr);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // Statement ::= RETURN SEMI 
            {
              Object RESULT =null;
		int retleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int retright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object ret = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
                    ReturnCallCheck(retleft, null);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // Statement ::= CONTINUE SEMI 
            {
              Object RESULT =null;
		int semleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int semright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object sem = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                    if (IsNotInForLoop())
                        parser.report_error("Continue naredba se moze izvrsiti samo iz unutar for petlje ", semleft);
                    else
                        Code.putJump(desi.peek());
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // Statement ::= BREAK SEMI 
            {
              Object RESULT =null;
		int semleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int semright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object sem = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
                if (IsNotInForLoop())
                        parser.report_error("Breakovati se moze samo iz unutar for petlje ", semleft);
                    else
                        Code.putJump(endFor.pop() - 1);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // Statement ::= FOR LPAREN DesignatorOpt SEMI NT$3 CondOpt NT$4 SEMI NT$5 DesignatorOpt NT$6 RPAREN NT$7 Statement 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 
                    
                    forStack.pop();
                    Code.putJump(desi.pop());
                    if(endAdr.peek() != -1)
                        Code.fixup(endAdr.pop());
                    else {
                        Code.fixup(noCond.pop());
                        endAdr.pop();
                    }
                    ExitedFor();
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-13)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // NT$7 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
 
                    forStack.push(1); 
                    Code.fixup(forAdr.pop());
                    EnteredFor();
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$7",65, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // NT$6 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
 
                    Code.putJump(cond.pop());
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$6",64, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // NT$5 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

                    desi.push(Code.pc);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$5",63, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // NT$4 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

                    Code.putJump(0);
                    forAdr.push(Code.pc - 2);
                    
                    if(endAdr.peek() != -1) 
                        endFor.push(endAdr.peek()); 
                    else {
                        Code.putJump(0);
                        noCond.push(Code.pc - 2);
                        endFor.push(noCond.peek());
                    }
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$4",62, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // NT$3 ::= 
            {
              Object RESULT =null;

                    cond.push(Code.pc);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$3",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // Statement ::= StatementIfElse 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // Statement ::= DesignatorStatement SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // StatementListOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementListOpt",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // StatementListOpt ::= StatementListOpt Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementListOpt",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // FormalParamDecl ::= Type IDENT 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
                        parser.VariableDeclaration(name, nameleft, Obj.Var, parser.lastType);
                        EntityCounters.IncreaseFormalParamsCount();
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamDecl",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // FormalParamDecl ::= Type IDENT LBRACK RBRACK 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
                        parser.VariableDeclaration(name, nameleft, Obj.Var, new Struct(Struct.Array, parser.lastType));
                        EntityCounters.IncreaseFormalParamsCount(); 
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamDecl",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // FormalParamList ::= FormalParamDecl 
            {
              Integer RESULT =null;
		 RESULT = 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // FormalParamList ::= error COMMA FormalParamDecl 
            {
              Integer RESULT =null;
		 parser.ReportError("Doslo je do greske prilikom deklaracije formalnog parametra funkcije pre znaka \",\""); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // FormalParamList ::= FormalParamList COMMA FormalParamDecl 
            {
              Integer RESULT =null;
		int numberOfParamsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int numberOfParamsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer numberOfParams = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 RESULT = numberOfParams + 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // FormParamsOpt ::= 
            {
              Integer RESULT =null;
		 RESULT = 0; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParamsOpt",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // FormParamsOpt ::= error 
            {
              Integer RESULT =null;
		 parser.ReportError("Doslo je do greske prilikom deklaracije formalnog parametra funkcije pre znaka \")\""); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParamsOpt",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // FormParamsOpt ::= VarArgs 
            {
              Integer RESULT =null;
		 RESULT = 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParamsOpt",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // FormParamsOpt ::= FormalParamList VarArgs 
            {
              Integer RESULT =null;
		int numOfParamsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int numOfParamsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer numOfParams = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 RESULT = numOfParams+1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParamsOpt",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // FormParamsOpt ::= FormalParamList 
            {
              Integer RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer result = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = result; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParamsOpt",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // VarArgs ::= COMMA Type DOT DOT DOT IDENT 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                parser.lastType = new Struct(Struct.Array, parser.lastType);
                parser.VariableDeclaration(name, nameleft, Obj.Var, parser.lastType);    
                EntityCounters.IncreaseFormalParamsCount();
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarArgs",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // TypeVoid ::= VOID 
            {
              Struct RESULT =null;
		 RESULT = parser.lastType = Tab.noType;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("TypeVoid",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // TypeVoid ::= Type 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = type; // = parser.lastType
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("TypeVoid",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // StaticOpt ::= 
            {
              Boolean RESULT =null;
		 RESULT = false;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StaticOpt",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // StaticOpt ::= STATIC 
            {
              Boolean RESULT =null;
		 RESULT = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StaticOpt",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // MethodDecl ::= StaticOpt TypeVoid IDENT NT$1 LPAREN FormParamsOpt RPAREN MethodVarDeclListOpt LBRACE NT$2 StatementListOpt RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int isStaticMethodleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).left;
		int isStaticMethodright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).right;
		Boolean isStaticMethod = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).value;
		int methodNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int methodNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		String methodName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;
		int numOfParamsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int numOfParamsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		Integer numOfParams = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		 
    if (numOfParams == null) numOfParams = 0;
    
    if (methodName.equals("main") &&  numOfParams >0)
    {
        parser.report_error("Main ne sme imati argumente!", numOfParamsleft);
    }

    
    if (!parser.returnHappend && type != Tab.noType)
    {
        parser.report_error("Fali vam povratna vrednost funkcije!",null);
    }

    Code.put(Code.exit);
    Code.put(Code.return_);
    
    parser.MethodEnding();
    parser.returnHappend = false;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // NT$2 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int isStaticMethodleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int isStaticMethodright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		Boolean isStaticMethod = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;
		int methodNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int methodNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		String methodName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		int numOfParamsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int numOfParamsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Integer numOfParams = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;

	parser.lastMethod.setAdr(Code.pc);
	if ("main".equals(parser.lastMethod.getName()))
	{
		Code.mainPc = Code.pc;
	}    
    parser.lastMethod.setLevel(numOfParams);
	Code.put(Code.enter);
	Code.put(parser.lastMethod.getLevel());
	Code.put(Tab.currentScope.getnVars());

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$2",60, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // NT$1 ::= 
            {
              Object RESULT =null;
		int isStaticMethodleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int isStaticMethodright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Boolean isStaticMethod = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int methodNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methodNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String methodName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                    parser.MethodDeclaration(methodName, methodNameleft, type, typeleft, isStaticMethod);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$1",59, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // MethodDeclListOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclListOpt",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // MethodDeclListOpt ::= MethodDeclListOpt MethodDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclListOpt",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // MethodDeclOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclOpt",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // MethodDeclOpt ::= LBRACE MethodDeclListOpt RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclOpt",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // MethodIdentList ::= Var 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodIdentList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // MethodIdentList ::= MethodIdentList COMMA Var 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodIdentList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // MethodVarDecl ::= Type MethodIdentList SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodVarDecl",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // MethodVarDeclListOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodVarDeclListOpt",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // MethodVarDeclListOpt ::= MethodVarDeclListOpt MethodVarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodVarDeclListOpt",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // ExtendsOpt ::= 
            {
              Struct RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExtendsOpt",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // ExtendsOpt ::= EXTENDS error 
            {
              Struct RESULT =null;
		
                    parser.ReportError("Doslo je do greske prilikom deklaracije prosirenja natklase"); 
                    RESULT = Tab.noType;
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExtendsOpt",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // ExtendsOpt ::= EXTENDS Type 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
                    if(!(type.getKind() == Struct.Class))
                        parser.report_error(" Tip objekta iz kog se pokusava izvodjenje mora biti klasa! ", typeleft);
                    else 
                        parser.extendedClass = Tab.find(parser.curTypeName);
                    RESULT = type;
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExtendsOpt",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // ClassDecl ::= CLASS IDENT ExtendsOpt LBRACE NT$0 ClassVarDeclListOpt MethodDeclOpt RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		int extendsClassleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int extendsClassright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Struct extendsClass = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		  
    SaveExtendedClassMembers(extendsClass);
    parser.ClassEnding();

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // NT$0 ::= 
            {
              Object RESULT =null;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int extendsClassleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int extendsClassright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct extendsClass = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
 
    parser.ClassDeclaration(className, classNameleft);

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$0",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // ClassVarDecl ::= VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassVarDecl",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // ClassVarDecl ::= STATIC VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassVarDecl",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // ClassVarDeclListOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassVarDeclListOpt",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // ClassVarDeclListOpt ::= ClassVarDeclListOpt ClassVarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassVarDeclListOpt",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // Type ::= IDENT 
            {
              Struct RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
            RESULT = parser.CheckTypeAndUpdateLastType(name, nameleft);
        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Type",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // Var ::= IDENT 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.VariableDeclaration(name, nameleft, Obj.Var, parser.lastType); EntityCounters.IncreaseVariableCount(); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Var",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // Var ::= IDENT LBRACK RBRACK 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
            parser.VariableDeclaration(name, nameleft, Obj.Var, new Struct(Struct.Array, parser.lastType));
			EntityCounters.IncreaseVariableCount();
        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Var",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // VarDeclList ::= Var 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // VarDeclList ::= error COMMA Var 
            {
              Object RESULT =null;
		 parser.ReportVarDeclError(','); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // VarDeclList ::= VarDeclList COMMA Var 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // VarDecl ::= Type error SEMI 
            {
              Object RESULT =null;
		 parser.ReportVarDeclError(';'); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // VarDecl ::= Type VarDeclList SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // Const ::= NUMBER 
            {
              Obj RESULT =null;
		int numberrleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int numberrright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer numberr = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 Obj obj = new Obj(Obj.Con, "", Tab.intType); 
	obj.setAdr((int)numberr);
	RESULT=obj; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Const",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // Const ::= CHAR 
            {
              Obj RESULT =null;
		int charrleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int charrright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		char charr = (char)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
            	Obj obj = new Obj(Obj.Con, "", Tab.charType); 
	obj.setAdr(charr); 
	RESULT=obj;
	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Const",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // Const ::= BOOL 
            {
              Obj RESULT =null;
		int boollleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int boollright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean booll = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
	Obj obj= new Obj(Obj.Con, "", boolType); 
obj.setAdr(booll?1:0); 
	RESULT = obj;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Const",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // ConstIdent ::= IDENT ASSIGN Const 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj type = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
    parser.VariableDeclaration(name, nameleft, Obj.Con, parser.lastType, type, typeleft);
	EntityCounters.IncreaseConstVariableCount();

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstIdent",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // ConstDeclList ::= ConstIdent 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclList",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // ConstDeclList ::= ConstDeclList COMMA ConstIdent 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclList",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // ConstDecl ::= CONST Type ConstDeclList SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // Decl ::= VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Decl",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // Decl ::= ConstDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Decl",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // Decl ::= ClassDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Decl",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // DeclListOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclListOpt",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // DeclListOpt ::= DeclListOpt Decl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclListOpt",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // ProgramName ::= IDENT 
            {
              Obj RESULT =null;
		int progNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int progNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String progName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
    RESULT = Tab.insert(Obj.Prog, progName, Tab.noType);
    Tab.openScope();
    

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgramName",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= Program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		RESULT = start_val;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MJParser$parser.done_parsing();
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // Program ::= PROG ProgramName DeclListOpt LBRACE MethodDeclListOpt RBRACE 
            {
              Object RESULT =null;
		int progNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int progNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj progName = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		
    Code.dataSize = Tab.currentScope().getnVars();
    parser.HandleProgramEnd(progName, progNameleft);

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Program",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

