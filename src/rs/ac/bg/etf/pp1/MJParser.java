
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Fri Sep 15 12:09:14 CEST 2017
//----------------------------------------------------

package rs.ac.bg.etf.pp1;

import rs.etf.pp1.mj.runtime.Code;
import java_cup.runtime.*;
import org.apache.log4j.*;
import java.util.*;
import java.util.stream.IntStream;
import rs.ac.bg.etf.pp1.util.ScopeEngine;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Fri Sep 15 12:09:14 CEST 2017
  */
public class MJParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public MJParser() {super();}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\235\000\002\050\010\000\002\002\004\000\002\051" +
    "\003\000\002\045\004\000\002\045\002\000\002\044\003" +
    "\000\002\044\003\000\002\044\003\000\002\032\006\000" +
    "\002\033\005\000\002\033\003\000\002\031\005\000\002" +
    "\052\003\000\002\052\003\000\002\052\003\000\002\026" +
    "\005\000\002\026\005\000\002\027\005\000\002\027\005" +
    "\000\002\027\003\000\002\030\005\000\002\030\003\000" +
    "\002\063\003\000\002\004\004\000\002\004\002\000\002" +
    "\003\004\000\002\003\003\000\002\074\002\000\002\002" +
    "\012\000\002\067\004\000\002\067\004\000\002\067\002" +
    "\000\002\011\004\000\002\011\002\000\002\010\005\000" +
    "\002\012\005\000\002\012\003\000\002\006\005\000\002" +
    "\006\002\000\002\007\004\000\002\007\002\000\002\075" +
    "\002\000\002\005\015\000\002\062\003\000\002\062\002" +
    "\000\002\064\003\000\002\064\003\000\002\025\010\000" +
    "\002\071\003\000\002\071\004\000\002\071\003\000\002" +
    "\071\003\000\002\071\002\000\002\072\005\000\002\072" +
    "\005\000\002\072\003\000\002\034\006\000\002\034\004" +
    "\000\002\036\004\000\002\036\002\000\002\035\004\000" +
    "\002\035\003\000\002\076\002\000\002\077\002\000\002" +
    "\100\002\000\002\101\002\000\002\102\002\000\002\035" +
    "\020\000\002\035\004\000\002\035\004\000\002\035\004" +
    "\000\002\035\005\000\002\035\007\000\002\035\010\000" +
    "\002\035\005\000\002\037\007\000\002\103\002\000\002" +
    "\037\012\000\002\037\007\000\002\037\011\000\002\046" +
    "\004\000\002\046\002\000\002\013\003\000\002\013\003" +
    "\000\002\013\002\000\002\043\003\000\002\043\003\000" +
    "\002\043\002\000\002\104\002\000\002\014\006\000\002" +
    "\014\006\000\002\014\004\000\002\014\004\000\002\014" +
    "\005\000\002\070\003\000\002\070\002\000\002\073\005" +
    "\000\002\073\003\000\002\105\002\000\002\053\005\000" +
    "\002\060\004\000\002\060\002\000\002\061\004\000\002" +
    "\106\002\000\002\061\006\000\002\040\005\000\002\040" +
    "\003\000\002\041\005\000\002\041\003\000\002\042\003" +
    "\000\002\042\005\000\002\065\004\000\002\065\003\000" +
    "\002\107\002\000\002\066\006\000\002\066\003\000\002" +
    "\110\002\000\002\054\006\000\002\054\003\000\002\111" +
    "\002\000\002\056\006\000\002\056\003\000\002\112\002" +
    "\000\002\055\006\000\002\055\003\000\002\057\003\000" +
    "\002\057\006\000\002\057\003\000\002\057\003\000\002" +
    "\057\003\000\002\057\004\000\002\113\002\000\002\057" +
    "\010\000\002\057\005\000\002\021\003\000\002\021\003" +
    "\000\002\021\003\000\002\022\003\000\002\022\003\000" +
    "\002\022\003\000\002\022\003\000\002\022\003\000\002" +
    "\022\003\000\002\015\003\000\002\015\003\000\002\016" +
    "\003\000\002\016\003\000\002\023\003\000\002\023\003" +
    "\000\002\020\003\000\002\020\003\000\002\024\003\000" +
    "\002\024\003\000\002\024\003\000\002\017\003\000\002" +
    "\017\003\000\002\017\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\367\000\004\016\005\001\002\000\004\002\371\001" +
    "\002\000\004\064\007\001\002\000\012\005\ufffd\006\ufffd" +
    "\023\ufffd\064\ufffd\001\002\000\012\005\uffff\006\uffff\023" +
    "\uffff\064\uffff\001\002\000\012\005\020\006\021\023\013" +
    "\064\014\001\002\000\006\003\361\064\105\001\002\000" +
    "\012\005\ufffe\006\ufffe\023\ufffe\064\ufffe\001\002\000\012" +
    "\021\uffd9\022\uffd9\024\uffd9\064\uffd9\001\002\000\070\003" +
    "\uffeb\023\uffeb\025\uffeb\026\uffeb\030\uffeb\031\uffeb\032\uffeb" +
    "\033\uffeb\034\uffeb\035\uffeb\037\uffeb\040\uffeb\041\uffeb\042" +
    "\uffeb\043\uffeb\044\uffeb\045\uffeb\046\uffeb\047\uffeb\050\uffeb" +
    "\051\uffeb\054\uffeb\055\uffeb\056\uffeb\057\uffeb\060\uffeb\064" +
    "\uffeb\001\002\000\012\005\ufffa\006\ufffa\023\ufffa\064\ufffa" +
    "\001\002\000\012\005\ufffc\006\ufffc\023\ufffc\064\ufffc\001" +
    "\002\000\012\005\ufffb\006\ufffb\023\ufffb\064\ufffb\001\002" +
    "\000\004\064\036\001\002\000\004\064\014\001\002\000" +
    "\004\064\024\001\002\000\006\056\034\057\033\001\002" +
    "\000\004\036\026\001\002\000\006\056\ufff7\057\ufff7\001" +
    "\002\000\010\061\027\062\032\063\031\001\002\000\006" +
    "\056\ufff3\057\ufff3\001\002\000\006\056\ufff6\057\ufff6\001" +
    "\002\000\006\056\ufff5\057\ufff5\001\002\000\006\056\ufff4" +
    "\057\ufff4\001\002\000\004\064\024\001\002\000\012\005" +
    "\ufff9\006\ufff9\023\ufff9\064\ufff9\001\002\000\006\056\ufff8" +
    "\057\ufff8\001\002\000\006\011\040\023\uffe2\001\002\000" +
    "\004\023\043\001\002\000\006\003\042\064\014\001\002" +
    "\000\004\023\uffe4\001\002\000\004\023\uffe3\001\002\000" +
    "\012\021\uffe6\023\uffe6\024\uffe6\064\uffe6\001\002\000\012" +
    "\021\uffe9\023\uffe9\024\uffe9\064\uffe9\001\002\000\012\021" +
    "\047\023\046\024\uffdb\064\014\001\002\000\012\021\uffd9" +
    "\022\uffd9\024\uffd9\064\uffd9\001\002\000\004\064\014\001" +
    "\002\000\012\021\uffe7\023\uffe7\024\uffe7\064\uffe7\001\002" +
    "\000\012\021\uffea\023\uffea\024\uffea\064\uffea\001\002\000" +
    "\004\024\053\001\002\000\012\005\uffe5\006\uffe5\023\uffe5" +
    "\064\uffe5\001\002\000\012\021\uffe8\023\uffe8\024\uffe8\064" +
    "\uffe8\001\002\000\012\021\056\022\uffd5\024\057\064\uffd5" +
    "\001\002\000\006\022\uffd6\064\uffd6\001\002\000\004\024" +
    "\uffdc\001\002\000\012\021\uffda\022\uffda\024\uffda\064\uffda" +
    "\001\002\000\006\022\064\064\014\001\002\000\004\064" +
    "\uffd4\001\002\000\004\064\065\001\002\000\004\064\uffd3" +
    "\001\002\000\004\027\066\001\002\000\012\003\uffd8\030" +
    "\uffd8\057\uffd8\064\uffd8\001\002\000\012\003\072\030\uffcd" +
    "\057\070\064\014\001\002\000\004\064\014\001\002\000" +
    "\004\064\344\001\002\000\006\030\uffce\057\353\001\002" +
    "\000\006\030\uffd1\057\340\001\002\000\004\030\077\001" +
    "\002\000\004\030\uffcf\001\002\000\006\030\uffca\057\uffca" +
    "\001\002\000\006\023\uffe0\064\uffe0\001\002\000\006\023" +
    "\101\064\014\001\002\000\026\004\uffc6\007\uffc6\012\uffc6" +
    "\013\uffc6\015\uffc6\017\uffc6\020\uffc6\023\uffc6\024\uffc6\064" +
    "\uffc6\001\002\000\004\064\105\001\002\000\006\023\uffe1" +
    "\064\uffe1\001\002\000\006\056\112\057\111\001\002\000" +
    "\010\025\107\056\uffec\057\uffec\001\002\000\006\056\uffdd" +
    "\057\uffdd\001\002\000\004\026\110\001\002\000\006\056" +
    "\uffed\057\uffed\001\002\000\004\064\105\001\002\000\006" +
    "\023\uffdf\064\uffdf\001\002\000\006\056\uffde\057\uffde\001" +
    "\002\000\026\004\132\007\127\012\120\013\122\015\126" +
    "\017\115\020\130\023\116\024\131\064\117\001\002\000" +
    "\004\027\334\001\002\000\026\004\uffc6\007\uffc6\012\uffc6" +
    "\013\uffc6\015\uffc6\017\uffc6\020\uffc6\023\uffc6\024\uffc6\064" +
    "\uffc6\001\002\000\072\025\uff9f\026\uff9f\027\uff9f\030\uff9f" +
    "\031\uff9f\032\uff9f\033\uff9f\034\uff9f\035\uff9f\036\uff9f\037" +
    "\uff9f\040\uff9f\041\uff9f\042\uff9f\043\uff9f\044\uff9f\045\uff9f" +
    "\046\uff9f\047\uff9f\050\uff9f\051\uff9f\052\uff9f\053\uff9f\054" +
    "\uff9f\055\uff9f\056\uff9f\057\uff9f\060\uff9f\001\002\000\004" +
    "\027\300\001\002\000\024\027\272\036\267\037\175\040" +
    "\174\041\157\042\160\043\161\052\271\053\270\001\002" +
    "\000\004\027\231\001\002\000\004\056\230\001\002\000" +
    "\026\004\uffc7\007\uffc7\012\uffc7\013\uffc7\015\uffc7\017\uffc7" +
    "\020\uffc7\023\uffc7\024\uffc7\064\uffc7\001\002\000\030\004" +
    "\uffc4\007\uffc4\010\uffc4\012\uffc4\013\uffc4\015\uffc4\017\uffc4" +
    "\020\uffc4\023\uffc4\024\uffc4\064\uffc4\001\002\000\004\027" +
    "\221\001\002\000\004\056\220\001\002\000\022\014\136" +
    "\027\150\032\144\056\142\061\140\062\151\063\135\064" +
    "\117\001\002\000\012\021\uffd7\022\uffd7\024\uffd7\064\uffd7" +
    "\001\002\000\004\056\133\001\002\000\030\004\uffbd\007" +
    "\uffbd\010\uffbd\012\uffbd\013\uffbd\015\uffbd\017\uffbd\020\uffbd" +
    "\023\uffbd\024\uffbd\064\uffbd\001\002\000\032\026\uff91\030" +
    "\uff91\044\uff91\045\uff91\046\uff91\047\uff91\050\uff91\051\uff91" +
    "\054\uff91\055\uff91\056\uff91\057\uff91\001\002\000\056\026" +
    "\uff80\030\uff80\031\uff80\032\uff80\033\uff80\034\uff80\035\uff80" +
    "\037\uff80\040\uff80\041\uff80\042\uff80\043\uff80\044\uff80\045" +
    "\uff80\046\uff80\047\uff80\050\uff80\051\uff80\054\uff80\055\uff80" +
    "\056\uff80\057\uff80\001\002\000\004\064\014\001\002\000" +
    "\060\026\uff84\027\204\030\uff84\031\uff84\032\uff84\033\uff84" +
    "\034\uff84\035\uff84\037\uff84\040\uff84\041\uff84\042\uff84\043" +
    "\uff84\044\uff84\045\uff84\046\uff84\047\uff84\050\uff84\051\uff84" +
    "\054\uff84\055\uff84\056\uff84\057\uff84\001\002\000\056\026" +
    "\uff82\030\uff82\031\uff82\032\uff82\033\uff82\034\uff82\035\uff82" +
    "\037\uff82\040\uff82\041\uff82\042\uff82\043\uff82\044\uff82\045" +
    "\uff82\046\uff82\047\uff82\050\uff82\051\uff82\054\uff82\055\uff82" +
    "\056\uff82\057\uff82\001\002\000\042\026\uff8e\030\uff8e\031" +
    "\uff8d\032\uff8d\037\uff90\040\uff90\044\uff8e\045\uff8e\046\uff8e" +
    "\047\uff8e\050\uff8e\051\uff8e\054\uff8e\055\uff8e\056\uff8e\057" +
    "\uff8e\001\002\000\030\004\uffbb\007\uffbb\010\uffbb\012\uffbb" +
    "\013\uffbb\015\uffbb\017\uffbb\020\uffbb\023\uffbb\024\uffbb\064" +
    "\uffbb\001\002\000\004\056\171\001\002\000\016\014\136" +
    "\027\150\061\140\062\151\063\135\064\117\001\002\000" +
    "\056\026\uff88\030\uff88\031\uff88\032\uff88\033\uff87\034\uff87" +
    "\035\uff87\037\uff88\040\uff88\041\uff8a\042\uff8a\043\uff8a\044" +
    "\uff88\045\uff88\046\uff88\047\uff88\050\uff88\051\uff88\054\uff88" +
    "\055\uff88\056\uff88\057\uff88\001\002\000\042\026\uff8b\030" +
    "\uff8b\031\uff8b\032\uff8b\037\uff8b\040\uff8b\044\uff8b\045\uff8b" +
    "\046\uff8b\047\uff8b\050\uff8b\051\uff8b\054\uff8b\055\uff8b\056" +
    "\uff8b\057\uff8b\001\002\000\056\026\uff85\030\uff85\031\uff85" +
    "\032\uff85\033\uff85\034\uff85\035\uff85\037\uff85\040\uff85\041" +
    "\uff85\042\uff85\043\uff85\044\uff85\045\uff85\046\uff85\047\uff85" +
    "\050\uff85\051\uff85\054\uff85\055\uff85\056\uff85\057\uff85\001" +
    "\002\000\020\014\136\027\150\032\144\061\140\062\151" +
    "\063\135\064\117\001\002\000\056\026\uff81\030\uff81\031" +
    "\uff81\032\uff81\033\uff81\034\uff81\035\uff81\037\uff81\040\uff81" +
    "\041\uff81\042\uff81\043\uff81\044\uff81\045\uff81\046\uff81\047" +
    "\uff81\050\uff81\051\uff81\054\uff81\055\uff81\056\uff81\057\uff81" +
    "\001\002\000\004\030\153\001\002\000\056\026\uff7c\030" +
    "\uff7c\031\uff7c\032\uff7c\033\uff7c\034\uff7c\035\uff7c\037\uff7c" +
    "\040\uff7c\041\uff7c\042\uff7c\043\uff7c\044\uff7c\045\uff7c\046" +
    "\uff7c\047\uff7c\050\uff7c\051\uff7c\054\uff7c\055\uff7c\056\uff7c" +
    "\057\uff7c\001\002\000\010\033\164\034\165\035\163\001" +
    "\002\000\010\041\157\042\160\043\161\001\002\000\016" +
    "\014\136\027\150\061\140\062\151\063\135\064\117\001" +
    "\002\000\022\003\uff67\014\uff67\027\uff67\032\uff67\061\uff67" +
    "\062\uff67\063\uff67\064\uff67\001\002\000\022\003\uff66\014" +
    "\uff66\027\uff66\032\uff66\061\uff66\062\uff66\063\uff66\064\uff66" +
    "\001\002\000\022\003\uff65\014\uff65\027\uff65\032\uff65\061" +
    "\uff65\062\uff65\063\uff65\064\uff65\001\002\000\042\026\uff89" +
    "\030\uff89\031\uff89\032\uff89\037\uff89\040\uff89\044\uff89\045" +
    "\uff89\046\uff89\047\uff89\050\uff89\051\uff89\054\uff89\055\uff89" +
    "\056\uff89\057\uff89\001\002\000\016\014\uff68\027\uff68\061" +
    "\uff68\062\uff68\063\uff68\064\uff68\001\002\000\016\014\uff6a" +
    "\027\uff6a\061\uff6a\062\uff6a\063\uff6a\064\uff6a\001\002\000" +
    "\016\014\uff69\027\uff69\061\uff69\062\uff69\063\uff69\064\uff69" +
    "\001\002\000\016\014\136\027\150\061\140\062\151\063" +
    "\135\064\117\001\002\000\056\026\uff86\030\uff86\031\uff86" +
    "\032\uff86\033\uff86\034\uff86\035\uff86\037\uff86\040\uff86\041" +
    "\uff86\042\uff86\043\uff86\044\uff86\045\uff86\046\uff86\047\uff86" +
    "\050\uff86\051\uff86\054\uff86\055\uff86\056\uff86\057\uff86\001" +
    "\002\000\032\026\uff92\030\uff92\044\uff92\045\uff92\046\uff92" +
    "\047\uff92\050\uff92\051\uff92\054\uff92\055\uff92\056\uff92\057" +
    "\uff92\001\002\000\030\004\uffba\007\uffba\010\uffba\012\uffba" +
    "\013\uffba\015\uffba\017\uffba\020\uffba\023\uffba\024\uffba\064" +
    "\uffba\001\002\000\006\031\201\032\200\001\002\000\006" +
    "\037\175\040\174\001\002\000\022\003\uff6d\014\uff6d\027" +
    "\uff6d\032\uff6d\061\uff6d\062\uff6d\063\uff6d\064\uff6d\001\002" +
    "\000\022\003\uff6e\014\uff6e\027\uff6e\032\uff6e\061\uff6e\062" +
    "\uff6e\063\uff6e\064\uff6e\001\002\000\016\014\136\027\150" +
    "\061\140\062\151\063\135\064\117\001\002\000\032\026" +
    "\uff8f\030\uff8f\044\uff8f\045\uff8f\046\uff8f\047\uff8f\050\uff8f" +
    "\051\uff8f\054\uff8f\055\uff8f\056\uff8f\057\uff8f\001\002\000" +
    "\016\014\uff6f\027\uff6f\061\uff6f\062\uff6f\063\uff6f\064\uff6f" +
    "\001\002\000\016\014\uff70\027\uff70\061\uff70\062\uff70\063" +
    "\uff70\064\uff70\001\002\000\016\014\136\027\150\061\140" +
    "\062\151\063\135\064\117\001\002\000\042\026\uff8c\030" +
    "\uff8c\031\uff8c\032\uff8c\037\uff8c\040\uff8c\044\uff8c\045\uff8c" +
    "\046\uff8c\047\uff8c\050\uff8c\051\uff8c\054\uff8c\055\uff8c\056" +
    "\uff8c\057\uff8c\001\002\000\022\014\136\027\150\030\uffa2" +
    "\032\144\061\140\062\151\063\135\064\117\001\002\000" +
    "\006\030\uffa3\057\211\001\002\000\004\030\210\001\002" +
    "\000\006\030\uffa0\057\uffa0\001\002\000\056\026\uff83\030" +
    "\uff83\031\uff83\032\uff83\033\uff83\034\uff83\035\uff83\037\uff83" +
    "\040\uff83\041\uff83\042\uff83\043\uff83\044\uff83\045\uff83\046" +
    "\uff83\047\uff83\050\uff83\051\uff83\054\uff83\055\uff83\056\uff83" +
    "\057\uff83\001\002\000\020\014\136\027\150\032\144\061" +
    "\140\062\151\063\135\064\117\001\002\000\006\030\uffa1" +
    "\057\uffa1\001\002\000\060\025\uff7e\026\uff7f\030\uff7f\031" +
    "\uff7f\032\uff7f\033\uff7f\034\uff7f\035\uff7f\037\uff7f\040\uff7f" +
    "\041\uff7f\042\uff7f\043\uff7f\044\uff7f\045\uff7f\046\uff7f\047" +
    "\uff7f\050\uff7f\051\uff7f\054\uff7f\055\uff7f\056\uff7f\057\uff7f" +
    "\001\002\000\004\025\215\001\002\000\020\014\136\027" +
    "\150\032\144\061\140\062\151\063\135\064\117\001\002" +
    "\000\004\026\217\001\002\000\056\026\uff7d\030\uff7d\031" +
    "\uff7d\032\uff7d\033\uff7d\034\uff7d\035\uff7d\037\uff7d\040\uff7d" +
    "\041\uff7d\042\uff7d\043\uff7d\044\uff7d\045\uff7d\046\uff7d\047" +
    "\uff7d\050\uff7d\051\uff7d\054\uff7d\055\uff7d\056\uff7d\057\uff7d" +
    "\001\002\000\030\004\uffbc\007\uffbc\010\uffbc\012\uffbc\013" +
    "\uffbc\015\uffbc\017\uffbc\020\uffbc\023\uffbc\024\uffbc\064\uffbc" +
    "\001\002\000\020\014\136\027\150\032\144\061\140\062" +
    "\151\063\135\064\117\001\002\000\006\030\uffb0\057\223" +
    "\001\002\000\004\061\227\001\002\000\004\030\225\001" +
    "\002\000\004\056\226\001\002\000\030\004\uffb8\007\uffb8" +
    "\010\uffb8\012\uffb8\013\uffb8\015\uffb8\017\uffb8\020\uffb8\023" +
    "\uffb8\024\uffb8\064\uffb8\001\002\000\004\030\uffb1\001\002" +
    "\000\030\004\uffc5\007\uffc5\010\uffc5\012\uffc5\013\uffc5\015" +
    "\uffc5\017\uffc5\020\uffc5\023\uffc5\024\uffc5\064\uffc5\001\002" +
    "\000\022\003\233\014\136\027\150\032\144\061\140\062" +
    "\151\063\135\064\117\001\002\000\012\030\uff95\054\uff95" +
    "\055\uff95\056\uff95\001\002\000\004\030\260\001\002\000" +
    "\012\030\uff97\054\uff97\055\252\056\uff97\001\002\000\006" +
    "\030\247\054\250\001\002\000\026\030\uff94\044\242\045" +
    "\237\046\241\047\244\050\240\051\243\054\uff94\055\uff94" +
    "\056\uff94\001\002\000\020\014\uff77\027\uff77\032\uff77\061" +
    "\uff77\062\uff77\063\uff77\064\uff77\001\002\000\020\014\uff76" +
    "\027\uff76\032\uff76\061\uff76\062\uff76\063\uff76\064\uff76\001" +
    "\002\000\020\014\uff75\027\uff75\032\uff75\061\uff75\062\uff75" +
    "\063\uff75\064\uff75\001\002\000\020\014\uff78\027\uff78\032" +
    "\uff78\061\uff78\062\uff78\063\uff78\064\uff78\001\002\000\020" +
    "\014\uff74\027\uff74\032\uff74\061\uff74\062\uff74\063\uff74\064" +
    "\uff74\001\002\000\020\014\uff73\027\uff73\032\uff73\061\uff73" +
    "\062\uff73\063\uff73\064\uff73\001\002\000\020\014\136\027" +
    "\150\032\144\061\140\062\151\063\135\064\117\001\002" +
    "\000\012\030\uff93\054\uff93\055\uff93\056\uff93\001\002\000" +
    "\024\004\132\007\127\012\120\013\122\015\126\017\115" +
    "\020\130\023\116\064\117\001\002\000\020\014\136\027" +
    "\150\032\144\061\140\062\151\063\135\064\117\001\002" +
    "\000\012\030\uff98\054\uff98\055\252\056\uff98\001\002\000" +
    "\020\014\136\027\150\032\144\061\140\062\151\063\135" +
    "\064\117\001\002\000\012\030\uff96\054\uff96\055\uff96\056" +
    "\uff96\001\002\000\030\004\uffb6\007\uffb6\010\255\012\uffb6" +
    "\013\uffb6\015\uffb6\017\uffb6\020\uffb6\023\uffb6\024\uffb6\064" +
    "\uffb6\001\002\000\024\004\uffb5\007\uffb5\012\uffb5\013\uffb5" +
    "\015\uffb5\017\uffb5\020\uffb5\023\uffb5\064\uffb5\001\002\000" +
    "\024\004\132\007\127\012\120\013\122\015\126\017\115" +
    "\020\130\023\116\064\117\001\002\000\030\004\uffb4\007" +
    "\uffb4\010\uffb4\012\uffb4\013\uffb4\015\uffb4\017\uffb4\020\uffb4" +
    "\023\uffb4\024\uffb4\064\uffb4\001\002\000\024\004\132\007" +
    "\127\012\120\013\122\015\126\017\115\020\130\023\116" +
    "\064\117\001\002\000\030\004\uffb3\007\uffb3\010\262\012" +
    "\uffb3\013\uffb3\015\uffb3\017\uffb3\020\uffb3\023\uffb3\024\uffb3" +
    "\064\uffb3\001\002\000\024\004\132\007\127\012\120\013" +
    "\122\015\126\017\115\020\130\023\116\064\117\001\002" +
    "\000\030\004\uffb2\007\uffb2\010\uffb2\012\uffb2\013\uffb2\015" +
    "\uffb2\017\uffb2\020\uffb2\023\uffb2\024\uffb2\064\uffb2\001\002" +
    "\000\022\003\uff79\014\uff79\027\uff79\032\uff79\061\uff79\062" +
    "\uff79\063\uff79\064\uff79\001\002\000\022\003\uff7a\014\uff7a" +
    "\027\uff7a\032\uff7a\061\uff7a\062\uff7a\063\uff7a\064\uff7a\001" +
    "\002\000\022\003\275\014\uffa9\027\uffa9\032\uffa9\061\uffa9" +
    "\062\uffa9\063\uffa9\064\uffa9\001\002\000\022\003\uff7b\014" +
    "\uff7b\027\uff7b\032\uff7b\061\uff7b\062\uff7b\063\uff7b\064\uff7b" +
    "\001\002\000\006\030\uffa6\056\uffa6\001\002\000\006\030" +
    "\uffa5\056\uffa5\001\002\000\022\014\136\027\150\030\uffa2" +
    "\032\144\061\140\062\151\063\135\064\117\001\002\000" +
    "\004\030\274\001\002\000\006\030\uffa7\056\uffa7\001\002" +
    "\000\006\030\uffa4\056\uffa4\001\002\000\020\014\136\027" +
    "\150\032\144\061\140\062\151\063\135\064\117\001\002" +
    "\000\006\030\uffa8\056\uffa8\001\002\000\010\003\301\056" +
    "\uffad\064\117\001\002\000\006\030\uffae\056\uffae\001\002" +
    "\000\006\030\uffaf\056\uffaf\001\002\000\004\056\304\001" +
    "\002\000\024\003\uffc3\014\uffc3\027\uffc3\032\uffc3\056\uffc3" +
    "\061\uffc3\062\uffc3\063\uffc3\064\uffc3\001\002\000\024\003" +
    "\307\014\136\027\150\032\144\056\uffaa\061\140\062\151" +
    "\063\135\064\117\001\002\000\004\056\uffc2\001\002\000" +
    "\004\056\uffab\001\002\000\006\054\250\056\uffac\001\002" +
    "\000\004\056\312\001\002\000\010\003\uffc1\030\uffc1\064" +
    "\uffc1\001\002\000\010\003\301\030\uffad\064\117\001\002" +
    "\000\004\030\uffc0\001\002\000\004\030\316\001\002\000" +
    "\024\004\uffbf\007\uffbf\012\uffbf\013\uffbf\015\uffbf\017\uffbf" +
    "\020\uffbf\023\uffbf\064\uffbf\001\002\000\024\004\132\007" +
    "\127\012\120\013\122\015\126\017\115\020\130\023\116" +
    "\064\117\001\002\000\030\004\uffbe\007\uffbe\010\uffbe\012" +
    "\uffbe\013\uffbe\015\uffbe\017\uffbe\020\uffbe\023\uffbe\024\uffbe" +
    "\064\uffbe\001\002\000\072\025\uff9c\026\uff9c\027\uff9c\030" +
    "\uff9c\031\uff9c\032\uff9c\033\uff9c\034\uff9c\035\uff9c\036\uff9c" +
    "\037\uff9c\040\uff9c\041\uff9c\042\uff9c\043\uff9c\044\uff9c\045" +
    "\uff9c\046\uff9c\047\uff9c\050\uff9c\051\uff9c\052\uff9c\053\uff9c" +
    "\054\uff9c\055\uff9c\056\uff9c\057\uff9c\060\uff9c\001\002\000" +
    "\072\025\324\026\uff9e\027\uff9e\030\uff9e\031\uff9e\032\uff9e" +
    "\033\uff9e\034\uff9e\035\uff9e\036\uff9e\037\uff9e\040\uff9e\041" +
    "\uff9e\042\uff9e\043\uff9e\044\uff9e\045\uff9e\046\uff9e\047\uff9e" +
    "\050\uff9e\051\uff9e\052\uff9e\053\uff9e\054\uff9e\055\uff9e\056" +
    "\uff9e\057\uff9e\060\325\001\002\000\072\025\uff9d\026\uff9d" +
    "\027\uff9d\030\uff9d\031\uff9d\032\uff9d\033\uff9d\034\uff9d\035" +
    "\uff9d\036\uff9d\037\uff9d\040\uff9d\041\uff9d\042\uff9d\043\uff9d" +
    "\044\uff9d\045\uff9d\046\uff9d\047\uff9d\050\uff9d\051\uff9d\052" +
    "\uff9d\053\uff9d\054\uff9d\055\uff9d\056\uff9d\057\uff9d\060\uff9d" +
    "\001\002\000\020\014\uff9a\027\uff9a\032\uff9a\061\uff9a\062" +
    "\uff9a\063\uff9a\064\uff9a\001\002\000\004\064\326\001\002" +
    "\000\072\025\uff9b\026\uff9b\027\uff9b\030\uff9b\031\uff9b\032" +
    "\uff9b\033\uff9b\034\uff9b\035\uff9b\036\uff9b\037\uff9b\040\uff9b" +
    "\041\uff9b\042\uff9b\043\uff9b\044\uff9b\045\uff9b\046\uff9b\047" +
    "\uff9b\050\uff9b\051\uff9b\052\uff9b\053\uff9b\054\uff9b\055\uff9b" +
    "\056\uff9b\057\uff9b\060\uff9b\001\002\000\020\014\136\027" +
    "\150\032\144\061\140\062\151\063\135\064\117\001\002" +
    "\000\004\026\331\001\002\000\072\025\uff99\026\uff99\027" +
    "\uff99\030\uff99\031\uff99\032\uff99\033\uff99\034\uff99\035\uff99" +
    "\036\uff99\037\uff99\040\uff99\041\uff99\042\uff99\043\uff99\044" +
    "\uff99\045\uff99\046\uff99\047\uff99\050\uff99\051\uff99\052\uff99" +
    "\053\uff99\054\uff99\055\uff99\056\uff99\057\uff99\060\uff99\001" +
    "\002\000\026\004\132\007\127\012\120\013\122\015\126" +
    "\017\115\020\130\023\116\024\333\064\117\001\002\000" +
    "\030\004\uffb7\007\uffb7\010\uffb7\012\uffb7\013\uffb7\015\uffb7" +
    "\017\uffb7\020\uffb7\023\uffb7\024\uffb7\064\uffb7\001\002\000" +
    "\004\064\117\001\002\000\004\030\336\001\002\000\004" +
    "\056\337\001\002\000\030\004\uffb9\007\uffb9\010\uffb9\012" +
    "\uffb9\013\uffb9\015\uffb9\017\uffb9\020\uffb9\023\uffb9\024\uffb9" +
    "\064\uffb9\001\002\000\004\064\014\001\002\000\004\030" +
    "\uffd0\001\002\000\006\060\345\064\344\001\002\000\006" +
    "\030\uffcc\057\uffcc\001\002\000\010\025\351\030\uffc8\057" +
    "\uffc8\001\002\000\004\060\346\001\002\000\004\060\347" +
    "\001\002\000\004\064\350\001\002\000\004\030\uffd2\001" +
    "\002\000\004\026\352\001\002\000\006\030\uffc9\057\uffc9" +
    "\001\002\000\004\064\014\001\002\000\006\030\uffcb\057" +
    "\uffcb\001\002\000\004\060\345\001\002\000\012\021\056" +
    "\022\uffd5\024\357\064\uffd5\001\002\000\004\002\001\001" +
    "\002\000\006\056\367\057\366\001\002\000\006\056\364" +
    "\057\363\001\002\000\006\056\uffee\057\uffee\001\002\000" +
    "\004\064\105\001\002\000\016\005\ufff1\006\ufff1\021\ufff1" +
    "\023\ufff1\024\ufff1\064\ufff1\001\002\000\006\056\uffef\057" +
    "\uffef\001\002\000\004\064\105\001\002\000\016\005\ufff2" +
    "\006\ufff2\021\ufff2\023\ufff2\024\ufff2\064\ufff2\001\002\000" +
    "\006\056\ufff0\057\ufff0\001\002\000\004\002\000\001\002" +
    "" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\367\000\004\050\003\001\001\000\002\001\001\000" +
    "\004\051\005\001\001\000\004\045\007\001\001\000\002" +
    "\001\001\000\014\002\015\026\014\032\016\044\011\063" +
    "\010\001\001\000\006\027\357\030\361\001\001\000\002" +
    "\001\001\000\004\007\355\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\063\021\001\001\000\006\031\024\033" +
    "\022\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\052\027\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\031\034\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\067\036\001\001\000\002\001\001\000\004\063\040" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\074" +
    "\043\001\001\000\004\004\044\001\001\000\012\003\050" +
    "\006\051\026\047\063\010\001\001\000\004\007\054\001" +
    "\001\000\006\026\053\063\010\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\005\057\062\060\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\063" +
    "\061\064\062\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\075\066\001" +
    "\001\000\014\025\074\034\075\063\070\071\073\072\072" +
    "\001\001\000\004\063\354\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\025\340\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\011\077\001" +
    "\001\000\006\010\102\063\101\001\001\000\004\036\113" +
    "\001\001\000\006\012\103\030\105\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\030\112\001" +
    "\001\000\002\001\001\000\002\001\001\000\012\014\122" +
    "\035\123\037\124\053\120\001\001\000\002\001\001\000" +
    "\004\036\331\001\001\000\004\105\320\001\001\000\002" +
    "\001\001\000\010\017\263\021\265\023\264\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\020\053" +
    "\136\054\140\055\144\056\145\057\146\065\142\066\133" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\063\212" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\107" +
    "\172\110\171\001\001\000\002\001\001\000\002\001\001" +
    "\000\016\053\136\054\140\055\144\056\145\057\146\066" +
    "\167\001\001\000\006\111\154\112\153\001\001\000\002" +
    "\001\001\000\002\001\001\000\020\053\136\054\140\055" +
    "\144\056\145\057\146\065\151\066\133\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\024" +
    "\165\001\001\000\004\017\155\001\001\000\012\053\136" +
    "\055\144\056\161\057\146\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\053" +
    "\136\057\166\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\016\201\001\001\000\004\023" +
    "\175\001\001\000\002\001\001\000\002\001\001\000\016" +
    "\053\136\054\140\055\144\056\145\057\146\066\176\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\012\053\136\055\144\056\202\057\146\001\001\000" +
    "\002\001\001\000\024\053\136\054\140\055\144\056\145" +
    "\057\146\065\206\066\133\070\205\073\204\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\020\053\136\054\140\055\144\056\145\057" +
    "\146\065\211\066\133\001\001\000\002\001\001\000\004" +
    "\113\213\001\001\000\002\001\001\000\020\053\136\054" +
    "\140\055\144\056\145\057\146\065\215\066\133\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\020\053\136\054\140\055\144\056\145\057\146\065\221" +
    "\066\133\001\001\000\004\046\223\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\026\040\234\041" +
    "\233\042\231\053\136\054\140\055\144\056\145\057\146" +
    "\065\235\066\133\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\022\244" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\020\053\136\054\140\055\144\056\145\057\146\065" +
    "\245\066\133\001\001\000\002\001\001\000\012\014\122" +
    "\035\253\037\124\053\120\001\001\000\024\041\250\042" +
    "\231\053\136\054\140\055\144\056\145\057\146\065\235" +
    "\066\133\001\001\000\002\001\001\000\022\042\252\053" +
    "\136\054\140\055\144\056\145\057\146\065\235\066\133" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\103" +
    "\255\001\001\000\012\014\122\035\256\037\124\053\120" +
    "\001\001\000\002\001\001\000\012\014\122\035\260\037" +
    "\124\053\120\001\001\000\002\001\001\000\012\014\122" +
    "\035\262\037\124\053\120\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\104\275\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\024\053\136\054\140\055\144\056\145\057\146\065\206" +
    "\066\133\070\272\073\204\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\020\053\136\054\140" +
    "\055\144\056\145\057\146\065\276\066\133\001\001\000" +
    "\002\001\001\000\010\013\302\014\301\053\120\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\076\304\001\001\000\030\040\307\041\233\042\231" +
    "\043\305\053\136\054\140\055\144\056\145\057\146\065" +
    "\235\066\133\001\001\000\004\077\310\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\100" +
    "\312\001\001\000\010\013\313\014\301\053\120\001\001" +
    "\000\004\101\314\001\001\000\002\001\001\000\004\102" +
    "\316\001\001\000\012\014\122\035\317\037\124\053\120" +
    "\001\001\000\002\001\001\000\004\060\321\001\001\000" +
    "\004\061\322\001\001\000\002\001\001\000\004\106\326" +
    "\001\001\000\002\001\001\000\002\001\001\000\020\053" +
    "\136\054\140\055\144\056\145\057\146\065\327\066\133" +
    "\001\001\000\002\001\001\000\002\001\001\000\012\014" +
    "\122\035\123\037\124\053\120\001\001\000\002\001\001" +
    "\000\004\053\334\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\034\342\063\341\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\034\353\063\070\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\005\057\062\060\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\030\364\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\030\367\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MJParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MJParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MJParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

    Tab.init(); // Universe scope
    Tab.currentScope.addToLocals(new Obj(Obj.Type, "bool",CUP$MJParser$actions.boolType));

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null) 
        log.info(s.toString() + " " + s.value.toString());
    return s;

    }



    Struct lastMethType = null;
    Struct lastType = null; // unneeded can get from up
    Obj lastClass = null;
    Obj lastMethod = null;
    Obj extendedClass = null;
    String curTypeName = "";
    
    boolean returnHappend = false;
    boolean errorEncountered = false;
    boolean errorHandled = false;
    
    void ReportError(String errorMessage)
    {
        errorEncountered = true;
        log.debug(errorMessage);
    }
    
    void ReportVarDeclError(char errorChar)
    {
        if (ScopeEngine.IsInGlobalScope())
        {
        	ReportError("Doslo je do greske prilikom deklaracije globalne promenljive pre znaka \""+errorChar + '\"');
            return;
        }
        if (ScopeEngine.IsInClassScope())
        {
        	ReportError("Doslo je do greske prilikom definicije lokalne promenljive unutrasnje klase pre znaka \"" +errorChar+ '\"');
            return;
        }
    }
    
    boolean CorrectNameAndType(String name, Struct type)
    {
        
        if( Tab.currentScope.findSymbol(name) != null)
        {
             report_error(" " + name + " je vec deklarisano ("+nameLocation+")" ,null );
             return false;
        }
        
        if (type == null || type == Tab.noType)
        {
            report_error("Greska u tipu pri deklaraciji ", null);
            return false; 
        }
        
        return true;
    }
    
    void VariableDeclaration(String name, int nameLocation, int objectKind, 
        Obj assignedType, int assignLocation, boolean isConst)
    {
    	if (!CorrectNameAndType(name, lastType))
    	{
    		return;
    	}
    	
        if(assignedType != null && assignedType.getType() != lastType)
        {
            report_error("neispravan tip promenljive koja se dodeljuje "+ UtilFunctions.StructToTypeName(lastType) +" = "+ UtilFunctions.StructToTypeName(assignedType.getType()) +"("+assignLocation+")",null );
            return;
        }
        
        Tab.insert(objectKind, name, lastType);
        
        if (isConst) ScopeEntityCounter.IncreaseConstVariableCount();
        else ScopeEntityCounter.IncreaseVariableCount();
        
        report_info("Definisana promenljiva " + name + " tipa: "+UtilFunctions.StructToTypeName(lastType)+ " na liniji "+nameLocation, null);
    }

    // Overloading
    void VariableDeclaration(String name, int nameLocation, int objectType)
    {
        VariableDeclaration(name, nameLocation, objectType, null, 0, false);
    }
    
    void VariableDeclaration(String name, int nameLocation, int objectType, Obj assignedType, int assignedLocation)
    {
        VariableDeclaration(name, nameLocation, objectType, assignedType, assignedLocation, false);
    }

    void ClassDeclaration(String className, int classLocation)
    {
        if(Tab.currentScope.findSymbol(className) != null)
        {
            report_error("Klasa sa imenom " + className + "je vec deklarisana ("+classLocation +")", null);
            return;
        }
        
        lastClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
        ScopeEntityCounter.InScope(ScopeEntityCounter.SCOPE.CLASS_SCOPE);
        Tab.openScope();
        classCount++;
        
        report_info("Definisana klasa " + className + " na liniji "+classLocation,null );
    }
    
    void ClassEnding()
    {
        if(extendedClass != null) {
            for (Obj obj : extendedClass.getType().getMembers()) {
                if(Tab.currentScope.findSymbol(obj.getName()) == null)
                      Tab.insert(obj.getKind(), obj.getName(), obj.getType());
                }
       }   
       extendedClass = null;
       
        // if (!nestedScopes.empty() && nestedScopes.peek() == SCOPE.CLASS_SCOPE)
        {
        	ScopeEntityCounter.OutOfCurrentScope();
            Tab.chainLocalSymbols(lastClass.getType());
            Tab.closeScope();
            lastClass = null;
        }          
    }
    
    void MethodDeclaration(String methodName, int methodLocation, Struct type, int typeLocation, boolean isStaticMethod)
    {
        if(Tab.currentScope.findSymbol(methodName) != null)
        {
              report_error("Naziv metode "+methodName + "je vec u upotrebi ("+methodLocation+")", null);
              return;
        }
        
        if(extendedClass != null) 
        {
           for (Obj o : extendedClass.getType().getMembers()) 
           {
               if(o.getKind() == Obj.Meth && o.getName().equals(methodName)) 
               if(o.getType().getElemType().getKind() == 6) 
                   {
                   // error
                   return;
                   }
          }
        }
        if (methodName.equals("main"))
        {
            if(type != Tab.noType)
            {
                report_error("Main mora biti tipa \"void\" ("+typeLocation + ")",null);
                return;
            }
            if (isStaticMethod)
            {
                report_error("Main ne sme biti staticka metoda ("+methodLocation+")",null);
                return;
            }

            ScopeEntityCounter.InScope(ScopeEntityCounter.SCOPE.MAIN_SCOPE);
            InsertMethod(methodName, methodLocation, type.getKind());
            Tab.openScope();
            lastMethType = type;
            return;
        } 
        
       if(isStaticMethod) 
       {
           InsertMethod(methodName, methodLocation, 6);
       }
       else 
       {
           InsertMethod(methodName, methodLocation, type.getKind());
       }
       
       lastMethType = type;
       ScopeEntityCounter.InScope(ScopeEntityCounter.SCOPE.METHOD_SCOPE);
       Tab.openScope();
    }
    
    void InsertMethod(String methodName, int methodLocation, int methodType)
    {
           if (methodType == 7 ) ScopeEntityCounter.IncreaseFunctionCount();
           else ScopeEntityCounter.IncreaseStaticFunctionCount();
           lastType.setElementType(new Struct(methodType));
           lastMethod = Tab.insert(Obj.Meth, methodName, lastType);
           report_info("Ubacena metoda "+methodName+" u tabelu simbola na liniji "+ methodLocation,null );
    }
    
    void MethodEnding()
    {
        // if (!nestedScopes.empty() &&
        // nestedScopes.peek() == SCOPE.METHOD_SCOPE ||
        // nestedScopes.peek() == SCOPE.MAIN_SCOPE || 
        // nestedScopes.peek() == SCOPE.CLASS_METHOD_SCOPE)
        {
            HandleScopeEnd(lastMethod);
            lastMethod = null;
            lastMethType = null;
        }
    }
    
    void HandleScopeEnd(Obj scopeName)
    {
    	ScopeEntityCounter.OutOfCurrentScope();
        Tab.chainLocalSymbols(scopeName);
        Tab.closeScope();
    }

    void HandleProgramEnd(Obj progName, int programLocation)
    {
        if(Tab.find("main") == Tab.noObj)
        {
            report_error("Metoda \"main\" nije pronadjena! ("+programLocation+")", null);
        }
        
        HandleScopeEnd(progName);
    }
    
    Struct CheckTypeAndUpdateLastType(String typeName, int nameLocation)
    {
        Obj typeNode = Tab.find(typeName);
        
        if (Obj.Type == typeNode.getKind()) 
        {
             curTypeName = typeName;
             return lastType = typeNode.getType();
        }
        
        lastType = Tab.noType;
        if (typeNode == Tab.noObj) 
        {
            report_error("U tabeli simbola nije pronadjen tip " + typeName + " referenciran na lokaciji "+nameLocation, null);            
            return Tab.noType;
        }
        
        report_error(" ime " + typeName + " ne predstavlja tip "+nameLocation, null);
        return Tab.noType;
    }

    Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
        StringBuilder msg = new StringBuilder(message); 
        if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$MJParser$actions {


int numberOfNestedFors = 0;
boolean isThisSpecified = false;
Obj backupDesig = null;
public static final int STATIC = 6;
public static final int Bool = 5;
public static final Struct boolType = new Struct(Struct.Bool);
boolean varArgs = false;
Obj lastDesignator = null;

Collection<Obj> classFields = null;
List<Struct> actParams= new LinkedList<Struct>();
    
    Stack<Integer> forStack = new Stack<Integer>();
    Stack<Integer> cond = new Stack<Integer>();
    Stack<Integer> andAdr = new Stack<Integer>();    
    Stack<Integer> orAdr = new Stack<Integer>();     
    Stack<Integer> endAdr = new Stack<Integer>();
    Stack<Integer> forAdr = new Stack<Integer>();
    Stack<Integer> endFor = new Stack<Integer>();
    Stack<Integer> noCond = new Stack<Integer>();
    Stack<Integer> desi = new Stack<Integer>();
    
    public void EnteredFor()
    {
        ++numberOfNestedFors;
    }
    public void ExitedFor()
    {
        --numberOfNestedFors;
    }
    public boolean IsNotInForLoop()
    {
        return numberOfNestedFors == 0;
    }
    
    void ReturnCallCheck(int returnLocation, Struct expr)
    {
       parser.returnHappend = true;
        
        if(parser.lastMethod == null )
        {
            parser.report_error("Return mora biti iz funkcije pozvan ("+returnLocation+")", null);
            return;
        }
        
        if (parser.lastMethType == Tab.noType)
        {
            parser.report_error("Return mora biti iz funkcije pozvan ("+returnLocation+")", null);
            return;
        }

        if (expr != null && expr.getKind() != parser.lastMethType.getKind())
        {
            parser.report_error("Funkcija vraca tip "+ UtilFunctions.StructToTypeName(expr) +" A mora vracati tip "+ 
            		UtilFunctions.StructToTypeName(parser.lastMethod.getType()) + "("+returnLocation+")", null);
        }
    }
    
int [] correctObjTypes = {Obj.Var, Obj.Elem, Obj.Fld };
int [] correctStructTypes = {Struct.Int, Struct.Char, Struct.None};
    
    public boolean IsObjectVarElemOrFieldError(Obj designator, int designatorLocation)
    {
        if (designator == null)
            return false;
        if (!IntStream.of(correctObjTypes).anyMatch(x -> x == designator.getKind()))
        {
            parser.report_error(" " + designator.getName() + 
            " mora biti  promenljiva, element niza ili polje unutar objekta ("+ designatorLocation+")", null);
            return false;
        }
        return true;
    }
    
    public boolean IsStructIntCharOrNone(Struct expr, int exprLocation)
    {
        if (!IntStream.of(correctStructTypes).anyMatch(x -> x == expr.getKind()))
        {       
            parser.report_error(" " + expr.getKind() + " mora biti tipa int, char ili bool. ("+exprLocation+")", null);                
            return false;
        }
        return true;
    }
    
    public void CorrectTypesForFunctionCalls(Obj designator, int designatorLocation)
    {
        if (IsObjectVarElemOrFieldError(designator, designatorLocation) &&
            IsStructIntCharOrNone(designator.getType(), designatorLocation))
         {
        	ScopeEntityCounter.IncreaseFunctionCallsCount(); 
         }
    }
    
    public boolean IsAssignable(Obj design, Struct expr)
    {
        if(expr.assignableTo(design.getType())) // If expr is assignable to design
        {
            return true;
        }
        
        if( expr.getKind() == design.getType().getKind() || // If they are not same Struct type
            expr.getElemType() != design.getType().getElemType() || // If they are not same Struct.ElementType
            expr.getNumberOfFields() != design.getType().getNumberOfFields() || // If they don't have same params of fields
            expr.getMembers() == design.getType().getMembers()) // If they don't have same type of fields
        {
            return false;
        }
  /*
        if (design.getType().getKind() == Struct.Array && // If designator is Struct.Array
            expr.getElemType() == null && // Expression is not array
            !expr.assignableTo(design.getType().getElemType())) // if expr is assignable to type of designator elements
        {
            return false;
        }
     */   
        return true;
    }
    
    Obj GetResultIfBothInt(Obj result, int resultLocation, Struct term)
    {
        /*if (!IsObjectVarElemOrFieldError(result , resultLocation))
        {
            return Tab.noObj;
        }*/
        
        if (result.getType().getKind() == Struct.Int && term.getKind() == Struct.Int)
        {
            return result;
        }
        
       parser.report_error("Poslali ste tipove" + UtilFunctions.StructToTypeName(parser.lastMethod.getType()) +
            " i " + UtilFunctions.StructToTypeName(term) + " a moraju biti int ("+resultLocation+")", null);
        return Tab.noObj;
    }
    
    void SaveExtendedClassMembers(Struct extendsClass)
    {
        if(extendsClass != null && extendsClass != Tab.noType && extendsClass.getKind() == Struct.Class) 
        {
            for (Obj obj : extendsClass.getMembers()) 
            {
                if(Tab.currentScope.findSymbol(obj.getName()) == null)
                      Tab.insert(obj.getKind(), obj.getName(), obj.getType());
            }
        }
    }
    
    boolean CheckIfArgumentsMatch(Obj designator, int designatorLocation, int args, int argsLocation)
    {
        if(designator.getKind() != Obj.Meth)
        {
              parser.report_error("Funkcija mora biti deklarisana pre poziva ("+designatorLocation+")", null);
              return false;
        }  
                                
        if(args != designator.getLevel()) 
        {
                parser.report_error(" Broj argumenata funkcije nije dobar."+ designator.getName() +" ("+argsLocation+")", null);
                return false;
        }
        
        for(int i = 0; i < args; i++) 
        {
             Obj o = ((Obj) designator.getLocalSymbols().toArray()[i]);
             Struct s = actParams.get(actParams.size() - (args - i)); // sta ce aoba
             if(!o.getType().compatibleWith(s))
                if(!(o.getType().getKind() != Struct.Class && o.getType().getKind() == s.getKind() && o.getType().getElemType() == s.getElemType() && o.getType().getNumberOfFields() == s.getNumberOfFields()))
             //if (!o.getType().compatibleWith(s) && !IsAssignable(o,s)) 
             {
                 parser.report_error(" Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva. ("+argsLocation+")", null);
                 return false;
             }
        }
        ScopeEntityCounter.IncreaseFunctionCallsCount();
        return true;
    }
    
    public boolean ThisIsSpecified(String name, int nameLocation)
    {
        if(!"this".equals(name)) return false;
     
        if(parser.lastMethod != null) 
        {
          if(!ScopeEntityCounter.IsInClassScope() || parser.lastMethod.getType().getElemType().getKind() == STATIC)
          {
               parser.report_error("This se moze navoditi samo u nestatickim metodama ("+nameLocation+")", null);
          }
          
          isThisSpecified = true;
       } 
       return true;
    }                       

  private final MJParser parser;

  /** Constructor */
  CUP$MJParser$actions(MJParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$MJParser$do_action(
    int                        CUP$MJParser$act_num,
    java_cup.runtime.lr_parser CUP$MJParser$parser,
    java.util.Stack            CUP$MJParser$stack,
    int                        CUP$MJParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MJParser$result;

      /* select the action based on the action number */
      switch (CUP$MJParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // MulopRight ::= ASSIGN_MOD 
            {
              Integer RESULT =null;
		 RESULT = Code.rem ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopRight",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // MulopRight ::= ASSIGN_DIV 
            {
              Integer RESULT =null;
		 RESULT = Code.div ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopRight",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // MulopRight ::= ASSIGN_MUL 
            {
              Integer RESULT =null;
		 RESULT = Code.mul ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopRight",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // MulopLeft ::= MOD 
            {
              Integer RESULT =null;
		 RESULT = Code.rem ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopLeft",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // MulopLeft ::= DIV 
            {
              Integer RESULT =null;
		 RESULT = Code.div ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopLeft",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // MulopLeft ::= MUL 
            {
              Integer RESULT =null;
		 RESULT = Code.mul ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopLeft",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // Mulop ::= MulopRight 
            {
              Integer RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // Mulop ::= MulopLeft 
            {
              Integer RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // AddopRight ::= ASSIGN_SUB 
            {
              Integer RESULT =null;
		 RESULT = Code.sub ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopRight",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // AddopRight ::= ASSIGN_ADD 
            {
              Integer RESULT =null;
		 RESULT = Code.add ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopRight",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // AddopLeft ::= SUB 
            {
              Object RESULT =null;
		 RESULT = Code.sub ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopLeft",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // AddopLeft ::= ADD 
            {
              Object RESULT =null;
		 RESULT = Code.add ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopLeft",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // Addop ::= AddopRight 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // Addop ::= AddopLeft 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // Relop ::= LESS_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.le ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // Relop ::= LESS 
            {
              Integer RESULT =null;
		 RESULT = Code.lt ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // Relop ::= GREATER_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.ge ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // Relop ::= GREATER 
            {
              Integer RESULT =null;
		 RESULT = Code.gt ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // Relop ::= NOT_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.ne ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // Relop ::= EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.eq ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // Assignop ::= MulopRight 
            {
              Integer RESULT =null;
		int mulOpleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int mulOpright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer mulOp = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = mulOp ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignop",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // Assignop ::= AddopRight 
            {
              Integer RESULT =null;
		int addOpleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int addOpright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer addOp = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = addOp ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignop",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // Assignop ::= ASSIGN 
            {
              Integer RESULT =null;
		 RESULT = 0 ; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignop",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // Factor ::= LPAREN Expression RPAREN 
            {
              Obj RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 RESULT = new Obj(Obj.Con, "", expr); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // Factor ::= NEW Type NT$15 LBRACK Expression RBRACK 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$15
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
                if(expr.getKind() == Struct.Int)
                    RESULT = new Obj(Obj.NO_VALUE, "", new Struct(Struct.Array, type));
                else {
                    parser.report_error(": tip expr mora biti int", typeleft);
                    RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                } 
                
                Code.put(Code.newarray);
                Code.put(type == Tab.charType ? 0 : 1); 
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // NT$15 ::= 
            {
              Obj RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                Obj obj = Tab.noObj;
                if(classFields == null)
                    obj = Tab.find(lastDesignator.getName());      
                else  { 
                    for (Obj o : classFields) { 
                        if(o.getName().equals(lastDesignator.getName()))
                            obj = o;
                    }
                } 
                                
                if(obj == Tab.noObj)
                    RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                else {
                    if(obj.getType().getElemType() != type) {
                        parser.report_error("Ne podudaraju se tipovi." +type+ " i "+ obj.getType().getElemType()+"("+typeleft+")",null );
                        RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                    }
                } 
                    
                classFields = null;
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$15",73, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // Factor ::= NEW Type 
            {
              Obj RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                if(type.getKind()!=Struct.Class)
                    parser.report_error("tip prilikom pravljenja objekta mora biti unutrasnja klasa",typeleft);
                else
                {
                if(lastDesignator.getType().getKind() != type.getKind()) {
                      parser.report_error(": tipovi se ne podudaraju ", typeleft);
                      RESULT = new Obj(Obj.NO_VALUE, "", Tab.noType);
                } else
                      RESULT = new Obj(Obj.NO_VALUE, "", type);
                
                }
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // Factor ::= BOOL 
            {
              Obj RESULT =null;
		int booleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int booright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean boo = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
            Obj value = new Obj(Obj.Con, "" + boo, new Struct (Struct.Bool)); 
            value.setAdr(boo? 1:0);
            Code.load(value);
            RESULT = value;  
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // Factor ::= CHAR 
            {
              Obj RESULT =null;
		int chrleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int chrright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		char chr = (char)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
            Obj value = new Obj(Obj.Con, "" + chr, Tab.charType); 
            value.setAdr(chr);
            Code.load(value);
            RESULT = value; 
             
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // Factor ::= NUMBER 
            {
              Obj RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer num = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
            Obj value = new Obj(Obj.Con, "" + num, Tab.intType); 
            value.setAdr(num.intValue());
            Code.load(value);
            RESULT = value;  
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // Factor ::= Designator LPAREN ActParsListOpt RPAREN 
            {
              Obj RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer params = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
            	ScopeEntityCounter.IncreaseFunctionCallsCount();
                if (designator.getKind() != Obj.Meth)
                { 
                    parser.report_error("Funkcija nije deklarisana",designatorleft);
                    RESULT = Tab.noObj;
                }
                else
                {
                    RESULT = new Obj(Obj.Meth, 
                        designator.getName(), 
                        new Struct(designator.getType().getKind()), 
                        designator.getAdr(), 
                        designator.getLevel());   
                }
                
                if(RESULT != Tab.noObj) {
                    if(params == RESULT.getLevel()) {
                        boolean flag = true;
                        for(int i = 0; i < params; i++) {
                            Obj o = ((Obj) designator.getLocalSymbols().toArray()[i]);
                            Struct s = actParams.get(actParams.size() - (params - i));
                             if(!o.getType().compatibleWith(s))
                                if(!(o.getType().getKind() != Struct.Class && o.getType().getKind() == s.getKind() && o.getType().getElemType() == s.getElemType() && o.getType().getNumberOfFields() == s.getNumberOfFields()))
                             //if (!IsAssignable(o,s))
                                    flag = false;
                        }
                        
                        if(!flag)
                            parser.report_error(" Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva.", paramsleft);
                        else {
                            if(RESULT.getType() != Tab.noType)
                                RESULT = new Obj(Obj.Con, "", RESULT.getType());
                                
                            else                            
                                parser.report_error(" Funkcija nema povratnu vrednost.", paramsleft);
                            
                            int destAdr = designator.getAdr() - Code.pc;
                            Code.put(Code.call);
                            Code.put2(destAdr);
                            if(designator.getType().getKind() != Struct.None)
                                Code.put(Code.pop);
                        }
                    } else {
                        parser.report_error(" Broj argumenata funkcije nije dobar."+ RESULT.getName(), paramsleft);                        
                    }
                    for(int i = 0; i < params; i++)
                            actParams.remove(actParams.size() - 1);
                }
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // Factor ::= Designator 
            {
              Obj RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		  RESULT = designator;
                if(designator.getKind() == Obj.Con)
                    Code.load(designator);
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // MulopFactorList ::= Factor 
            {
              Obj RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj result = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = result; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopFactorList",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // MulopFactorList ::= MulopFactorList NT$14 MulopLeft Factor 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$14
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int mflleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int mflright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj mfl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int factleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int factright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj fact = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                    if(fact.getKind() != Obj.Con) 
                            Code.load(fact);
                        
                        Code.put((int)op);
                    if(mfl.getType().getKind() != Struct.Int)
                        {
                            parser.report_error(" " + mfl.getName() + "mora biti int ", mflleft);
                            RESULT = Tab.noObj;
                         }
                     else{
                        if(fact.getType().getKind() != Struct.Int)
                        {
                            parser.report_error(" " + fact.getName() + "mora biti int ", factleft);
                            RESULT = Tab.noObj;
                        }
                        else{
                        RESULT = new Obj(Obj.Con, "rezultat mnozenja", Tab.intType);
                           }
                      }
                        /*RESULT = Tab.noObj;
                        if (GetResultIfBothInt(mfl, mflleft, fact.getType()) != Tab.noObj)
                        {
                            RESULT = new Obj(Obj.Con, "Multiplication result", Tab.intType); 
                        }  */
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MulopFactorList",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // NT$14 ::= 
            {
              Obj RESULT =null;
		int mflleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int mflright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj mfl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                    if(mfl.getKind() != Obj.Con)
                            Code.load(mfl);
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$14",72, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // Term ::= MulopFactorList 
            {
              Obj RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj result = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = result; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // Term ::= MulopFactorList NT$13 MulopRight Term 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int mflleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int mflright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj mfl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int termleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int termright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj term = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
            if(term.getKind() != Obj.Con)
                    Code.load(term);
                    
                Code.put((int)op);
                Code.store(mfl);
            if(mfl.getKind() != Obj.Var && mfl.getKind()!= Obj.Fld && mfl.getKind() != Obj.Elem)
                    {
                    parser.report_error(" " + mfl.getName() + " mora oznacavati  promenljivu, element niza ili polje objekta unutrasnje objekta", mflleft);
                    RESULT = Tab.noObj;
                    }
                else{
                    if(mfl.getType().getKind() != Struct.Int)
                        {
                        parser.report_error(" " + mfl.getName() + "mora biti int ", mflleft);
                        RESULT = Tab.noObj;
                        }
                    else{
                         if(term.getType().getKind() != Struct.Int)
                        {
                            parser.report_error(" " + term.getName() + "mora biti int ", termleft);
                            RESULT = Tab.noObj;
                        }
                        else{
                            RESULT = mfl;
                        }
                    }
                }
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // NT$13 ::= 
            {
              Obj RESULT =null;
		int mflleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int mflright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj mfl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

        if(mfl.getKind() == Obj.Elem) {
                    Code.put(Code.dup2);
                    Code.put(Code.dup2);
                }
                if(mfl.getKind() != Obj.Con)
                    Code.load(mfl); 
        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$13",71, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // AddopTermList ::= Term 
            {
              Obj RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj result = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = result; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopTermList",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // AddopTermList ::= AddopTermList NT$12 AddopLeft Term 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int atlleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int atlright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj atl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int termleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int termright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj term = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                     if(atl.getType().getKind() != Struct.Int)
                        {
                            parser.report_error(" " + atl.getName() + "mora biti int ", atlleft);
                            RESULT = Tab.noObj;
                         }
                     else{
                        if(term.getType().getKind() != Struct.Int)
                        {
                            parser.report_error(" " + term.getName() + "mora biti int ", termleft);
                            RESULT = Tab.noObj;
                        }
                        else{
                        RESULT = new Obj(Obj.Con, "rezultat sabiranja", Tab.intType);
                           }
                      }
                      if(term.getKind() != Obj.Con)
                            Code.load(term);
                        
                        Code.put((int)op);
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopTermList",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // NT$12 ::= 
            {
              Obj RESULT =null;
		int atlleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int atlright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj atl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
if(atl.getKind() != Obj.Con) Code.load(atl);
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$12",70, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // AddopTermCombList ::= AddopTermList 
            {
              Struct RESULT =null;
		int atlleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int atlright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj atl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                        if(atl != null)
                        {
                        RESULT = atl.getType();
                        if(atl.getKind() == Obj.Var || atl.getKind() == Obj.Elem)
                            Code.load(atl);
                        }
                        else
                        RESULT = Tab.noType;
                        
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopTermCombList",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // AddopTermCombList ::= AddopTermList NT$11 AddopRight AddopTermCombList 
            {
              Struct RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (Struct) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int atlleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int atlright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj atl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int atclleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int atclright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct atcl = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                        Code.put((int)op);
                            Code.store(atl);
                            Code.load(atl);
                        if(atl.getKind() != Obj.Var && atl.getKind()!= Obj.Fld && atl.getKind() != Obj.Elem)
                                {
                                parser.report_error(" " + atl.getName() + " mora oznacavati  promenljivu, element niza ili polje objekta unutrasnje objekta", atlleft);
                                RESULT = Tab.noType;
                                }
                            else{
                                if(atl.getType().getKind() != Struct.Int)
                                    {
                                    parser.report_error(" mora biti int ", atlleft);
                                    RESULT = Tab.noType;
                                    }
                                else{
                                     if(atcl.getKind() != Struct.Int)
                                    {
                                        parser.report_error(" mora biti int ", atclleft);
                                        RESULT = Tab.noType;
                                    }
                                    else{
                                        RESULT = atl.getType();
                                    }
                                }
                            }
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AddopTermCombList",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // NT$11 ::= 
            {
              Struct RESULT =null;
		int atlleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int atlright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj atl = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                    if(atl.getKind() == Obj.Elem) {
                                Code.put(Code.dup2);
                                Code.put(Code.dup2);
                            }
                            if(atl.getKind() != Obj.Con)
                    Code.load(atl); 
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$11",69, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // Expression ::= AddopTermCombList 
            {
              Struct RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct result = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                RESULT = result;
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expression",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // Expression ::= SUB AddopTermCombList 
            {
              Struct RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct result = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
                RESULT = result;
                
                if (result.getKind() != Struct.Int)
                {
                     RESULT = Tab.noType;
                     parser.report_error("izraz nakon minusa mora biti tipa int", resultleft);
                }
                Code.put(Code.neg);
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expression",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // CondFact ::= Expression Relop Expression 
            {
              Object RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct exp1 = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct exp2 = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
            if(!exp1.compatibleWith(exp2)) {
                    if(!(exp1.getKind() == exp2.getKind() && exp1.getElemType() == exp2.getElemType() && exp1.getNumberOfFields() == exp2.getNumberOfFields()))
                        parser.report_error(" Tipovi nisu kompatibilni", exp1left);
                }
                else {
                    if(exp1.getKind() == Struct.Array || exp1.getKind() == Struct.Class) {
                        if(op != Code.eq && op != Code.ne)
                            parser.report_error("Uz promenljive tipa klase ili niza mogu se koristiti samo != i ==", exp1left);
                    }
                Code.putFalseJump(op, 0); // dummy
                andAdr.push(Code.pc - 2);   
                }
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // CondFact ::= Expression 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct exp = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
            if(exp.getKind() != Struct.Bool)
                    parser.report_error("Exp mora biti tipa bool", expleft);
            Code.loadConst(0); //expr je bool i samo proverimo da li je jednako sa 0
                Code.putFalseJump(Code.ne, 0); // dummy //ako nije tacan uslov odmah preskacemo AND uslove i idemo na OR ako ima
                andAdr.push(Code.pc - 2);
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // CondTerm ::= CondFact 
            {
              Object RESULT =null;
		
                        Code.putJump(0); 
                        orAdr.push(Code.pc - 2);                    
                        while(!andAdr.empty()) 
                            Code.fixup(andAdr.pop());
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // CondTerm ::= CondTerm AND CondFact 
            {
              Object RESULT =null;
		
                        Code.putJump(0); 
                        orAdr.push(Code.pc - 2);                    
                        while(!andAdr.empty()) 
                            Code.fixup(andAdr.pop());
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // Condition ::= CondTerm 
            {
              Object RESULT =null;
		
        
        Code.putJump(0); 
        endAdr.push(Code.pc - 2);
    
        while(!orAdr.empty()) 
            Code.fixup(orAdr.pop());
                        
        
        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // Condition ::= Condition OR CondTerm 
            {
              Object RESULT =null;
		
        
        Code.putJump(0); 
        endAdr.push(Code.pc - 2);
    
        while(!orAdr.empty()) 
            Code.fixup(orAdr.pop());
                        
        
        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // DesignatorIdent ::= LBRACK NT$10 Expression RBRACK 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Object brack = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		  
            if(expr.getKind() != Struct.Int)
                parser.report_error(" tip u zagradama niza mora biti int a vama je :"+ expr.getKind(),exprleft);
              else {
                    //if(RESULT == null) {
                        if(backupDesig != null)
                            RESULT = lastDesignator = new Obj(Obj.Elem, backupDesig.getName(), backupDesig.getType().getElemType(), backupDesig.getAdr(), backupDesig.getLevel());
                        else
                            RESULT = lastDesignator = Tab.noObj;
                    //}
                }
                
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorIdent",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // NT$10 ::= 
            {
              Obj RESULT =null;
		int brackleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int brackright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object brack = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

            if(lastDesignator.getType().getKind() != Struct.Array) {
                    parser.report_error(": " + lastDesignator.getName() + " nije niz", brackleft);
                    RESULT = Tab.noObj;
            } else
                   backupDesig = lastDesignator;
                   
                   Code.load(lastDesignator);
             
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$10",68, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // DesignatorIdent ::= DOT IDENT 
            {
              Obj RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
            if(!(isThisSpecified || (lastDesignator != null && (lastDesignator.getKind() == Obj.Elem || lastDesignator.getKind() == Obj.Var || lastDesignator.getKind() == Obj.Fld )&& lastDesignator.getType().getKind() == Struct.Class))) {
                        if(lastDesignator.getKind() == Obj.Type) {
                            if(isThisSpecified) {
                                Obj o = Tab.currentScope().getOuter().findSymbol(name);
                                if(o != null) {
                                    if(o.getKind() != Obj.Meth) {
                                        parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                        lastDesignator = Tab.noObj;
                                    } else if(o.getType().getElemType().getKind() != STATIC) {
                                        parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                        lastDesignator = Tab.noObj;
                                    } else {
                                        lastDesignator = o;
                                    }
                                }
                                else { // ako koristimo this a nema ga u toj klasi, proveravamo da li je klasa izvedena
                                      // i ima li u osnovnoj onda
                                    Obj found = null;
                                    if(parser.extendedClass != null) {
                                        for (Obj o1 : parser.extendedClass.getType().getMembers()) {
                                            if(o1.getName().equals(name))
                                                found = o1;
                                        }
                                    }
                                    if(found != null) {
                                        if(found.getKind() != Obj.Meth) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else if(found.getType().getElemType().getKind() != 6) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else {
                                            lastDesignator = found;
                                        }
                                    } else {
                                        parser.report_error("(this." + name + ") nije nadjeno", nameleft);
                                        lastDesignator = Tab.noObj;
                                    }
                                }
                            } else {
                                Obj found = null;
                                if(lastDesignator != null) {
                                    for (Obj o : lastDesignator.getType().getMembers()) { //pronalazimo u klasi ovaj naziv
                                        if(o.getName().equals(name))
                                            found = o;
                                    }
                                    if(found != null){
                                        if(found.getKind() != Obj.Meth) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else if(found.getType().getElemType().getKind() != 6) {
                                            parser.report_error(": za klasu se mogu pozvati samo staticke metode", nameleft);
                                            lastDesignator = Tab.noObj;
                                        } else {
                                            lastDesignator = found;
                                        }
                                    } else {
                                        parser.report_error("(" + lastDesignator.getName() + "." + name + ") nije nadjeno", nameleft);
                                        lastDesignator = Tab.noObj;
                                    }
                                }
                            }
                            isThisSpecified = false;
                            RESULT = lastDesignator;
                        }
                        else {
                            parser.report_error(": " + lastDesignator.getName() + " nije klasa", nameleft);
                            lastDesignator = Tab.noObj;
                        }
                } else {
                    if(isThisSpecified) {
                        Obj o = Tab.currentScope().getOuter().findSymbol(name);
                        if(o != null) {
                            if(o.getType().getKind() == Struct.Array) {
                                lastDesignator = o;
                                if(lastDesignator != null && lastDesignator.getType() != null)
                                    classFields = lastDesignator.getType().getMembers();
                            }
                            lastDesignator = o;
                        }
                        else { // ako koristimo this a nema ga u toj klasi, proveravamo da li je klasa izvedena
                              // i ima li u osnovnoj onda
                            Obj found = null;
                            if(parser.extendedClass != null) {
                                for (Obj o1 : parser.extendedClass.getType().getMembers()) {
                                    if(o1.getName().equals(name))
                                        found = o1;
                                }
                            }
                            if(found != null) {
                                if(found.getType().getKind() == Struct.Array) {
                                    lastDesignator = found;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                lastDesignator = found;
                            } else
                                parser.report_error("(this." + name + ") nije nadjeno", nameleft);
                        }
                    } else {
                        Obj found = null;
                        if(lastDesignator != null) {
                            for (Obj o : lastDesignator.getType().getMembers()) { //pronalazimo u klasi ovaj naziv
                                if(o.getName().equals(name))
                                    found = o;
                            }
                            if(found != null){
                                if(found.getType().getKind() == Struct.Array) {
                                     lastDesignator = found;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                lastDesignator = found;
                            } else
                                parser.report_error("(" + lastDesignator.getName() + "." + name + ") nije nadjeno", nameleft);
                        }
                    }
                    isThisSpecified = false;
                    RESULT = lastDesignator;
                }
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorIdent",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // DesignatorListOpt ::= 
            {
              Obj RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorListOpt",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // DesignatorListOpt ::= DesignatorListOpt DesignatorIdent 
            {
              Obj RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj val = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
                        if (val != null) RESULT = val;
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorListOpt",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // Designator ::= IDENT NT$9 DesignatorListOpt 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int resleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj res = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 if(res != null) RESULT = res; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // NT$9 ::= 
            {
              Obj RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                  if(name.equals("this")) {
                    if(parser.lastMethod != null) {
                        if(ScopeEngine.IsInGlobalScope() || !ScopeEngine.IsInClassMethodScope() ||
                        parser.lastMethod.getType().getElemType().getKind() == STATIC)
                        {
                         parser.report_error("this moze postojati samo u nestatickim metodama", nameleft);
                         }
                            isThisSpecified = true;
                    }
                  } else {
                    Obj o = Tab.currentScope.findSymbol(name);
                    if(o == null) {
                        Obj o1 = Tab.find(name);
                        if(o1 != Tab.noObj) {
                            if(o1.getType().getKind() == Struct.Array)
                                lastDesignator = o1;
                    }
                    else {
                            Obj found = null;
                            if(parser.extendedClass != null) {
                                for (Obj o2 : parser.extendedClass.getType().getMembers()) {
                                    if(o2.getName().equals(name))
                                        found = o2;
                                }
                            }
                            if(found != null) {
                                if(found.getType().getKind() == Struct.Array) {
                                    lastDesignator = found;
                                    if(lastDesignator != null && lastDesignator.getType() != null)
                                        classFields = lastDesignator.getType().getMembers();
                                }
                                o1 = found;
                            } else
                                parser.report_error("" + name + "nije nadjeno "+nameleft,null );
                        }
                        lastDesignator = o1;
                        RESULT = o1;
                    }
                    else {
                      if(parser.lastMethod != null) {
                        if(o.getType().getKind() == Struct.Array)
                            lastDesignator = o;                       
                      }
                        RESULT = lastDesignator = o;
                    }  
                  }
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$9",67, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // ActPars ::= Expression 
            {
              Integer RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                actParams.add(expr);
                RESULT = 1;
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // ActPars ::= ActPars COMMA Expression 
            {
              Integer RESULT =null;
		int argsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer args = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                actParams.add(expr);
                RESULT = args+1;
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // ActParsListOpt ::= 
            {
              Integer RESULT =null;
		 RESULT = 0; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActParsListOpt",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // ActParsListOpt ::= ActPars 
            {
              Integer RESULT =null;
		int argsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer args = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = args; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActParsListOpt",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // DesignatorStatement ::= Designator Assignop error 
            {
              Object RESULT =null;
		 parser.ReportError("Doslo je do prilikom dodele vrednosti pre znaka ;"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // DesignatorStatement ::= Designator DEC 
            {
              Object RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		  
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if(designator.getType().getKind() != Struct.Int)
                                {
                                    parser.report_error("Prilikom INC " + designator.getName() + " mora biti int ", designatorleft);
                                }
                                else
                                {
                                 if(designator.getKind() == Obj.Elem)
                                Code.put(Code.dup2);
                                    Code.load(designator);
                                    Code.put(Code.const_1);
                                    Code.put(Code.sub);
                                    Code.store(designator);
                                }
                            }
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // DesignatorStatement ::= Designator INC 
            {
              Object RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		  
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if(designator.getType().getKind() != Struct.Int)
                                {
                                    parser.report_error("Prilikom INC " + designator.getName() + " mora biti int ", designatorleft);
                                }else
                                {
                                if(designator.getKind() == Obj.Elem)
                                Code.put(Code.dup2);
                            Code.load(designator);
                            Code.put(Code.const_1);
                            Code.put(Code.add);
                            Code.store(designator);
                                }
                            }
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // DesignatorStatement ::= Designator LPAREN ActParsListOpt RPAREN 
            {
              Object RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int argsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int argsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer args = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
                            //CheckIfArgumentsMatch(designator, designatorleft, args, argsleft);
                            if(designator != Tab.noObj) {
                            if((!varArgs && args == designator.getLevel())||(varArgs && args > designator.getLevel())) {
                                boolean flag = true;
                                Obj o=null;
                                for(int i = 0; i < args; i++) {
                                    if(i<designator.getLevel()) o = ((Obj) designator.getLocalSymbols().toArray()[i]);
                                    Struct s = actParams.get(actParams.size() - (args - i));
                                    if(!o.getType().compatibleWith(s))
                                        if(!(o.getType().getKind() != Struct.Class && o.getType().getKind() == s.getKind() && o.getType().getElemType() == s.getElemType() && o.getType().getNumberOfFields() == s.getNumberOfFields()))
                                            flag = false;
                                }
                                
                                if(!flag)
                                    parser.report_error(" Tipovi argumenta funkcije nisu kompatibilni sa argumentima poziva.", argsleft);
                                else{
                                int destAdr = designator.getAdr() - Code.pc;
                                Code.put(Code.call);
                                Code.put2(destAdr);
                                if(designator.getType().getKind() != Struct.None)
                                Code.put(Code.pop);
                                }
                            } else {
                                parser.report_error(" Broj argumenata funkcije nije dobar."+ designator.getName(), argsleft);                     
                            }
                            
                            for (int i =0; i < args ; i++)
                                actParams.remove(actParams.size() - 1);
                                }
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // DesignatorStatement ::= Designator Assignop NT$8 Expression 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                            if(desig.getKind() != Obj.Var && desig.getKind()!= Obj.Fld && desig.getKind() != Obj.Elem)
                                parser.report_error(" " + desig.getName() + " mora oznacavati  promenljivu, element niza ili polje unutar objekta", desigleft);
                            else{
                                boolean comp = true;
                                if(!expr.assignableTo(desig.getType())) {
                                
                                    if(expr.getKind() != desig.getType().getKind())
                                        parser.report_error(""+expr.getKind() +" != " +desig.getType().getKind()+"expr.getKind() != desig.getType().getKind()", desigleft); 
                                    if (expr.getElemType() != desig.getType().getElemType())
                                        parser.report_error(""+expr.getElemType() +" != "+ desig.getType().getElemType()+ " expr.getElemType() != desig.getType().getElemType()", desigleft);
                                    
                                    
                                    if (expr.getNumberOfFields() != desig.getType().getNumberOfFields())
                                        parser.report_error(" expr.getNumberOfFields() != desig.getType().getNumberOfFields()", desigleft);
                                    if (expr.getMembers() == desig.getType().getMembers())
                                        parser.report_error("expr.getMembers() == desig.getType().getMembers()", desigleft);
                                    if(desig.getType().getKind() == Struct.Array && expr.getElemType() == null)
                                        if(!expr.assignableTo(desig.getType().getElemType()))
                                            comp = false;
                                }
                                if(!comp)
                                    parser.report_error(" nekompatibilni tipovi u dodeli vrednosti", desigleft);
                            }
                            if((int)op != 0) 
                                Code.put((int)op); 
                            
                            Code.store(desig);
                            /*
                            if (IsObjectVarElemOrFieldError(designator, designatorleft))
                            {
                                if (!IsAssignable(designator, expr))
                                {
                                    parser.report_error("Nemoguce je dodeliti vrednost tipa "+parser.StructToTypeName(expr) + " variabli tipa " +parser.StructToTypeName(designator.getType())+"("+designatorleft+")" ,null );
                                }
                            }*/
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorStatement",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // NT$8 ::= 
            {
              Object RESULT =null;
		int desigleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int desigright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj desig = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                        if((int)op != 0) { 
                                if(desig.getKind() == Obj.Elem)
                                    Code.put(Code.dup2);
                                Code.load(desig); 
                            }
                        
                        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$8",66, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // CondOpt ::= 
            {
              Object RESULT =null;
		 endAdr.push(-1); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondOpt",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // CondOpt ::= error 
            {
              Object RESULT =null;
		 parser.ReportError("Doslo je do greske u logickom iskazu unutar FOR(...) konstrukcije"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondOpt",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // CondOpt ::= Condition 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondOpt",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // DesignatorOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorOpt",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // DesignatorOpt ::= error 
            {
              Object RESULT =null;
		 parser.ReportError("Doslo je do greske unutar FOR(...) konstrukcije"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorOpt",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // DesignatorOpt ::= DesignatorStatement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorOpt",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // NumOpt ::= 
            {
              Integer RESULT =null;
		 RESULT = 5; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NumOpt",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // NumOpt ::= COMMA NUMBER 
            {
              Integer RESULT =null;
		int widthleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int widthright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer width = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = width; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NumOpt",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // StatementIfElse ::= IF LPAREN error RPAREN Statement ELSE Statement 
            {
              Object RESULT =null;
		 parser.ReportError("Doslo je do greske u logickom izrazu unutar IF-ELSE konstrukcije"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementIfElse",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // StatementIfElse ::= IF LPAREN error RPAREN Statement 
            {
              Object RESULT =null;
		 parser.ReportError("Doslo je do greske u logickom izrazu unutar IF konstrukcije"); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementIfElse",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // StatementIfElse ::= IF LPAREN Condition RPAREN Statement ELSE NT$7 Statement 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 
                    Code.fixup(endAdr.pop());
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementIfElse",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // NT$7 ::= 
            {
              Object RESULT =null;

                    Code.pc += 3; 
                    Code.fixup(endAdr.pop());
                    Code.pc -= 3;
                    
                    Code.putJump(0); // dummy
                    endAdr.push(Code.pc - 2);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$7",65, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // StatementIfElse ::= IF LPAREN Condition RPAREN Statement 
            {
              Object RESULT =null;
		 
                    Code.fixup(endAdr.pop());
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementIfElse",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // Statement ::= LBRACE StatementListOpt RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // Statement ::= PRINT LPAREN Expression NumOpt RPAREN SEMI 
            {
              Object RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int widthleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int widthright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer width = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
                if (IsStructIntCharOrNone(expr, exprleft))
                {
                	ScopeEntityCounter.IncreaseFunctionCallsCount(); 
                     if (expr.getKind() == Struct.Char ) {
                    Code.loadConst(width);
                    Code.put(Code.bprint);
                 }
                 
                 else{
                    Code.loadConst(width);
                    Code.put(Code.print);
                 }
                }
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // Statement ::= READ LPAREN Designator RPAREN SEMI 
            {
              Object RESULT =null;
		int designatorleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int designatorright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj designator = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
                    CorrectTypesForFunctionCalls(designator, designatorleft);
                    if (designator.getType() == Tab.charType ) 
                        Code.put(Code.bprint);           
                     else
                        Code.put(Code.print);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // Statement ::= RETURN Expression SEMI 
            {
              Object RESULT =null;
		int retleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int retright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object ret = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int exprleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct expr = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
                    ReturnCallCheck(retleft, expr);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // Statement ::= RETURN SEMI 
            {
              Object RESULT =null;
		int retleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int retright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object ret = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
                    ReturnCallCheck(retleft, null);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // Statement ::= CONTINUE SEMI 
            {
              Object RESULT =null;
		int semleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int semright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object sem = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                    if (IsNotInForLoop())
                        parser.report_error("Continue naredba se moze izvrsiti samo iz unutar for petlje ", semleft);
                    else
                        Code.putJump(desi.peek());
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // Statement ::= BREAK SEMI 
            {
              Object RESULT =null;
		int semleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int semright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object sem = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
                if (IsNotInForLoop())
                        parser.report_error("Breakovati se moze samo iz unutar for petlje ", semleft);
                    else
                        Code.putJump(endFor.pop() - 1);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // Statement ::= FOR LPAREN DesignatorOpt SEMI NT$2 CondOpt NT$3 SEMI NT$4 DesignatorOpt NT$5 RPAREN NT$6 Statement 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 
                    
                    forStack.pop();
                    Code.putJump(desi.pop());
                    if(endAdr.peek() != -1)
                        Code.fixup(endAdr.pop());
                    else {
                        Code.fixup(noCond.pop());
                        endAdr.pop();
                    }
                    ExitedFor();
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-13)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // NT$6 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
 
                    forStack.push(1); 
                    Code.fixup(forAdr.pop());
                    EnteredFor();
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$6",64, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // NT$5 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
 
                    Code.putJump(cond.pop());
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$5",63, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // NT$4 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

                    desi.push(Code.pc);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$4",62, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // NT$3 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

                    Code.putJump(0);
                    forAdr.push(Code.pc - 2);
                    
                    if(endAdr.peek() != -1) 
                        endFor.push(endAdr.peek()); 
                    else {
                        Code.putJump(0);
                        noCond.push(Code.pc - 2);
                        endFor.push(noCond.peek());
                    }
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$3",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // NT$2 ::= 
            {
              Object RESULT =null;

                    cond.push(Code.pc);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$2",60, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // Statement ::= StatementIfElse 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // Statement ::= DesignatorStatement SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // StatementListOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementListOpt",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // StatementListOpt ::= StatementListOpt Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementListOpt",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // FormalParamDecl ::= Type IDENT 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
                        parser.VariableDeclaration(name, nameleft, Obj.Var);
                        parser.formalParamsCount++; 
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamDecl",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // FormalParamDecl ::= Type IDENT LBRACK RBRACK 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
                        parser.lastType = new Struct(Struct.Array, parser.lastType);
                        parser.VariableDeclaration(name, nameleft, Obj.Var);
                        parser.formalParamsCount++; 
                    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamDecl",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // FormalParamList ::= FormalParamDecl 
            {
              Integer RESULT =null;
		 RESULT = 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // FormalParamList ::= error COMMA FormalParamDecl 
            {
              Integer RESULT =null;
		 parser.ReportError("Doslo je do greske prilikom deklaracije formalnog parametra funkcije pre znaka \",\""); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // FormalParamList ::= FormalParamList COMMA FormalParamDecl 
            {
              Integer RESULT =null;
		int numberOfParamsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int numberOfParamsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer numberOfParams = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 RESULT = numberOfParams + 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormalParamList",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // FormParamsOpt ::= 
            {
              Integer RESULT =null;
		 RESULT = 0; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParamsOpt",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // FormParamsOpt ::= error 
            {
              Integer RESULT =null;
		 parser.ReportError("Doslo je do greske prilikom deklaracije formalnog parametra funkcije pre znaka \")\""); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParamsOpt",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // FormParamsOpt ::= VarArgs 
            {
              Integer RESULT =null;
		 RESULT = 1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParamsOpt",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // FormParamsOpt ::= FormalParamList VarArgs 
            {
              Integer RESULT =null;
		int numOfParamsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int numOfParamsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Integer numOfParams = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 RESULT = numOfParams+1; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParamsOpt",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // FormParamsOpt ::= FormalParamList 
            {
              Integer RESULT =null;
		int resultleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int resultright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer result = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = result; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParamsOpt",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // VarArgs ::= COMMA Type DOT DOT DOT IDENT 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                parser.lastType = new Struct(Struct.Array, parser.lastType);
                parser.VariableDeclaration(name, nameleft, Obj.Var);    
                parser.formalParamsCount++; 
            
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarArgs",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // TypeVoid ::= VOID 
            {
              Struct RESULT =null;
		 RESULT = parser.lastType = Tab.noType;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("TypeVoid",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // TypeVoid ::= Type 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = type; // = parser.lastType
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("TypeVoid",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // StaticOpt ::= 
            {
              Boolean RESULT =null;
		 RESULT = false;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StaticOpt",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // StaticOpt ::= STATIC 
            {
              Boolean RESULT =null;
		 RESULT = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StaticOpt",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // MethodDecl ::= StaticOpt TypeVoid IDENT LPAREN NT$1 FormParamsOpt RPAREN MethodVarDeclListOpt LBRACE StatementListOpt RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		int isStaticMethodleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).left;
		int isStaticMethodright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).right;
		Boolean isStaticMethod = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;
		int methodNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int methodNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		String methodName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		int numOfParamsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int numOfParamsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Integer numOfParams = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		 
    if (numOfParams == null) numOfParams = 0;
    
    if (methodName.equals("main") &&  numOfParams >0)
    {
        parser.report_error("Main ne sme imati argumente!", numOfParamsleft);
    }
    parser.lastMethod.setLevel(numOfParams);
    
    if (!parser.returnHappend && type != Tab.noType)
    {
        parser.report_error("Fali vam povratna vrednost funkcije!",null);
    }
    Code.mainPc = parser.lastMethod.getAdr();
    parser.MethodEnding();
   parser.returnHappend = false;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // NT$1 ::= 
            {
              Object RESULT =null;
		int isStaticMethodleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int isStaticMethodright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Boolean isStaticMethod = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int methodNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int methodNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String methodName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

                    parser.MethodDeclaration(methodName, methodNameleft, type, typeleft, isStaticMethod);
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$1",59, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // MethodDeclListOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclListOpt",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // MethodDeclListOpt ::= MethodDeclListOpt MethodDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclListOpt",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // MethodDeclOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclOpt",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // MethodDeclOpt ::= LBRACE MethodDeclListOpt RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclOpt",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // MethodIdentList ::= Var 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodIdentList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // MethodIdentList ::= MethodIdentList COMMA Var 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodIdentList",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // MethodVarDecl ::= Type MethodIdentList SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodVarDecl",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // MethodVarDeclListOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodVarDeclListOpt",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // MethodVarDeclListOpt ::= MethodVarDeclListOpt MethodVarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodVarDeclListOpt",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // ExtendsOpt ::= 
            {
              Struct RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExtendsOpt",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // ExtendsOpt ::= EXTENDS error 
            {
              Struct RESULT =null;
		
                    parser.ReportError("Doslo je do greske prilikom deklaracije prosirenja natklase"); 
                    RESULT = Tab.noType;
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExtendsOpt",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // ExtendsOpt ::= EXTENDS Type 
            {
              Struct RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct type = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
                    if(!(type.getKind() == Struct.Class))
                        parser.report_error(" Tip objekta iz kog se pokusava izvodjenje mora biti klasa! ", typeleft);
                    else 
                        parser.extendedClass = Tab.find(parser.curTypeName);
                    RESULT = type;
                
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExtendsOpt",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // ClassDecl ::= CLASS IDENT ExtendsOpt LBRACE NT$0 ClassVarDeclListOpt MethodDeclOpt RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		int extendsClassleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int extendsClassright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Struct extendsClass = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		  
    SaveExtendedClassMembers(extendsClass);
    parser.ClassEnding();

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // NT$0 ::= 
            {
              Object RESULT =null;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String className = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int extendsClassleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int extendsClassright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct extendsClass = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
 
    parser.ClassDeclaration(className, classNameleft);

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$0",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // ClassVarDecl ::= VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassVarDecl",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // ClassVarDecl ::= STATIC VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassVarDecl",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // ClassVarDeclListOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassVarDeclListOpt",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // ClassVarDeclListOpt ::= ClassVarDeclListOpt ClassVarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassVarDeclListOpt",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // Type ::= IDENT 
            {
              Struct RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
            RESULT = parser.CheckTypeAndUpdateLastType(name, nameleft);
        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Type",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // Var ::= IDENT 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 parser.VariableDeclaration(name, nameleft, Obj.Var); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Var",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // Var ::= IDENT LBRACK RBRACK 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 ScopeEntityCounter.IncreaseVariableCount();
            if (ScopeEngine.IsInGlobalScope()) {
                    // parser.globalVarCount++;
                      if( Tab.currentScope.findSymbol(name) != null)
                      parser.report_error(" " + name + " vec deklarisano", nameleft);
                      else {
                          if( parser.lastType != null && parser.lastType != Tab.noType)
                              Tab.insert(Obj.Var, name, new Struct(Struct.Array, parser.lastType));
                              parser.report_info("Definisana globalna promenljiva " + name + " tipa: "+ Struct.Array+" na liniji " + nameleft, null);
                          }    
                }
                else
             if(ScopeEngine.IsInMainScope()) {
                    //parser.localVarCount++;
                    if( Tab.currentScope.findSymbol(name) != null)
                      parser.report_error(" " + name + " vec deklarisano", nameleft);
                      else {
                          if( parser.lastType != null && parser.lastType != Tab.noType)
                                Tab.insert(Obj.Var, name, new Struct(Struct.Array, parser.lastType));
                              parser.report_info("Definisana lokalna promenljiva " + name + " tipa "+Struct.Array+" na liniji " + nameleft, null);
                          }
                } else if(ScopeEngine.IsInMethodScope()) {
                    if( Tab.currentScope.findSymbol(name) != null)
                      parser.report_error(" " + name + " vec deklarisano", nameleft);
                      else {
                          if( parser.lastType != null && parser.lastType != Tab.noType)
                              Tab.insert(Obj.Var, name, new Struct(Struct.Array, parser.lastType));
                              parser.report_info("Definisana lokalna promenljiva " + name + " tipa: "+Struct.Array+" na liniji " + nameleft, null);
                          }
                } else if(ScopeEngine.IsInClassScope()) {
                    //parser.varClassDeclCount++;
                    if( Tab.currentScope.findSymbol(name) != null)
                      parser.report_error(" " + name + " vec deklarisano", nameleft);
                      else {
                          if( parser.lastType != null && parser.lastType != Tab.noType)
                              Tab.insert(Obj.Var, name, new Struct(Struct.Array, parser.lastType));
                              parser.report_info("Definisano polje klase " + name + " tipa: "+Struct.Array+" na liniji " + nameleft, null);
                          }
                }
        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Var",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // VarDeclList ::= Var 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // VarDeclList ::= error COMMA Var 
            {
              Object RESULT =null;
		 parser.ReportVarDeclError(','); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // VarDeclList ::= VarDeclList COMMA Var 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // VarDecl ::= Type error SEMI 
            {
              Object RESULT =null;
		 parser.ReportVarDeclError(';'); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // VarDecl ::= Type VarDeclList SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // Const ::= NUMBER 
            {
              Obj RESULT =null;
		 RESULT = new Obj(Obj.Con, "", Tab.intType); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Const",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // Const ::= CHAR 
            {
              Obj RESULT =null;
		 RESULT = new Obj(Obj.Con, "", Tab.charType); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Const",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // Const ::= BOOL 
            {
              Obj RESULT =null;
		 RESULT = new Obj(Obj.Con, "", boolType); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Const",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // ConstIdent ::= IDENT ASSIGN Const 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj type = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
    parser.VariableDeclaration(name, nameleft, Obj.Con, type, typeleft);

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstIdent",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // ConstDeclList ::= ConstIdent 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclList",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // ConstDeclList ::= ConstDeclList COMMA ConstIdent 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclList",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // ConstDecl ::= CONST Type ConstDeclList SEMI 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // Decl ::= VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Decl",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // Decl ::= ConstDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Decl",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // Decl ::= ClassDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Decl",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // DeclListOpt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclListOpt",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // DeclListOpt ::= DeclListOpt Decl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclListOpt",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // ProgramName ::= IDENT 
            {
              Obj RESULT =null;
		int progNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int progNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String progName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
    RESULT = Tab.insert(Obj.Prog, progName, Tab.noType);
    Tab.openScope();
    

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgramName",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= Program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		RESULT = start_val;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MJParser$parser.done_parsing();
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // Program ::= PROG ProgramName DeclListOpt LBRACE MethodDeclListOpt RBRACE 
            {
              Object RESULT =null;
		int progNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int progNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj progName = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		
    parser.HandleProgramEnd(progName, progNameleft);
    Code.dataSize = Tab.currentScope().getnVars();
    

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Program",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

