package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.concepts.*;
import java.lang.Boolean;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
	boolean isSyntaxErrorDetected = false;
	Logger log = Logger.getLogger(getClass());

    // following redefined methods are used for redefinition of error messages 
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSyntax error", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal error, parsing cannot be continued", cur_token);
    }

    public void report_error(String message, Object info) {
    	isSyntaxErrorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" on line ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
:}

scan with {:
	// Scanner is called for getting new token from lexical analyzator
	// Here we can intercept token fetching in order to do something with token
	
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

/* Unused */
terminal FOR, STATIC, EXTENDS, IF, ELSE, DOT, DOTDOT, NOT_EQUAL, ARROW, ASSIGN_ADD, ASSIGN_SUB, AND, EQUAL, ASSIGN_DIV;
terminal BREAK, STARSTAR, GREATER, ASSIGN_MUL, ASSIGN_MOD, LESS_EQUAL, GREATER_EQUAL, CLASS, HASHTAG, CONTINUE, OR,LESS;
/* Unused */

terminal PROG, LBRACE, RBRACE, LPAREN, RPAREN, LBRACK, RBRACK, DEC, INC, SEMI, COMMA, ASSIGN, VOID;
terminal ADD, SUB, MUL, DIV, MOD, NEW, CONST;
terminal READ, PRINT, RETURN;
terminal Boolean BOOL;
terminal char CHAR;
terminal Integer NUMBER;
terminal String IDENT;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgramName, Designator, DesigName, Addop, Mulop, Var, DesigWithOptPostfixOperation, Const, OptValueAssign;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Factor, OptDeclList, TermAddopList, FactorMulopList, FuncCall, OptArray, OptCommaNumber, ExprOrError;

nonterminal Statement, DesignatorStatement, AssignExpr;
nonterminal Decl/*, OptBrackExpr*/;
nonterminal Boolean OptArrayBrackets; 

/* July 2017/2018 Addition for level A */
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl, MethodTypeName;
nonterminal rs.etf.pp1.symboltable.concepts.Struct FormalParamDecl;
nonterminal OptMethodDeclList/*, FormalParam*/, OptStatementList;
nonterminal java.util.List OptArgumentParamList, ArgumentParamList, OptFormalParamList, FormalParamList;
nonterminal VarDeclList;
/* End A  */

Program ::= (Program) PROG ProgramName:progName OptDeclList LBRACE OptMethodDeclList RBRACE ;

ProgramName ::= (ProgramName) IDENT:pName;

Statement ::= 	(DesignatorStmt) DesignatorStatement SEMI |
				(ReadStmt) READ LPAREN Designator:designator RPAREN SEMI |
				(PrintStmt) PRINT LPAREN Expr:expr OptCommaNumber:width RPAREN SEMI |
				(ReturnVoid) RETURN SEMI |
				(ReturnExpr) RETURN Expr:returnType SEMI
				;

OptCommaNumber ::= (CommaNumber) COMMA Expr:num | (NoCommaNumber) /* epsilon */ ;

DesignatorStatement ::= (AssignmentStmt) Designator:designator AssignExpr:expr |
						(PostfixStmt) DesigWithOptPostfixOperation:designator |
						(StmtFuncCall)  FuncCall
						;
AssignExpr ::= (AssignExpr) ASSIGN ExprOrError:expr;

OptValueAssign ::= (AssignExpression) ASSIGN Const:val | (NoAssignExpr) /* epsilon */;

FuncCall ::= (FuncCall) Designator:funcName LPAREN OptArgumentParamList:args RPAREN ;

ExprOrError ::= (Expression) Expr:expr | (Err) error:err {: parser.log.debug("Error successfully recovered in expression after assign operator before \";\"  on line " + errleft); :} ;

DesigWithOptPostfixOperation ::= (DecOperation) Designator:designator DEC  | (IncOperation) Designator:designator  INC | (NoPosfixOperation) Designator:designator;

Expr ::= (Expr) TermAddopList:res ;

TermAddopList ::= (TermAddops) TermAddopList:res Addop:op Term:te |  (SingleTerm) Term:res ;

Term::= (Term) FactorMulopList:res ;

FactorMulopList::= (FactorMulops) FactorMulopList:res Mulop:op Factor:fact   | (SingleFactor) Factor:res | (MinusFactor) SUB Factor:res;

Factor ::=  (ConstVar) Const:val |
			(ParenExpr) LPAREN Expr:expr RPAREN |
			(NewType) NEW Type:creationType OptArray:arrayLength |
			(DefVarWithOptPostfixOp) DesigWithOptPostfixOperation:designator |
			(ExprFuncCall) FuncCall
			;

Const ::= 	(ConstNum) NUMBER:numm | 
			(ConstChar) CHAR:charr |
			(ConstBool) BOOL:booll ;

 /* OptBrackExpr ::= (BrackExpr) LBRACK Expr:val RBRACK | (NoBrackExpr)  epsilon ; */

Designator ::= (Designator) DesigName:designatorName OptArray:indexedElement ;

DesigName ::= (DesigName) IDENT:designatorName;

OptArray ::= (ArrayIndexer) LBRACK Expr:val RBRACK | (NoArrayIndexer) /* epsilon */ ;

Addop ::= (AddopAdd) ADD | (AddopSub) SUB ;

Mulop ::= (MulopMul) MUL | (MulopDiv) DIV | (MulopMod) MOD ;

OptDeclList ::= (VarDeclLists) Decl OptDeclList | (NoDecl) /* epsilon */ ;

// VAR DECLARATION

Decl ::= (VarDeclNoErr) Type VarDeclList:list SEMI |
			(VarDeclError) Type error:err {: parser.log.debug("Error successfully recovered in variable declarations, before \";\"  on line " + errleft); :}
				SEMI ;

VarDeclList ::= (Vars) VarDeclList COMMA Var |
				(SingleVar) Var |
				(ErrorCommaVar) error:err  {: parser.log.debug("Error successfully recovered in variable declarations, before \",\"  on line " + errleft); :}
				COMMA Var ;
				
Var ::= (Var) IDENT:varName OptArrayBrackets:isArray OptValueAssign;

OptArrayBrackets ::= (ArrayType) LBRACK RBRACK | (SimpleType) /* epsilon */ ;

Type ::= (NotVoidType) IDENT:typeName | (ConstType) CONST IDENT:typeName | (VoidType) VOID;

/* July 2017/2018 Addition for level A */

OptMethodDeclList ::= (MethodDeclList) MethodDecl OptMethodDeclList | (NoMethodDecl) /* epsilon */ ;

MethodDecl ::= (MethodDecl) MethodTypeName:signature LPAREN OptFormalParamList:numOfParams RPAREN OptDeclList LBRACE OptStatementList RBRACE ;

MethodTypeName ::= (MethodTypeName) Type:retType OptArrayBrackets:isArray IDENT:methodName ;

OptFormalParamList ::= (FormalParamListOpt) FormalParamList:formalParams | 
						(FormalParamError) error:err  {: parser.log.debug("Error successfully recovered in formal parameters, before \")\"  on line " + errleft); :}
						|
						(NoFormalParam) /* epsilon */ ;

FormalParamList ::= (FormalParamDeclList) FormalParamList:formalParams COMMA FormalParamDecl:param  |
					(SingleFormalParamDecl) FormalParamDecl:param |
					(ErrorInFormalParamDecl) error:err {: parser.log.debug("Error successfully recovered in formal parameters, before \",\"  on line " + errleft); :}
					COMMA FormalParamDecl ;

FormalParamDecl ::= (FormalParamDecl) Type:paramType IDENT:paramName OptArrayBrackets:isArray ;

OptStatementList ::= (StatementList) Statement OptStatementList | (NoStatement) /* epsilon */ ;

OptArgumentParamList ::= (ArgumentParams) ArgumentParamList | (NoArgumentParams) /* epsilon */ ;

ArgumentParamList ::= (MultipleArgumentParams) Expr:expr COMMA ArgumentParamList:args | (ArgumentParam) Expr:expr ;

/* End A  */