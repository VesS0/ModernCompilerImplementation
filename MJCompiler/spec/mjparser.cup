package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.concepts.*;
import java.lang.Boolean;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
	boolean isSyntaxErrorDetected = false;
	Logger log = Logger.getLogger(getClass());

    // following redefined methods are used for redefinition of error messages 
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	isSyntaxErrorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
:}

scan with {:
	// Scanner is called for getting new token from lexical analyzator
	// Here we can intercept token fetching in order to do something with token
	
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

/* Unused */
terminal FOR, STATIC, EXTENDS, IF, ELSE, DOT, DOTDOT, NOT_EQUAL, ARROW, ASSIGN_ADD, ASSIGN_SUB, AND, EQUAL, ASSIGN_DIV;
terminal BREAK, STARSTAR, GREATER, ASSIGN_MUL, ASSIGN_MOD, LESS_EQUAL, GREATER_EQUAL, CLASS, HASHTAG, CONTINUE, OR,LESS;
/* Unused */

terminal PROG, LBRACE, RBRACE, LPAREN, RPAREN, LBRACK, RBRACK, DEC, INC, SEMI, COMMA, ASSIGN, VOID;
terminal ADD, SUB, MUL, DIV, MOD, NEW, CONST;
terminal READ, PRINT, RETURN;
terminal Boolean BOOL;
terminal char CHAR;
terminal Integer NUMBER;
terminal String IDENT;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgramName, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Factor, OptVarDeclList, TermAddopList, FactorMulopList, FuncCall, OptArray, OptCommaNumber, ExprOrError;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Const;

nonterminal Statement, DesignatorStatement;
nonterminal VarDecl/*, OptBrackExpr*/, VarType;
nonterminal Addop, Mulop, OptPostfixOperation;
nonterminal Boolean OptConst, OptArrayBrackets; 

/* July 2017/2018 Addition for level A */
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl, MethodTypeName;
nonterminal rs.etf.pp1.symboltable.concepts.Struct FormalParamList, FormalParamDecl;
nonterminal OptMethodDeclList/*, FormalParam*/, OptFormalParamList, OptStatementList;
nonterminal OptArgumentParamList, ArgumentParamList;
nonterminal VarList, SemiCommaVarList;
/* End A  */

Program ::= (Program) PROG ProgramName:progName OptVarDeclList LBRACE OptMethodDeclList RBRACE ;

ProgramName ::= (ProgramName) IDENT:pName;

Statement ::= 	(DesignatorStmt) DesignatorStatement SEMI |
				(ReadStmt) READ LPAREN Designator:designator RPAREN SEMI |
				(PrintStmt) PRINT LPAREN Expr:expr OptCommaNumber:width RPAREN SEMI |
				(ReturnVoid) RETURN SEMI |
				(ReturnExpr) RETURN Expr:returnType SEMI
				;

OptCommaNumber ::= (CommaNumber) COMMA Expr:num | (NoCommaNumber) /* epsilon */ ;

DesignatorStatement ::= (AssignmentStmt) Designator:designator ASSIGN ExprOrError:expr |
						(PostfixStmt) Designator:designator OptPostfixOperation:op |
						(StmtFuncCall)  FuncCall
						;

FuncCall ::= (FuncCall) Designator:funcName LPAREN OptArgumentParamList:args RPAREN ;

ExprOrError ::= (Expression) Expr:expr | (Err) error:err {: parser.log.debug("Error successfully recovered in expression after assign operator before \";\"  on line " + errleft); :} ;

OptPostfixOperation ::= (DecOperation) DEC  | (IncOperation) INC | (NoPosfixOperation) /* epsilon */ ;

Expr ::= (TermAddopListExprSub) SUB TermAddopList:res |
		 (TermAddopListExpr) TermAddopList:res |
		 (ExprFuncCall) FuncCall
		 ;

TermAddopList ::= (TermAddops) Term Addop:op TermAddopList:res |  (SingleTerm) Term:res ;

Term::= (Term) FactorMulopList:res ;

FactorMulopList::= (FactorMulops) Factor:fact Mulop:op FactorMulopList:res | (SingleFactor) Factor:res ;

Factor ::=  (ConstVar) Const:val |
			(ParenExpr) LPAREN Expr:expr RPAREN |
			(NewType) NEW Type:creationType OptArray:arrayLength |
			(DefVarWithOptPostfixOp) Designator:designator OptPostfixOperation:op 
			/* |(FuncCall) Designator LPAREN OptArgumentParamList RPAREN */ 
			;

Const ::= 	(ConstNum) NUMBER:numm | 
			(ConstChar) CHAR:charr |
			(ConstBool) BOOL:booll ;

 /* OptBrackExpr ::= (BrackExpr) LBRACK Expr:val RBRACK | (NoBrackExpr)  epsilon ; */

Designator ::= (Designator) IDENT:designatorName OptArray:indexedElement ;

OptArray ::= (ArrayIndexer) LBRACK Expr:val RBRACK | (NoArrayIndexer) /* epsilon */ ;

Addop ::= (AddopAdd) ADD | (AddopSub) SUB ;

Mulop ::= (MulopMul) MUL | (MulopDiv) DIV | (MulopMod) MOD ;

OptVarDeclList ::= (VarDeclList) VarDecl OptVarDeclList | (NoVarDecl) /* epsilon */ ;

VarDecl ::= (VarDecl) VarType VarList:list ;

VarType ::= (VarType) OptConst:isConst Type:varType;

OptConst ::= (ConstType) CONST | (NotConstType) /* epsilon */ ;

VarList ::= (Vars) IDENT:varName OptArrayBrackets:isArray /* here insert! */ SemiCommaVarList:list |
(ParamDefinitionError) error:err
{: parser.log.debug("Error successfully recovered in variable definition before \",\" or \";\" on line " + errleft); :}
SemiCommaVarList ;

SemiCommaVarList ::= (Semi) SEMI | (CommaVarDecl) COMMA VarList:list ;

OptArrayBrackets ::= (ArrayType) LBRACK RBRACK | (SimpleType) /* epsilon */ ;

Type ::= (NotVoidType) IDENT:typeName | (VoidType) VOID;

/* July 2017/2018 Addition for level A */

OptMethodDeclList ::= (MethodDeclList) MethodDecl OptMethodDeclList | (NoMethodDecl) /* epsilon */ ;

MethodDecl ::= (MethodDecl) MethodTypeName:signature LPAREN OptFormalParamList:numOfParams RPAREN OptVarDeclList LBRACE OptStatementList RBRACE ;

MethodTypeName ::= (MethodTypeName) OptConst:isConst Type:retType OptArrayBrackets:isArray IDENT:methodName ;

OptFormalParamList ::= (FormalParamListOpt) FormalParamList:formalParams | (NoFormalParam) /* epsilon */ ;

FormalParamList ::= (FormalParamDeclList) FormalParamDecl:param COMMA FormalParamList:formalParams | (SingleFormalParamDecl) FormalParamDecl:param ;

FormalParamDecl ::= (FormalParamDecl) OptConst:isConst Type:paramType IDENT:paramName OptArrayBrackets:isArray ;

OptStatementList ::= (StatementList) Statement OptStatementList | (NoStatement) /* epsilon */ ;

OptArgumentParamList ::= (ArgumentParams) ArgumentParamList | (NoArgumentParams) /* epsilon */ ;

ArgumentParamList ::= (MultipleArgumentParams) Expr:expr COMMA ArgumentParamList:args | (ArgumentParam) Expr:expr ;

/* End A  */