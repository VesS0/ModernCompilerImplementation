package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	boolean errorDetected = false;
	Logger log = Logger.getLogger(getClass());

    // following redefined methods are used for redefinition of error messages 
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
:}

scan with {:
	// Scanner is called for getting new token from lexical analyzator
	// Here we can intercept token fetching in order to do something with token
	
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

/* Unused */
terminal FOR, STATIC, EXTENDS, IF, ELSE, DOT, DOTDOT, NOT_EQUAL, ARROW, VOID, ASSIGN_ADD, ASSIGN_SUB, AND, EQUAL, ASSIGN_DIV;
terminal BREAK, STARSTAR, GREATER, ASSIGN_MUL, ASSIGN_MOD, LESS_EQUAL, GREATER_EQUAL, CLASS, HASHTAG, CONTINUE, OR,LESS;
/* Unused */

terminal PROG, LBRACE, RBRACE, LPAREN, RPAREN, LBRACK, RBRACK, DEC, INC, SEMI, COMMA, ASSIGN;
terminal ADD, SUB, MUL, DIV, MOD, CHAR, BOOL, NEW, CONST;
terminal READ, PRINT, RETURN;
terminal Integer NUMBER;
terminal String IDENT;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgramName, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Factor, OptVarDeclList;


nonterminal Statement Statement;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ExprOrError ExprOrError;
nonterminal OptTermAddopList OptTermAddopList;
nonterminal OptFactorMulopList OptFactorMulopList;
nonterminal VarDecl VarDecl;
nonterminal OptBrackExpr OptBrackExpr;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal OptPostfixOperation OptPostfixOperation;
nonterminal OptCommaNumber OptCommaNumber;
nonterminal OptConst OptConst; 
nonterminal OptArrayIndexer OptArrayIndexer;
nonterminal OptArrayBrackets OptArrayBrackets;
nonterminal Const Const;

/* July 2017/2018 Addition for level A */
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl;
nonterminal OptMethodDeclList OptMethodDeclList;
nonterminal FormalParam FormalParam;
nonterminal FormalParamList FormalParamList;
nonterminal FormalParamDecl FormalParamDecl;
nonterminal OptFormalParamList OptFormalParamList;
nonterminal OptStatementList OptStatementList;
nonterminal OptActualParamList OptActualParamList;
nonterminal OptMultipleActualParamList OptMultipleActualParamList;
nonterminal ActualParamList ActualParamList;
nonterminal MethodTypeName MethodTypeName;
nonterminal MethodReturnType MethodReturnType;
nonterminal Var Var;
nonterminal SemiCommaVarDecl SemiCommaVarDecl;
/* End A  */

Program ::= (Program) PROG ProgramName:progName OptVarDeclList:O1 LBRACE OptMethodDeclList:O2 RBRACE {: RESULT=new Program(progName, O1, O2); RESULT.setLine(progNameleft); :} ;

ProgramName ::= (ProgramName) IDENT:pName {: RESULT=new ProgramName(pName); RESULT.setLine(pNameleft); :};

Statement ::= 	(DesignatorStmt) DesignatorStatement:D1 SEMI {: RESULT=new DesignatorStmt(D1); RESULT.setLine(D1left); :} |
				(ReadStmt) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadStmt(D1); RESULT.setLine(D1left); :} |
				(PrintStmt) PRINT LPAREN Expr:E1 OptCommaNumber:O2 RPAREN SEMI {: RESULT=new PrintStmt(E1, O2); RESULT.setLine(E1left); :} |
				(ReturnVoid) RETURN SEMI {: RESULT=new ReturnVoid(); :} |
				(ReturnExpr) RETURN Expr:returnType SEMI {: RESULT=new ReturnExpr(returnType); RESULT.setLine(returnTypeleft); :}
				;

OptCommaNumber ::= (CommaNumber) COMMA NUMBER:N1 {: RESULT=new CommaNumber(N1); RESULT.setLine(N1left); :} | (NoCommaNumber) {: RESULT=new NoCommaNumber(); :} /* epsilon */ ;

DesignatorStatement ::= (AssignmentStmt) Designator:D1 ASSIGN ExprOrError:E2 {: RESULT=new AssignmentStmt(D1, E2); RESULT.setLine(D1left); :} |
						(PostfixStmt) Designator:D1 OptPostfixOperation:O2 {: RESULT=new PostfixStmt(D1, O2); RESULT.setLine(D1left); :} |
						(ProcCall)  Designator:funcName LPAREN OptActualParamList:O1 RPAREN {: RESULT=new ProcCall(funcName, O1); RESULT.setLine(funcNameleft); :}
						;

ExprOrError ::= Expr:E1 {: RESULT=new ExprOrErrorDerived1(E1); RESULT.setLine(E1left); :} | error:err {: parser.log.debug("Error successfully recovered in expression after assign operator before \";\"  on line " + errleft); :} {: RESULT=new ExprOrErrorDerived2(); :} ;

OptPostfixOperation ::= (DecOperation) DEC {: RESULT=new DecOperation(); :}  | (IncOperation) INC {: RESULT=new IncOperation(); :} | (NoPosfixOperation) {: RESULT=new NoPosfixOperation(); :} /* epsilon */ ;

Expr ::= (TermAddopListExpr) SUB Term:T1 OptTermAddopList:O2 {: RESULT=new TermAddopListExpr(T1, O2); RESULT.setLine(T1left); :} |
		 (TermAddopListExprNoSub) Term:T1 OptTermAddopList:O2 {: RESULT=new TermAddopListExprNoSub(T1, O2); RESULT.setLine(T1left); :}
		 | (FuncCall) Designator:D1 LPAREN OptActualParamList:O2 RPAREN {: RESULT=new FuncCall(D1, O2); RESULT.setLine(D1left); :} /* optionally move down */
		 ;

OptTermAddopList ::= (TermAddopList) Addop:A1 Term:T2 OptTermAddopList:O3 {: RESULT=new TermAddopList(A1, T2, O3); RESULT.setLine(A1left); :} | (NoTerm) {: RESULT=new NoTerm(); :} /* epsilon */ ;

Term::= (Term) Factor:F1 OptFactorMulopList:O2 {: RESULT=new Term(F1, O2); RESULT.setLine(F1left); :} ;

OptFactorMulopList::= (FactorMulopList) Mulop:M1 Factor:F2 OptFactorMulopList:O3 {: RESULT=new FactorMulopList(M1, F2, O3); RESULT.setLine(M1left); :} | (NoFactor) {: RESULT=new NoFactor(); :} /* epsilon */ ;

Factor ::=  (ConstVar) Const:C1 {: RESULT=new ConstVar(C1); RESULT.setLine(C1left); :} |
			(ParenExpr) LPAREN Expr:E1 RPAREN {: RESULT=new ParenExpr(E1); RESULT.setLine(E1left); :} |
			(NewType) NEW Type:T1 OptBrackExpr:O2 {: RESULT=new NewType(T1, O2); RESULT.setLine(T1left); :} |
			(DefinedVariable) Designator:D1 OptPostfixOperation:O2 {: RESULT=new DefinedVariable(D1, O2); RESULT.setLine(D1left); :} /* |(FuncCall) Designator LPAREN OptActualParamList RPAREN */ ;

Const ::= 	(ConstNum) NUMBER:N1 {: RESULT=new ConstNum(N1); RESULT.setLine(N1left); :} | 
			(ConstChar) CHAR {: RESULT=new ConstChar(); :} |
			(ConstBool) BOOL {: RESULT=new ConstBool(); :} ;

OptBrackExpr ::= (BrackExpr) LBRACK Expr:E1 RBRACK {: RESULT=new BrackExpr(E1); RESULT.setLine(E1left); :} | (NoBrackExpr) {: RESULT=new NoBrackExpr(); :} /* epsilon */ ;

Designator ::= (DesignatorSimple) IDENT:I1 OptArrayIndexer:O2 {: RESULT=new DesignatorSimple(I1, O2); RESULT.setLine(I1left); :} ;

OptArrayIndexer ::= (ArrayIndexer) LBRACK Expr:E1 RBRACK {: RESULT=new ArrayIndexer(E1); RESULT.setLine(E1left); :} | (NoArrayIndexer) {: RESULT=new NoArrayIndexer(); :} /* epsilon */ ;

Addop ::= (AddopAdd) ADD {: RESULT=new AddopAdd(); :} | (AddopSub) SUB {: RESULT=new AddopSub(); :} ;

Mulop ::= (MulopMul) MUL {: RESULT=new MulopMul(); :} | (MulopDiv) DIV {: RESULT=new MulopDiv(); :} | (MulopMod) MOD {: RESULT=new MulopMod(); :} ;

OptVarDeclList ::= (VarDeclList) VarDecl:V1 OptVarDeclList:O2 {: RESULT=new VarDeclList(V1, O2); RESULT.setLine(V1left); :} | (NoVarDecl) {: RESULT=new NoVarDecl(); :} /*ERROR COMMA VarDecl | */ /* epsilon */ ;

VarDecl ::= (VarDecl) OptConst:O1 Type:varType Var:V2 {: RESULT=new VarDecl(O1, varType, V2); RESULT.setLine(O1left); :} ;

OptConst ::= (ConstType) CONST {: RESULT=new ConstType(); :} | (NotConstType) {: RESULT=new NotConstType(); :} /* epsilon */ ;

Var ::= (VarList) IDENT:varName OptArrayBrackets:O1 SemiCommaVarDecl:S2 {: RESULT=new VarList(varName, O1, S2); RESULT.setLine(varNameleft); :} |
(ParamDefinitionError) error:err {: parser.log.debug("Error successfully recovered in variable definition before \",\" or \";\" on line " + errleft); :}  SemiCommaVarDecl:S1 {: RESULT=new ParamDefinitionError(S1); RESULT.setLine(S1left); :} 
;

SemiCommaVarDecl ::= (Semi) SEMI {: RESULT=new Semi(); :} | (CommaVarDecl) COMMA Var:V1 {: RESULT=new CommaVarDecl(V1); RESULT.setLine(V1left); :} ;

OptArrayBrackets ::= (ArrayType) LBRACK RBRACK {: RESULT=new ArrayType(); :} | (NoBrack) {: RESULT=new NoBrack(); :} /* epsilon */ ;

Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :} ;

/* July 2017/2018 Addition for level A */

MethodDecl ::= (MethodDecl) MethodTypeName:M1 LPAREN OptFormalParamList:O2 RPAREN OptVarDeclList:O3 LBRACE OptStatementList:O4 RBRACE {: RESULT=new MethodDecl(M1, O2, O3, O4); RESULT.setLine(M1left); :} ;

MethodTypeName ::= (MethodTypeName) MethodReturnType:retType IDENT:methodName {: RESULT=new MethodTypeName(retType, methodName); RESULT.setLine(retTypeleft); :} ;

MethodReturnType ::= (MethodReturnType) OptConst:O1 Type:T2 OptArrayBrackets:O3 {: RESULT=new MethodReturnType(O1, T2, O3); RESULT.setLine(O1left); :};

OptMethodDeclList ::= (MethodDeclList) MethodDecl:M1 OptMethodDeclList:O2 {: RESULT=new MethodDeclList(M1, O2); RESULT.setLine(M1left); :} | (NoMethodDecl) {: RESULT=new NoMethodDecl(); :} /* epsilon */ ;

OptFormalParamList ::= (FormalParamListOpt) FormalParamList:F1 {: RESULT=new FormalParamListOpt(F1); RESULT.setLine(F1left); :} | (NoFormalParam) {: RESULT=new NoFormalParam(); :} /* epsilon */ ;

FormalParamList ::= (FormalParamDeclList) FormalParamDecl:F1 COMMA FormalParamList:F2 {: RESULT=new FormalParamDeclList(F1, F2); RESULT.setLine(F1left); :} | (SingleFormalParamDecl) FormalParamDecl:F1 {: RESULT=new SingleFormalParamDecl(F1); RESULT.setLine(F1left); :} ;

FormalParamDecl ::= (FormalParamDecl) OptConst:O1 Type:T2 IDENT:I3 {: RESULT=new FormalParamDecl(O1, T2, I3); RESULT.setLine(O1left); :} ;

OptStatementList ::= (StatementList) Statement:S1 OptStatementList:O2 {: RESULT=new StatementList(S1, O2); RESULT.setLine(S1left); :} | (NoStatement) {: RESULT=new NoStatement(); :} /* epsilon */ ;

OptActualParamList ::= (ActualParams) ActualParamList:A1 {: RESULT=new ActualParams(A1); RESULT.setLine(A1left); :} | (NoActualParams) {: RESULT=new NoActualParams(); :} /* epsilon */ ;

ActualParamList ::= (MultipleActualParams) Expr:E1 COMMA ActualParamList:A2 {: RESULT=new MultipleActualParams(E1, A2); RESULT.setLine(E1left); :} | (ActualParam) Expr:E1 {: RESULT=new ActualParam(E1); RESULT.setLine(E1left); :} /* epsilon */ ;

/* End A  */
